// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_eks_cluster

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func EksClusterResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Version: 1,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "The ID of the EKS cluster.",
				MarkdownDescription: "The ID of the EKS cluster.",
			},
		},
		Blocks: map[string]schema.Block{
			"cluster": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"kind": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The resource kind.",
							MarkdownDescription: "The resource kind.",
							Default:             stringdefault.StaticString("Cluster"),
						},
					},
					Blocks: map[string]schema.Block{
						"metadata": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"labels": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "The labels for the cluster in Rafay console.",
										MarkdownDescription: "The labels for the cluster in Rafay console.",
									},
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the EKS cluster in Rafay console.",
										MarkdownDescription: "The name of the EKS cluster in Rafay console.",
									},
									"project": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the Rafay project the cluster will be created in.",
										MarkdownDescription: "The name of the Rafay project the cluster will be created in.",
									},
								},
								CustomType: MetadataType{
									ObjectType: types.ObjectType{
										AttrTypes: MetadataValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"spec": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"blueprint": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The name of the blueprint to use for the EKS cluster.",
										MarkdownDescription: "The name of the blueprint to use for the EKS cluster.",
										Default:             stringdefault.StaticString("default"),
									},
									"blueprint_version": schema.StringAttribute{
										Optional:            true,
										Description:         "The blueprint version.",
										MarkdownDescription: "The blueprint version.",
									},
									"cloud_provider": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the cloud provider for EKS cluster.",
										MarkdownDescription: "The name of the cloud provider for EKS cluster.",
									},
									"cni_provider": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The CNI provider to use for the EKS cluster.",
										MarkdownDescription: "The CNI provider to use for the EKS cluster.",
										Default:             stringdefault.StaticString("aws-cni"),
									},
									"cross_account_role_arn": schema.StringAttribute{
										Optional:            true,
										Description:         "Role ARN of the linked account.",
										MarkdownDescription: "Role ARN of the linked account.",
									},
									"proxy_config": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Proxy configuration for the EKS cluster.",
										MarkdownDescription: "Proxy configuration for the EKS cluster.",
									},
									"type": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The type of the cluster.",
										MarkdownDescription: "The type of the cluster.",
										Default:             stringdefault.StaticString("aws-eks"),
									},
								},
								Blocks: map[string]schema.Block{
									"cni_params": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"custom_cni_cidr": schema.StringAttribute{
													Optional:            true,
													Description:         "Secondary IPv4 CIDR block for the VPC. This should be specified if you choose to auto-create VPC and subnets while creating the EKS cluster.",
													MarkdownDescription: "Secondary IPv4 CIDR block for the VPC. This should be specified if you choose to auto-create VPC and subnets while creating the EKS cluster.",
												},
											},
											Blocks: map[string]schema.Block{
												"custom_cni_crd_spec": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																Optional:            true,
																Description:         "The name of the Availability Zone (AZ). The availability zone specified here should be a part of the region specified for the EKS cluster.",
																MarkdownDescription: "The name of the Availability Zone (AZ). The availability zone specified here should be a part of the region specified for the EKS cluster.",
															},
														},
														Blocks: map[string]schema.Block{
															"cni_spec": schema.SetNestedBlock{
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																		"security_groups": schema.SetAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "The security groups associated with secondary ENIs for AWS EC2 nodes.",
																			MarkdownDescription: "The security groups associated with secondary ENIs for AWS EC2 nodes.",
																		},
																		"subnet": schema.StringAttribute{
																			Optional:            true,
																			Description:         "The subnet associated with secondary ENIs for AWS EC2 nodes.",
																			MarkdownDescription: "The subnet associated with secondary ENIs for AWS EC2 nodes.",
																		},
																	},
																	CustomType: CniSpecType{
																		ObjectType: types.ObjectType{
																			AttrTypes: CniSpecValue{}.AttributeTypes(ctx),
																		},
																	},
																},
															},
														},
														CustomType: CustomCniCrdSpecType{
															ObjectType: types.ObjectType{
																AttrTypes: CustomCniCrdSpecValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: CniParamsType{
												ObjectType: types.ObjectType{
													AttrTypes: CniParamsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"sharing": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"enabled": schema.BoolAttribute{
													Optional:            true,
													Description:         "Whether to enable cluster sharing.",
													MarkdownDescription: "Whether to enable cluster sharing.",
												},
											},
											Blocks: map[string]schema.Block{
												"projects": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																Required:            true,
																Description:         "The name of the project to share the cluster with.",
																MarkdownDescription: "The name of the project to share the cluster with.",
															},
														},
														CustomType: ProjectsType{
															ObjectType: types.ObjectType{
																AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: SharingType{
												ObjectType: types.ObjectType{
													AttrTypes: SharingValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"system_components_placement": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"node_selector": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "Key-Value pairs insuring pods to be scheduled on desired nodes.",
													MarkdownDescription: "Key-Value pairs insuring pods to be scheduled on desired nodes.",
												},
											},
											Blocks: map[string]schema.Block{
												"daemonset_override": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"node_selection_enabled": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "Whether to enable node selection for the daemonset.",
																MarkdownDescription: "Whether to enable node selection for the daemonset.",
																Default:             booldefault.StaticBool(false),
															},
														},
														Blocks: map[string]schema.Block{
															"tolerations": schema.ListNestedBlock{
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																		"effect": schema.StringAttribute{
																			Optional:            true,
																			Description:         "indicates the taint effect to match.",
																			MarkdownDescription: "indicates the taint effect to match.",
																		},
																		"key": schema.StringAttribute{
																			Optional:            true,
																			Description:         "the taint key that the toleration applies to.",
																			MarkdownDescription: "the taint key that the toleration applies to.",
																		},
																		"operator": schema.StringAttribute{
																			Optional:            true,
																			Description:         "represents a key's relationship to the value.",
																			MarkdownDescription: "represents a key's relationship to the value.",
																		},
																		"toleration_seconds": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "represents the period of time the toleration tolerates the taint.",
																			MarkdownDescription: "represents the period of time the toleration tolerates the taint.",
																		},
																		"value": schema.StringAttribute{
																			Optional:            true,
																			Description:         "the taint value the toleration matches to.",
																			MarkdownDescription: "the taint value the toleration matches to.",
																		},
																	},
																	CustomType: Tolerations2Type{
																		ObjectType: types.ObjectType{
																			AttrTypes: Tolerations2Value{}.AttributeTypes(ctx),
																		},
																	},
																},
															},
														},
														CustomType: DaemonsetOverrideType{
															ObjectType: types.ObjectType{
																AttrTypes: DaemonsetOverrideValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
												"tolerations": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"effect": schema.StringAttribute{
																Optional:            true,
																Description:         "indicates the taint effect to match.",
																MarkdownDescription: "indicates the taint effect to match.",
															},
															"key": schema.StringAttribute{
																Optional:            true,
																Description:         "the taint key that the toleration applies to.",
																MarkdownDescription: "the taint key that the toleration applies to.",
															},
															"operator": schema.StringAttribute{
																Optional:            true,
																Description:         "represents a key's relationship to the value.",
																MarkdownDescription: "represents a key's relationship to the value.",
															},
															"toleration_seconds": schema.Int64Attribute{
																Optional:            true,
																Description:         "represents the period of time the toleration tolerates the taint.",
																MarkdownDescription: "represents the period of time the toleration tolerates the taint.",
															},
															"value": schema.StringAttribute{
																Optional:            true,
																Description:         "the taint value the toleration matches to.",
																MarkdownDescription: "the taint value the toleration matches to.",
															},
														},
														CustomType: TolerationsType{
															ObjectType: types.ObjectType{
																AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: SystemComponentsPlacementType{
												ObjectType: types.ObjectType{
													AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: SpecType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
					},
					CustomType: ClusterType{
						ObjectType: types.ObjectType{
							AttrTypes: ClusterValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"cluster_config": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"apiversion": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The Rafay API version of the EKS cluster.",
							MarkdownDescription: "The Rafay API version of the EKS cluster.",
							Default:             stringdefault.StaticString("rafay.io/v1alpha5"),
						},
						"availability_zones": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "A list of availability zones for the cluster.",
							MarkdownDescription: "A list of availability zones for the cluster.",
						},
						"kind": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The kind of the resource.",
							MarkdownDescription: "The kind of the resource.",
							Default:             stringdefault.StaticString("ClusterConfig"),
						},
						"managed_nodegroups_map": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ami": schema.StringAttribute{
										Optional:            true,
										Description:         "Specify custom AMIs, auto-ssm, auto, or static.",
										MarkdownDescription: "Specify custom AMIs, auto-ssm, auto, or static.",
									},
									"ami_family": schema.StringAttribute{
										Optional:            true,
										Description:         "The AMI family for the node group.",
										MarkdownDescription: "The AMI family for the node group.",
									},
									"asg_suspend_processes": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of autoscaling processes to suspend.",
										MarkdownDescription: "List of autoscaling processes to suspend.",
									},
									"availability_zones": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Limit nodes to specific AZs",
										MarkdownDescription: "Limit nodes to specific AZs",
									},
									"bottle_rocket": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enable_admin_container": schema.BoolAttribute{
												Optional:            true,
												Description:         "Enable admin container.",
												MarkdownDescription: "Enable admin container.",
											},
											"settings": schema.StringAttribute{
												Optional:            true,
												Description:         "contains any bottlerocket settings",
												MarkdownDescription: "contains any bottlerocket settings",
											},
										},
										CustomType: BottleRocket5Type{
											ObjectType: types.ObjectType{
												AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"desired_capacity": schema.Int64Attribute{
										Optional:            true,
										Description:         "desired capacity of instances in the nodegroup",
										MarkdownDescription: "desired capacity of instances in the nodegroup",
									},
									"disable_imdsv1": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to disable IMDSv1 on the node group.",
										MarkdownDescription: "Whether to disable IMDSv1 on the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"disable_pods_imds": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to disable IMDS for pods in the node group.",
										MarkdownDescription: "Whether to disable IMDS for pods in the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"ebs_optimized": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enables EBS optimization.",
										MarkdownDescription: "enables EBS optimization.",
										Default:             booldefault.StaticBool(false),
									},
									"efa_enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										MarkdownDescription: "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										Default:             booldefault.StaticBool(false),
									},
									"enable_detailed_monitoring": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable EC2 detailed monitoring",
										MarkdownDescription: "Enable EC2 detailed monitoring",
										Default:             booldefault.StaticBool(false),
									},
									"iam": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"attach_policy": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"id": schema.StringAttribute{
														Optional:            true,
														Description:         "Attach policy ID.",
														MarkdownDescription: "Attach policy ID.",
													},
													"statement": schema.SetNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"action": schema.SetAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "Attach policy action",
																	MarkdownDescription: "Attach policy action",
																},
																"condition": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy condition",
																	MarkdownDescription: "Attach policy condition",
																},
																"effect": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy effect",
																	MarkdownDescription: "Attach policy effect",
																},
																"not_action": schema.SetAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "Attach policy not_action",
																	MarkdownDescription: "Attach policy not_action",
																},
																"not_principal": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy not_principal",
																	MarkdownDescription: "Attach policy not_principal",
																},
																"not_resource": schema.SetAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "Attach policy not_resource",
																	MarkdownDescription: "Attach policy not_resource",
																},
																"principal": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy principal",
																	MarkdownDescription: "Attach policy principal",
																},
																"resource": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy resource",
																	MarkdownDescription: "Attach policy resource",
																},
																"sid": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy sid",
																	MarkdownDescription: "Attach policy sid",
																},
															},
															CustomType: Statement5Type{
																ObjectType: types.ObjectType{
																	AttrTypes: Statement5Value{}.AttributeTypes(ctx),
																},
															},
														},
														Optional: true,
													},
													"version": schema.StringAttribute{
														Optional:            true,
														Description:         "Attach policy version.",
														MarkdownDescription: "Attach policy version.",
													},
												},
												CustomType: AttachPolicy5Type{
													ObjectType: types.ObjectType{
														AttrTypes: AttachPolicy5Value{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
											},
											"attach_policy_arns": schema.SetAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "Attach policy ARNs.",
												MarkdownDescription: "Attach policy ARNs.",
											},
											"attach_policy_v2": schema.StringAttribute{
												Optional:            true,
												Description:         "Attach policy v2.",
												MarkdownDescription: "Attach policy v2.",
											},
											"iam_node_group_with_addon_policies": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"alb_ingress": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"app_mesh": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"app_mesh_review": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"auto_scaler": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(true),
													},
													"cert_manager": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"cloud_watch": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"ebs": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"efs": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"external_dns": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"fsx": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"image_builder": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(true),
													},
													"xray": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
												},
												CustomType: IamNodeGroupWithAddonPolicies5Type{
													ObjectType: types.ObjectType{
														AttrTypes: IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
											},
											"instance_profile_arn": schema.StringAttribute{
												Optional:            true,
												Description:         "Instance profile ARN.",
												MarkdownDescription: "Instance profile ARN.",
											},
											"instance_role_arn": schema.StringAttribute{
												Optional:            true,
												Description:         "Instance role ARN.",
												MarkdownDescription: "Instance role ARN.",
											},
											"instance_role_name": schema.StringAttribute{
												Optional:            true,
												Description:         "Instance role name.",
												MarkdownDescription: "Instance role name.",
											},
											"instance_role_permission_boundary": schema.StringAttribute{
												Optional:            true,
												Description:         "Instance role permission boundary.",
												MarkdownDescription: "Instance role permission boundary.",
											},
										},
										CustomType: Iam5Type{
											ObjectType: types.ObjectType{
												AttrTypes: Iam5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"instance_name": schema.StringAttribute{
										Optional:            true,
										Description:         "Name for the instance.",
										MarkdownDescription: "Name for the instance.",
									},
									"instance_prefix": schema.StringAttribute{
										Optional:            true,
										Description:         "Prefix for the instance name.",
										MarkdownDescription: "Prefix for the instance name.",
									},
									"instance_selector": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"cpu_architecture": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'",
												MarkdownDescription: "CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'",
												Default:             stringdefault.StaticString("x86_64"),
											},
											"gpus": schema.Int64Attribute{
												Optional:            true,
												Description:         "specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.",
												MarkdownDescription: "specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.",
											},
											"memory": schema.StringAttribute{
												Optional:            true,
												Description:         "specifies the memory The unit defaults to GiB.",
												MarkdownDescription: "specifies the memory The unit defaults to GiB.",
											},
											"vcpus": schema.Int64Attribute{
												Optional:            true,
												Description:         "specifies the number of vCPUs.",
												MarkdownDescription: "specifies the number of vCPUs.",
											},
										},
										CustomType: InstanceSelector5Type{
											ObjectType: types.ObjectType{
												AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"instance_type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of EC2 instance to use for the nodes in this group.",
										MarkdownDescription: "The type of EC2 instance to use for the nodes in this group.",
									},
									"instance_types": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of instance types for the node group.",
										MarkdownDescription: "List of instance types for the node group.",
									},
									"labels": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of labels to assign to the nodes in the group.",
										MarkdownDescription: "A map of labels to assign to the nodes in the group.",
									},
									"launch_template": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"id": schema.StringAttribute{
												Optional:            true,
												Description:         "ID of the launch template.",
												MarkdownDescription: "ID of the launch template.",
											},
											"version": schema.StringAttribute{
												Optional:            true,
												Description:         "Version of the launch template.",
												MarkdownDescription: "Version of the launch template.",
											},
										},
										CustomType: LaunchTemplate5Type{
											ObjectType: types.ObjectType{
												AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"max_pods_per_node": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"max_size": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"min_size": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"node_repair_config": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Optional:            true,
												Description:         "Enable node repair for nodegroup.",
												MarkdownDescription: "Enable node repair for nodegroup.",
											},
										},
										CustomType: NodeRepairConfig5Type{
											ObjectType: types.ObjectType{
												AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"override_bootstrap_command": schema.StringAttribute{
										Optional:            true,
										Description:         "Override the vendor's bootstrapping script.",
										MarkdownDescription: "Override the vendor's bootstrapping script.",
									},
									"placement": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"group": schema.StringAttribute{
												Optional:            true,
												Description:         "placement group name.",
												MarkdownDescription: "placement group name.",
											},
										},
										CustomType: Placement5Type{
											ObjectType: types.ObjectType{
												AttrTypes: Placement5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"pre_bootstrap_commands": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "executed before bootstrapping instances to the cluster.",
										MarkdownDescription: "executed before bootstrapping instances to the cluster.",
									},
									"private_networking": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable private networking for the node group.",
										MarkdownDescription: "Enable private networking for the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"security_groups": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"attach_ids": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "attaches additional security groups to the nodegroup",
												MarkdownDescription: "attaches additional security groups to the nodegroup",
											},
											"with_local": schema.BoolAttribute{
												Optional:            true,
												Description:         "attach a security group local to this nodegroup Not supported for managed nodegroups",
												MarkdownDescription: "attach a security group local to this nodegroup Not supported for managed nodegroups",
											},
											"with_shared": schema.BoolAttribute{
												Optional:            true,
												Description:         "attach the security group shared among all nodegroups in the cluster",
												MarkdownDescription: "attach the security group shared among all nodegroups in the cluster",
											},
										},
										CustomType: SecurityGroups5Type{
											ObjectType: types.ObjectType{
												AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"spot": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to use spot instances for the node group.",
										MarkdownDescription: "Whether to use spot instances for the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"ssh": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"allow": schema.BoolAttribute{
												Optional:            true,
												Description:         "If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured.",
												MarkdownDescription: "If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured.",
											},
											"enable_ssm": schema.BoolAttribute{
												Optional:            true,
												Description:         "Enables the ability to SSH onto nodes using SSM.",
												MarkdownDescription: "Enables the ability to SSH onto nodes using SSM.",
											},
											"public_key": schema.StringAttribute{
												Optional:            true,
												Description:         "Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
												MarkdownDescription: "Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
											},
											"public_key_name": schema.StringAttribute{
												Optional:            true,
												Description:         "Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
												MarkdownDescription: "Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
											},
											"source_security_group_ids": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "source securitgy group IDs.",
												MarkdownDescription: "source securitgy group IDs.",
											},
										},
										CustomType: Ssh5Type{
											ObjectType: types.ObjectType{
												AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"subnets": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Limit nodes to specific subnets.",
										MarkdownDescription: "Limit nodes to specific subnets.",
									},
									"tags": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed).",
										MarkdownDescription: "Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed).",
									},
									"taints": schema.SetNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"effect": schema.StringAttribute{
													Optional:            true,
													Description:         "effect of the taint.",
													MarkdownDescription: "effect of the taint.",
												},
												"key": schema.StringAttribute{
													Optional:            true,
													Description:         "key of the taint.",
													MarkdownDescription: "key of the taint.",
												},
												"value": schema.StringAttribute{
													Optional:            true,
													Description:         "value of the taint.",
													MarkdownDescription: "value of the taint.",
												},
											},
											CustomType: Taints5Type{
												ObjectType: types.ObjectType{
													AttrTypes: Taints5Value{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
									"update_config": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"max_unavailable": schema.Int64Attribute{
												Optional:            true,
												Description:         "max unavailable nodes during update.",
												MarkdownDescription: "max unavailable nodes during update.",
											},
											"max_unavailable_percentage": schema.Int64Attribute{
												Optional:            true,
												Description:         "max unavailable percentage during update.",
												MarkdownDescription: "max unavailable percentage during update.",
											},
										},
										CustomType: UpdateConfig5Type{
											ObjectType: types.ObjectType{
												AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"version": schema.StringAttribute{
										Optional:            true,
										Description:         "Kuberenetes version for the nodegroup.",
										MarkdownDescription: "Kuberenetes version for the nodegroup.",
									},
									"volume_encrypted": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "whether to encrypt volumes attached to instances in the nodegroup.",
										MarkdownDescription: "whether to encrypt volumes attached to instances in the nodegroup.",
										Default:             booldefault.StaticBool(false),
									},
									"volume_iops": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										MarkdownDescription: "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										Default:             int64default.StaticInt64(3000),
									},
									"volume_kms_key_id": schema.StringAttribute{
										Optional:            true,
										Description:         "of volumes attached to instances in the nodegroup.",
										MarkdownDescription: "of volumes attached to instances in the nodegroup.",
									},
									"volume_name": schema.StringAttribute{
										Optional:            true,
										Description:         "of volumes attached to instances in the nodegroup.",
										MarkdownDescription: "of volumes attached to instances in the nodegroup.",
									},
									"volume_size": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										MarkdownDescription: "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										Default:             int64default.StaticInt64(80),
									},
									"volume_throughput": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										MarkdownDescription: "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										Default:             int64default.StaticInt64(125),
									},
									"volume_type": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The type of EBS volume to use for the nodes in this group.",
										MarkdownDescription: "The type of EBS volume to use for the nodes in this group.",
										Default:             stringdefault.StaticString("gp3"),
									},
								},
								CustomType: ManagedNodegroupsMapType{
									ObjectType: types.ObjectType{
										AttrTypes: ManagedNodegroupsMapValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Map of managed node group names to their configurations. Each key is the name of the managed node group, and the value is an object containing the configuration for that managed node group.",
							MarkdownDescription: "Map of managed node group names to their configurations. Each key is the name of the managed node group, and the value is an object containing the configuration for that managed node group.",
						},
						"node_groups_map": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ami": schema.StringAttribute{
										Optional:            true,
										Description:         "Specify custom AMIs, auto-ssm, auto, or static.",
										MarkdownDescription: "Specify custom AMIs, auto-ssm, auto, or static.",
									},
									"ami_family": schema.StringAttribute{
										Optional: true,
									},
									"asg_metrics_collection6": schema.SetNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"granularity": schema.StringAttribute{
													Optional:            true,
													Description:         "of metrics collected.",
													MarkdownDescription: "of metrics collected.",
												},
												"metrics": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "list of metrics to collect. Valid values are: GroupMinSize, GroupMaxSize, GroupDesiredCapacity, GroupInServiceInstances, GroupPendingInstances, GroupStandbyInstances, GroupTerminatingInstances, GroupTotalInstances.",
													MarkdownDescription: "list of metrics to collect. Valid values are: GroupMinSize, GroupMaxSize, GroupDesiredCapacity, GroupInServiceInstances, GroupPendingInstances, GroupStandbyInstances, GroupTerminatingInstances, GroupTotalInstances.",
												},
											},
											CustomType: AsgMetricsCollection6Type{
												ObjectType: types.ObjectType{
													AttrTypes: AsgMetricsCollection6Value{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
									"asg_suspend_processes": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of autoscaling processes to suspend.",
										MarkdownDescription: "List of autoscaling processes to suspend.",
									},
									"availability_zones2": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Limit nodes to specific AZs",
										MarkdownDescription: "Limit nodes to specific AZs",
									},
									"bottle_rocket": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enable_admin_container": schema.BoolAttribute{
												Optional:            true,
												Description:         "Enable admin container.",
												MarkdownDescription: "Enable admin container.",
											},
											"settings": schema.StringAttribute{
												Optional:            true,
												Description:         "contains any bottlerocket settings",
												MarkdownDescription: "contains any bottlerocket settings",
											},
										},
										CustomType: BottleRocket6Type{
											ObjectType: types.ObjectType{
												AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"classic_load_balancer_names": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Associate load balancers with auto scaling group.",
										MarkdownDescription: "Associate load balancers with auto scaling group.",
									},
									"cluster_dns": schema.StringAttribute{
										Optional:            true,
										Description:         "Custom address used for DNS lookups.",
										MarkdownDescription: "Custom address used for DNS lookups.",
									},
									"cpu_credits": schema.StringAttribute{
										Optional:            true,
										Description:         "configures T3 Unlimited, valid only for T-type instances",
										MarkdownDescription: "configures T3 Unlimited, valid only for T-type instances",
									},
									"desired_capacity": schema.Int64Attribute{
										Optional: true,
									},
									"disable_imdsv1": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to disable IMDSv1 on the node group.",
										MarkdownDescription: "Whether to disable IMDSv1 on the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"disable_pods_imds": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to disable IMDS for pods in the node group.",
										MarkdownDescription: "Whether to disable IMDS for pods in the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"ebs_optimized": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enables EBS optimization.",
										MarkdownDescription: "enables EBS optimization.",
										Default:             booldefault.StaticBool(false),
									},
									"efa_enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										MarkdownDescription: "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										Default:             booldefault.StaticBool(false),
									},
									"enable_detailed_monitoring": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable EC2 detailed monitoring",
										MarkdownDescription: "Enable EC2 detailed monitoring",
										Default:             booldefault.StaticBool(false),
									},
									"iam": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"attach_policy": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"id": schema.StringAttribute{
														Optional:            true,
														Description:         "Attach policy ID.",
														MarkdownDescription: "Attach policy ID.",
													},
													"statement": schema.SetNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"action": schema.SetAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "Attach policy action",
																	MarkdownDescription: "Attach policy action",
																},
																"condition": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy condition",
																	MarkdownDescription: "Attach policy condition",
																},
																"effect": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy effect",
																	MarkdownDescription: "Attach policy effect",
																},
																"not_action": schema.SetAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "Attach policy not_action",
																	MarkdownDescription: "Attach policy not_action",
																},
																"not_principal": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy not_principal",
																	MarkdownDescription: "Attach policy not_principal",
																},
																"not_resource": schema.SetAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "Attach policy not_resource",
																	MarkdownDescription: "Attach policy not_resource",
																},
																"principal": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy principal",
																	MarkdownDescription: "Attach policy principal",
																},
																"resource": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy resource",
																	MarkdownDescription: "Attach policy resource",
																},
																"sid": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Attach policy sid",
																	MarkdownDescription: "Attach policy sid",
																},
															},
															CustomType: Statement6Type{
																ObjectType: types.ObjectType{
																	AttrTypes: Statement6Value{}.AttributeTypes(ctx),
																},
															},
														},
														Optional: true,
													},
													"version": schema.StringAttribute{
														Optional:            true,
														Description:         "Attach policy version.",
														MarkdownDescription: "Attach policy version.",
													},
												},
												CustomType: AttachPolicy6Type{
													ObjectType: types.ObjectType{
														AttrTypes: AttachPolicy6Value{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
											},
											"attach_policy_arns": schema.SetAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "Attach policy ARNs.",
												MarkdownDescription: "Attach policy ARNs.",
											},
											"attach_policy_v2": schema.StringAttribute{
												Optional:            true,
												Description:         "Attach policy v2.",
												MarkdownDescription: "Attach policy v2.",
											},
											"iam_node_group_with_addon_policies": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"alb_ingress": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"app_mesh": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"app_mesh_review": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"auto_scaler": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(true),
													},
													"cert_manager": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"cloud_watch": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"ebs": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"efs": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"external_dns": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"fsx": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
													"image_builder": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(true),
													},
													"xray": schema.BoolAttribute{
														Optional: true,
														Computed: true,
														Default:  booldefault.StaticBool(false),
													},
												},
												CustomType: IamNodeGroupWithAddonPolicies6Type{
													ObjectType: types.ObjectType{
														AttrTypes: IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
											},
											"instance_profile_arn": schema.StringAttribute{
												Optional:            true,
												Description:         "Instance profile ARN.",
												MarkdownDescription: "Instance profile ARN.",
											},
											"instance_role_arn": schema.StringAttribute{
												Optional:            true,
												Description:         "Instance role ARN.",
												MarkdownDescription: "Instance role ARN.",
											},
											"instance_role_name": schema.StringAttribute{
												Optional:            true,
												Description:         "Instance role name.",
												MarkdownDescription: "Instance role name.",
											},
											"instance_role_permission_boundary": schema.StringAttribute{
												Optional:            true,
												Description:         "Instance role permission boundary.",
												MarkdownDescription: "Instance role permission boundary.",
											},
										},
										CustomType: Iam6Type{
											ObjectType: types.ObjectType{
												AttrTypes: Iam6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"instance_name": schema.StringAttribute{
										Optional:            true,
										Description:         "Name for the instance.",
										MarkdownDescription: "Name for the instance.",
									},
									"instance_prefix": schema.StringAttribute{
										Optional:            true,
										Description:         "Prefix for the instance name.",
										MarkdownDescription: "Prefix for the instance name.",
									},
									"instance_selector": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"cpu_architecture": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'",
												MarkdownDescription: "CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'",
												Default:             stringdefault.StaticString("x86_64"),
											},
											"gpus": schema.Int64Attribute{
												Optional:            true,
												Description:         "specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.",
												MarkdownDescription: "specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.",
											},
											"memory": schema.StringAttribute{
												Optional:            true,
												Description:         "specifies the memory The unit defaults to GiB.",
												MarkdownDescription: "specifies the memory The unit defaults to GiB.",
											},
											"vcpus": schema.Int64Attribute{
												Optional:            true,
												Description:         "specifies the number of vCPUs.",
												MarkdownDescription: "specifies the number of vCPUs.",
											},
										},
										CustomType: InstanceSelector6Type{
											ObjectType: types.ObjectType{
												AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"instance_type": schema.StringAttribute{
										Required:            true,
										Description:         "The type of EC2 instance to use for the nodes in this group.",
										MarkdownDescription: "The type of EC2 instance to use for the nodes in this group.",
									},
									"instances_distribution": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"capacity_rebalance": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Enable capacity rebalancing for spot instances.",
												MarkdownDescription: "Enable capacity rebalancing for spot instances.",
												Default:             booldefault.StaticBool(false),
											},
											"instance_types": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "instance types.",
												MarkdownDescription: "instance types.",
											},
											"max_price": schema.Float64Attribute{
												Optional:            true,
												Description:         "Maximum bid price in USD.",
												MarkdownDescription: "Maximum bid price in USD.",
											},
											"on_demand_base_capacity": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "base number of on-demand instances (non-negative).",
												MarkdownDescription: "base number of on-demand instances (non-negative).",
												Default:             int64default.StaticInt64(0),
											},
											"on_demand_percentage_above_base_capacity": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "percentage of on-demand instances above base capacity (0-100).",
												MarkdownDescription: "percentage of on-demand instances above base capacity (0-100).",
												Default:             int64default.StaticInt64(100),
											},
											"spot_allocation_strategy": schema.StringAttribute{
												Optional:            true,
												Description:         "allocation strategy for spot instances. Valid values are capacity-optimized and lowest-price.",
												MarkdownDescription: "allocation strategy for spot instances. Valid values are capacity-optimized and lowest-price.",
											},
											"spot_instance_pools": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "number of spot instance pools to use (1-20).",
												MarkdownDescription: "number of spot instance pools to use (1-20).",
												Default:             int64default.StaticInt64(2),
											},
										},
										CustomType: InstancesDistribution6Type{
											ObjectType: types.ObjectType{
												AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"kubelet_extra_config6": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"eviction_hard": schema.MapAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "eviction hard resources.",
												MarkdownDescription: "eviction hard resources.",
											},
											"feature_gates": schema.MapAttribute{
												ElementType:         types.BoolType,
												Optional:            true,
												Description:         "feature gates.",
												MarkdownDescription: "feature gates.",
											},
											"kube_reserved": schema.MapAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "kube reserved resources.",
												MarkdownDescription: "kube reserved resources.",
											},
											"kube_reserved_cgroup": schema.StringAttribute{
												Optional:            true,
												Description:         "kube reserved cgroup.",
												MarkdownDescription: "kube reserved cgroup.",
											},
											"system_reserved": schema.MapAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "system reserved resources.",
												MarkdownDescription: "system reserved resources.",
											},
										},
										CustomType: KubeletExtraConfig6Type{
											ObjectType: types.ObjectType{
												AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"labels": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of labels to assign to the nodes in the group.",
										MarkdownDescription: "A map of labels to assign to the nodes in the group.",
									},
									"max_pods_per_node": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"max_size": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"min_size": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"override_bootstrap_command": schema.StringAttribute{
										Optional:            true,
										Description:         "Override the vendor's bootstrapping script.",
										MarkdownDescription: "Override the vendor's bootstrapping script.",
									},
									"placement": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"group": schema.StringAttribute{
												Optional:            true,
												Description:         "placement group name.",
												MarkdownDescription: "placement group name.",
											},
										},
										CustomType: Placement6Type{
											ObjectType: types.ObjectType{
												AttrTypes: Placement6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"pre_bootstrap_commands": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "executed before bootstrapping instances to the cluster.",
										MarkdownDescription: "executed before bootstrapping instances to the cluster.",
									},
									"private_networking": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable private networking for the node group.",
										MarkdownDescription: "Enable private networking for the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"security_groups": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"attach_ids": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "attaches additional security groups to the nodegroup",
												MarkdownDescription: "attaches additional security groups to the nodegroup",
											},
											"with_local": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "attach a security group local to this nodegroup Not supported for managed nodegroups",
												MarkdownDescription: "attach a security group local to this nodegroup Not supported for managed nodegroups",
												Default:             booldefault.StaticBool(true),
											},
											"with_shared": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "attach the security group shared among all nodegroups in the cluster",
												MarkdownDescription: "attach the security group shared among all nodegroups in the cluster",
												Default:             booldefault.StaticBool(true),
											},
										},
										CustomType: SecurityGroups6Type{
											ObjectType: types.ObjectType{
												AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"ssh": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"allow": schema.BoolAttribute{
												Optional:            true,
												Description:         "If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured.",
												MarkdownDescription: "If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured.",
											},
											"enable_ssm": schema.BoolAttribute{
												Optional:            true,
												Description:         "Enables the ability to SSH onto nodes using SSM.",
												MarkdownDescription: "Enables the ability to SSH onto nodes using SSM.",
											},
											"public_key": schema.StringAttribute{
												Optional:            true,
												Description:         "Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
												MarkdownDescription: "Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
											},
											"public_key_name": schema.StringAttribute{
												Optional:            true,
												Description:         "Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
												MarkdownDescription: "Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
											},
											"source_security_group_ids": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "source securitgy group IDs.",
												MarkdownDescription: "source securitgy group IDs.",
											},
										},
										CustomType: Ssh6Type{
											ObjectType: types.ObjectType{
												AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"subnet_cidr": schema.StringAttribute{
										Optional:            true,
										Description:         "Create new subnet from the CIDR block and limit nodes to this subnet (Applicable only for the WavelenghZone nodes).",
										MarkdownDescription: "Create new subnet from the CIDR block and limit nodes to this subnet (Applicable only for the WavelenghZone nodes).",
									},
									"subnets": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Limit nodes to specific subnets.",
										MarkdownDescription: "Limit nodes to specific subnets.",
									},
									"tags2": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed).",
										MarkdownDescription: "Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed).",
									},
									"taints": schema.SetNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"effect": schema.StringAttribute{
													Optional:            true,
													Description:         "effect of the taint.",
													MarkdownDescription: "effect of the taint.",
												},
												"key": schema.StringAttribute{
													Optional:            true,
													Description:         "key of the taint.",
													MarkdownDescription: "key of the taint.",
												},
												"value": schema.StringAttribute{
													Optional:            true,
													Description:         "value of the taint.",
													MarkdownDescription: "value of the taint.",
												},
											},
											CustomType: Taints6Type{
												ObjectType: types.ObjectType{
													AttrTypes: Taints6Value{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
									"target_group_arns": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Associate target group with auto scaling group.",
										MarkdownDescription: "Associate target group with auto scaling group.",
									},
									"update_config": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"max_unavaliable": schema.Int64Attribute{
												Optional:            true,
												Description:         "max unavaliable nodes during update.",
												MarkdownDescription: "max unavaliable nodes during update.",
											},
											"max_unavaliable_percetage": schema.Int64Attribute{
												Optional:            true,
												Description:         "max unavaliable percentage during update.",
												MarkdownDescription: "max unavaliable percentage during update.",
											},
										},
										CustomType: UpdateConfig6Type{
											ObjectType: types.ObjectType{
												AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"version": schema.StringAttribute{
										Optional:            true,
										Description:         "Kuberenetes version for the nodegroup.",
										MarkdownDescription: "Kuberenetes version for the nodegroup.",
									},
									"volume_encrypted": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "whether to encrypt volumes attached to instances in the nodegroup.",
										MarkdownDescription: "whether to encrypt volumes attached to instances in the nodegroup.",
										Default:             booldefault.StaticBool(false),
									},
									"volume_iops": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										MarkdownDescription: "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										Default:             int64default.StaticInt64(3000),
									},
									"volume_kms_key_id": schema.StringAttribute{
										Optional:            true,
										Description:         "of volumes attached to instances in the nodegroup.",
										MarkdownDescription: "of volumes attached to instances in the nodegroup.",
									},
									"volume_name": schema.StringAttribute{
										Optional:            true,
										Description:         "of volumes attached to instances in the nodegroup.",
										MarkdownDescription: "of volumes attached to instances in the nodegroup.",
									},
									"volume_size": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										MarkdownDescription: "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										Default:             int64default.StaticInt64(80),
									},
									"volume_throughput": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										MarkdownDescription: "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										Default:             int64default.StaticInt64(125),
									},
									"volume_type": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The type of EBS volume to use for the nodes in this group.",
										MarkdownDescription: "The type of EBS volume to use for the nodes in this group.",
										Default:             stringdefault.StaticString("gp3"),
									},
								},
								CustomType: NodeGroupsMapType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Map of node group names to their configurations. Each key is the name of the node group, and the value is an object containing the configuration for that node group.",
							MarkdownDescription: "Map of node group names to their configurations. Each key is the name of the node group, and the value is an object containing the configuration for that node group.",
						},
					},
					Blocks: map[string]schema.Block{
						"access_config": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"authentication_mode": schema.StringAttribute{
										Optional:            true,
										Description:         "configure which source the cluster will use for authenticated IAM principals. API or API_AND_CONFIG_MAP (default) or CONFIG_MAP",
										MarkdownDescription: "configure which source the cluster will use for authenticated IAM principals. API or API_AND_CONFIG_MAP (default) or CONFIG_MAP",
									},
									"bootstrap_cluster_creator_admin_permissions": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "choose whether the IAM principal creating the cluster has Kubernetes cluster administrator access.",
										MarkdownDescription: "choose whether the IAM principal creating the cluster has Kubernetes cluster administrator access.",
										Default:             booldefault.StaticBool(true),
									},
								},
								Blocks: map[string]schema.Block{
									"access_entries": schema.SetNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"kubernetes_groups": schema.SetAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "set of Kubernetes groups to map to the principal ARN.",
													MarkdownDescription: "set of Kubernetes groups to map to the principal ARN.",
												},
												"kubernetes_username": schema.StringAttribute{
													Optional:            true,
													Description:         "username to map to the principal ARN.",
													MarkdownDescription: "username to map to the principal ARN.",
												},
												"principal_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "the IAM principal that you want to grant access to Kubernetes objects on your cluster.",
													MarkdownDescription: "the IAM principal that you want to grant access to Kubernetes objects on your cluster.",
												},
												"tags": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "applied to the access entries.",
													MarkdownDescription: "applied to the access entries.",
												},
												"type": schema.StringAttribute{
													Optional:            true,
													Description:         "EC2_LINUX, EC2_WINDOWS, FARGATE_LINUX or STANDARD.",
													MarkdownDescription: "EC2_LINUX, EC2_WINDOWS, FARGATE_LINUX or STANDARD.",
												},
											},
											Blocks: map[string]schema.Block{
												"access_policies": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"policy_arn": schema.StringAttribute{
																Optional:            true,
																Description:         "the ARN of the IAM policy that you want to attach to the access entry.",
																MarkdownDescription: "the ARN of the IAM policy that you want to attach to the access entry.",
															},
														},
														Blocks: map[string]schema.Block{
															"access_scope": schema.SetNestedBlock{
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																		"namespaces": schema.SetAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "Scope access to namespace(s).",
																			MarkdownDescription: "Scope access to namespace(s).",
																		},
																		"type": schema.StringAttribute{
																			Optional:            true,
																			Description:         "namespace or cluster.",
																			MarkdownDescription: "namespace or cluster.",
																		},
																	},
																	CustomType: AccessScopeType{
																		ObjectType: types.ObjectType{
																			AttrTypes: AccessScopeValue{}.AttributeTypes(ctx),
																		},
																	},
																},
															},
														},
														CustomType: AccessPoliciesType{
															ObjectType: types.ObjectType{
																AttrTypes: AccessPoliciesValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: AccessEntriesType{
												ObjectType: types.ObjectType{
													AttrTypes: AccessEntriesValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: AccessConfigType{
									ObjectType: types.ObjectType{
										AttrTypes: AccessConfigValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"addons": schema.SetNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"attach_policy_arns": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "list of ARNs of the IAM policies to attach",
										MarkdownDescription: "list of ARNs of the IAM policies to attach",
									},
									"attach_policy_v2": schema.StringAttribute{
										Optional:            true,
										Description:         "holds a policy document to attach to this addon in json string format",
										MarkdownDescription: "holds a policy document to attach to this addon in json string format",
									},
									"configuration_values": schema.StringAttribute{
										Optional:            true,
										Description:         "configuration values for the addon",
										MarkdownDescription: "configuration values for the addon",
									},
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "EKS addon name.",
										MarkdownDescription: "EKS addon name.",
									},
									"permissions_boundary": schema.StringAttribute{
										Optional:            true,
										Description:         "ARN of the permissions boundary to associate",
										MarkdownDescription: "ARN of the permissions boundary to associate",
									},
									"service_account_role_arn": schema.StringAttribute{
										Optional:            true,
										Description:         "service account role ARN",
										MarkdownDescription: "service account role ARN",
									},
									"tags": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "The metadata to apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define.",
										MarkdownDescription: "The metadata to apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define.",
									},
									"use_default_pod_identity_associations": schema.BoolAttribute{
										Optional:            true,
										Description:         "Flag to create pod identity association by default",
										MarkdownDescription: "Flag to create pod identity association by default",
									},
									"version": schema.StringAttribute{
										Optional:            true,
										Description:         "EKS addon version.",
										MarkdownDescription: "EKS addon version.",
									},
								},
								Blocks: map[string]schema.Block{
									"attach_policy": schema.SetNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Optional:            true,
													Description:         "Attach policy ID.",
													MarkdownDescription: "Attach policy ID.",
												},
												"version": schema.StringAttribute{
													Optional:            true,
													Description:         "Attach policy version.",
													MarkdownDescription: "Attach policy version.",
												},
											},
											Blocks: map[string]schema.Block{
												"statement": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"action": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "Attach policy action",
																MarkdownDescription: "Attach policy action",
															},
															"condition": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy condition",
																MarkdownDescription: "Attach policy condition",
															},
															"effect": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy effect",
																MarkdownDescription: "Attach policy effect",
															},
															"not_action": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "Attach policy not_action",
																MarkdownDescription: "Attach policy not_action",
															},
															"not_principal": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy not_principal",
																MarkdownDescription: "Attach policy not_principal",
															},
															"not_resource": schema.SetAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "Attach policy not_resource",
																MarkdownDescription: "Attach policy not_resource",
															},
															"principal": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy principal",
																MarkdownDescription: "Attach policy principal",
															},
															"resource": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy resource",
																MarkdownDescription: "Attach policy resource",
															},
															"sid": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy sid",
																MarkdownDescription: "Attach policy sid",
															},
														},
														CustomType: Statement2Type{
															ObjectType: types.ObjectType{
																AttrTypes: Statement2Value{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: AttachPolicy3Type{
												ObjectType: types.ObjectType{
													AttrTypes: AttachPolicy3Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"pod_identity_associations": schema.SetNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"create_service_account": schema.BoolAttribute{
													Optional:            true,
													Description:         "enable flag to create service account.",
													MarkdownDescription: "enable flag to create service account.",
												},
												"namespace": schema.StringAttribute{
													Required:            true,
													Description:         "namespace of service account.",
													MarkdownDescription: "namespace of service account.",
												},
												"permission_boundary_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "permission boundary ARN.",
													MarkdownDescription: "permission boundary ARN.",
												},
												"permission_policy": schema.StringAttribute{
													Optional:            true,
													Description:         "permission policy document.",
													MarkdownDescription: "permission policy document.",
												},
												"permission_policy_arns": schema.SetAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "permission policy ARNs.",
													MarkdownDescription: "permission policy ARNs.",
												},
												"role_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "role ARN of AWS role to associate with service account.",
													MarkdownDescription: "role ARN of AWS role to associate with service account.",
												},
												"role_name": schema.StringAttribute{
													Optional:            true,
													Description:         "aws role name to associate.",
													MarkdownDescription: "aws role name to associate.",
												},
												"service_account_name": schema.StringAttribute{
													Required:            true,
													Description:         "name of service account.",
													MarkdownDescription: "name of service account.",
												},
												"tags": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "AWS tags for the service account.",
													MarkdownDescription: "AWS tags for the service account.",
												},
											},
											Blocks: map[string]schema.Block{
												"well_known_policies": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"auto_scaler": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "service account annotations.",
																MarkdownDescription: "service account annotations.",
																Default:             booldefault.StaticBool(false),
															},
															"aws_load_balancer_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds policies for using the aws-load-balancer-controller.",
																MarkdownDescription: "adds policies for using the aws-load-balancer-controller.",
																Default:             booldefault.StaticBool(false),
															},
															"cert_manager": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds cert-manager policies.",
																MarkdownDescription: "adds cert-manager policies.",
																Default:             booldefault.StaticBool(false),
															},
															"ebs_csi_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds ebs-csi-controller policies.",
																MarkdownDescription: "adds ebs-csi-controller policies.",
																Default:             booldefault.StaticBool(false),
															},
															"efs_csi_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds policies for using the efs-csi-driver controller.",
																MarkdownDescription: "adds policies for using the efs-csi-driver controller.",
																Default:             booldefault.StaticBool(false),
															},
															"external_dns": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds external-dns policies for Amazon Route 53.",
																MarkdownDescription: "adds external-dns policies for Amazon Route 53.",
																Default:             booldefault.StaticBool(false),
															},
															"image_builder": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "allows for full ECR (Elastic Container Registry) access.",
																MarkdownDescription: "allows for full ECR (Elastic Container Registry) access.",
																Default:             booldefault.StaticBool(false),
															},
														},
														CustomType: WellKnownPolicies4Type{
															ObjectType: types.ObjectType{
																AttrTypes: WellKnownPolicies4Value{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: PodIdentityAssociations2Type{
												ObjectType: types.ObjectType{
													AttrTypes: PodIdentityAssociations2Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"well_known_policies": schema.SetNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"auto_scaler": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "service account annotations.",
													MarkdownDescription: "service account annotations.",
													Default:             booldefault.StaticBool(false),
												},
												"aws_load_balancer_controller": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "adds policies for using the aws-load-balancer-controller.",
													MarkdownDescription: "adds policies for using the aws-load-balancer-controller.",
													Default:             booldefault.StaticBool(false),
												},
												"cert_manager": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "adds cert-manager policies.",
													MarkdownDescription: "adds cert-manager policies.",
													Default:             booldefault.StaticBool(false),
												},
												"ebs_csi_controller": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "adds ebs-csi-controller policies.",
													MarkdownDescription: "adds ebs-csi-controller policies.",
													Default:             booldefault.StaticBool(false),
												},
												"efs_csi_controller": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "adds policies for using the efs-csi-driver controller.",
													MarkdownDescription: "adds policies for using the efs-csi-driver controller.",
													Default:             booldefault.StaticBool(false),
												},
												"external_dns": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "adds external-dns policies for Amazon Route 53.",
													MarkdownDescription: "adds external-dns policies for Amazon Route 53.",
													Default:             booldefault.StaticBool(false),
												},
												"image_builder": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "allows for full ECR (Elastic Container Registry) access.",
													MarkdownDescription: "allows for full ECR (Elastic Container Registry) access.",
													Default:             booldefault.StaticBool(false),
												},
											},
											CustomType: WellKnownPolicies3Type{
												ObjectType: types.ObjectType{
													AttrTypes: WellKnownPolicies3Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: AddonsType{
									ObjectType: types.ObjectType{
										AttrTypes: AddonsValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"addons_config": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"auto_apply_pod_identity_associations": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Flag to create pod identity by default for managed addons.",
										MarkdownDescription: "Flag to create pod identity by default for managed addons.",
										Default:             booldefault.StaticBool(false),
									},
									"disable_ebs_csi_driver": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "flag to enable or disable ebs csi driver.",
										MarkdownDescription: "flag to enable or disable ebs csi driver.",
										Default:             booldefault.StaticBool(false),
									},
								},
								CustomType: AddonsConfigType{
									ObjectType: types.ObjectType{
										AttrTypes: AddonsConfigValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"auto_mode_config": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "Flag to enable or disable auto mode.",
										MarkdownDescription: "Flag to enable or disable auto mode.",
									},
									"node_pools": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of default nodepools (general-purpose,system).",
										MarkdownDescription: "List of default nodepools (general-purpose,system).",
									},
									"node_role_arn": schema.StringAttribute{
										Optional:            true,
										Description:         "RoleARN of the nodes.",
										MarkdownDescription: "RoleARN of the nodes.",
									},
								},
								CustomType: AutoModeConfigType{
									ObjectType: types.ObjectType{
										AttrTypes: AutoModeConfigValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"cloud_watch": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Blocks: map[string]schema.Block{
									"cluster_logging": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"enable_types": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "Types of logging to enable. Valid entries are: 'api', 'audit', 'authenticator', 'controllerManager', 'scheduler', 'all', '*'.",
													MarkdownDescription: "Types of logging to enable. Valid entries are: 'api', 'audit', 'authenticator', 'controllerManager', 'scheduler', 'all', '*'.",
												},
												"log_retention_in_days": schema.Int64Attribute{
													Optional:            true,
													Description:         "Number of days to retain the log events in the specified log group.",
													MarkdownDescription: "Number of days to retain the log events in the specified log group.",
												},
											},
											CustomType: ClusterLoggingType{
												ObjectType: types.ObjectType{
													AttrTypes: ClusterLoggingValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: CloudWatchType{
									ObjectType: types.ObjectType{
										AttrTypes: CloudWatchValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"fargate_profiles": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Optional:            true,
										Description:         "The name of the fargate profile.",
										MarkdownDescription: "The name of the fargate profile.",
									},
									"pod_execution_role_arn": schema.StringAttribute{
										Optional:            true,
										Description:         "The ARN of the pod execution role to use for pods that match the selectors in the fargate profile.",
										MarkdownDescription: "The ARN of the pod execution role to use for pods that match the selectors in the fargate profile.",
									},
									"status": schema.StringAttribute{
										Optional:            true,
										Description:         "The status of the fargate profile.",
										MarkdownDescription: "The status of the fargate profile.",
									},
									"subnets": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "The IDs of the subnets to launch the fargate profile in.",
										MarkdownDescription: "The IDs of the subnets to launch the fargate profile in.",
									},
									"tags": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of tags to assign to the fargate profile.",
										MarkdownDescription: "A map of tags to assign to the fargate profile.",
									},
								},
								Blocks: map[string]schema.Block{
									"selectors": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"labels": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "A map of labels to match for the fargate profile.",
													MarkdownDescription: "A map of labels to match for the fargate profile.",
												},
												"namespace": schema.StringAttribute{
													Optional:            true,
													Description:         "The namespace to match for the fargate profile.",
													MarkdownDescription: "The namespace to match for the fargate profile.",
												},
											},
											CustomType: SelectorsType{
												ObjectType: types.ObjectType{
													AttrTypes: SelectorsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: FargateProfilesType{
									ObjectType: types.ObjectType{
										AttrTypes: FargateProfilesValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"iam": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"fargate_pod_execution_role_arn": schema.StringAttribute{
										Optional:            true,
										Description:         "role used by pods to access AWS APIs. This role is added to the Kubernetes RBAC for authorization.",
										MarkdownDescription: "role used by pods to access AWS APIs. This role is added to the Kubernetes RBAC for authorization.",
									},
									"fargate_pod_execution_role_permissions_boundary": schema.StringAttribute{
										Optional:            true,
										Description:         "permissions boundary for the fargate pod execution role.",
										MarkdownDescription: "permissions boundary for the fargate pod execution role.",
									},
									"service_role_arn": schema.StringAttribute{
										Optional:            true,
										Description:         "service role ARN of the cluster.",
										MarkdownDescription: "service role ARN of the cluster.",
									},
									"service_role_permission_boundary": schema.StringAttribute{
										Optional:            true,
										Description:         "permissions boundary for all identity-based entities created by the vendor.",
										MarkdownDescription: "permissions boundary for all identity-based entities created by the vendor.",
									},
									"vpc_resource_controller_policy": schema.BoolAttribute{
										Optional:            true,
										Description:         "attaches the IAM policy necessary to run the VPC controller in the control plane.",
										MarkdownDescription: "attaches the IAM policy necessary to run the VPC controller in the control plane.",
									},
									"with_oidc": schema.BoolAttribute{
										Optional:            true,
										Description:         "enables the IAM OIDC provider as well as IRSA for the Amazon CNI plugin.",
										MarkdownDescription: "enables the IAM OIDC provider as well as IRSA for the Amazon CNI plugin.",
									},
								},
								Blocks: map[string]schema.Block{
									"pod_identity_associations": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"create_service_account": schema.BoolAttribute{
													Optional:            true,
													Description:         "enable flag to create service account.",
													MarkdownDescription: "enable flag to create service account.",
												},
												"namespace": schema.StringAttribute{
													Required:            true,
													Description:         "namespace of service account.",
													MarkdownDescription: "namespace of service account.",
												},
												"permission_boundary_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "permission boundary ARN.",
													MarkdownDescription: "permission boundary ARN.",
												},
												"permission_policy": schema.StringAttribute{
													Optional:            true,
													Description:         "permission policy document.",
													MarkdownDescription: "permission policy document.",
												},
												"permission_policy_arns": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "permission policy ARNs.",
													MarkdownDescription: "permission policy ARNs.",
												},
												"role_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "role ARN of AWS role to associate with service account.",
													MarkdownDescription: "role ARN of AWS role to associate with service account.",
												},
												"role_name": schema.StringAttribute{
													Optional:            true,
													Description:         "aws role name to associate.",
													MarkdownDescription: "aws role name to associate.",
												},
												"service_account_name": schema.StringAttribute{
													Required:            true,
													Description:         "name of service account.",
													MarkdownDescription: "name of service account.",
												},
												"tags": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "AWS tags for the service account.",
													MarkdownDescription: "AWS tags for the service account.",
												},
											},
											Blocks: map[string]schema.Block{
												"well_known_policies": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"auto_scaler": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "service account annotations.",
																MarkdownDescription: "service account annotations.",
																Default:             booldefault.StaticBool(false),
															},
															"aws_load_balancer_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds policies for using the aws-load-balancer-controller.",
																MarkdownDescription: "adds policies for using the aws-load-balancer-controller.",
																Default:             booldefault.StaticBool(false),
															},
															"cert_manager": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds cert-manager policies.",
																MarkdownDescription: "adds cert-manager policies.",
																Default:             booldefault.StaticBool(false),
															},
															"ebs_csi_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds ebs-csi-controller policies.",
																MarkdownDescription: "adds ebs-csi-controller policies.",
																Default:             booldefault.StaticBool(false),
															},
															"efs_csi_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds policies for using the efs-csi-driver controller.",
																MarkdownDescription: "adds policies for using the efs-csi-driver controller.",
																Default:             booldefault.StaticBool(false),
															},
															"external_dns": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds external-dns policies for Amazon Route 53.",
																MarkdownDescription: "adds external-dns policies for Amazon Route 53.",
																Default:             booldefault.StaticBool(false),
															},
															"image_builder": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "allows for full ECR (Elastic Container Registry) access.",
																MarkdownDescription: "allows for full ECR (Elastic Container Registry) access.",
																Default:             booldefault.StaticBool(false),
															},
														},
														CustomType: WellKnownPoliciesType{
															ObjectType: types.ObjectType{
																AttrTypes: WellKnownPoliciesValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: PodIdentityAssociationsType{
												ObjectType: types.ObjectType{
													AttrTypes: PodIdentityAssociationsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"service_accounts": schema.SetNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attach_policy": schema.StringAttribute{
													Optional:            true,
													Description:         "holds a policy document to attach to this service account.",
													MarkdownDescription: "holds a policy document to attach to this service account.",
												},
												"attach_policy_arns": schema.SetAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "CIDR range from where ClusterIPs are assigned.",
													MarkdownDescription: "CIDR range from where ClusterIPs are assigned.",
												},
												"attach_role_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "ARN of the role to attach to the service account.",
													MarkdownDescription: "ARN of the role to attach to the service account.",
												},
												"permissions_boundary": schema.StringAttribute{
													Optional:            true,
													Description:         "ARN of the permissions boundary to associate with the service account.",
													MarkdownDescription: "ARN of the permissions boundary to associate with the service account.",
												},
												"role_name": schema.StringAttribute{
													Optional:            true,
													Description:         "Specific role name instead of the Cloudformation-generated role name.",
													MarkdownDescription: "Specific role name instead of the Cloudformation-generated role name.",
												},
												"role_only": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "Specify if only the IAM Service Account role should be created without creating/annotating the service account.",
													MarkdownDescription: "Specify if only the IAM Service Account role should be created without creating/annotating the service account.",
													Default:             booldefault.StaticBool(false),
												},
												"tags": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "AWS tags for the service account.",
													MarkdownDescription: "AWS tags for the service account.",
												},
											},
											Blocks: map[string]schema.Block{
												"metadata": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"annotations": schema.MapAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "Annotations to add to the service account.",
																MarkdownDescription: "Annotations to add to the service account.",
															},
															"labels": schema.MapAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "CIDR range from where ClusterIPs are assigned.",
																MarkdownDescription: "CIDR range from where ClusterIPs are assigned.",
															},
															"name": schema.StringAttribute{
																Optional:            true,
																Description:         "service account name.",
																MarkdownDescription: "service account name.",
															},
															"namespace": schema.StringAttribute{
																Optional:            true,
																Description:         "service account namespace.",
																MarkdownDescription: "service account namespace.",
															},
														},
														CustomType: Metadata3Type{
															ObjectType: types.ObjectType{
																AttrTypes: Metadata3Value{}.AttributeTypes(ctx),
															},
														},
													},
												},
												"status": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"role_arn": schema.StringAttribute{
																Optional:            true,
																Description:         "role ARN of the service account.",
																MarkdownDescription: "role ARN of the service account.",
															},
														},
														CustomType: StatusType{
															ObjectType: types.ObjectType{
																AttrTypes: StatusValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
												"well_known_policies": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"auto_scaler": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "service account annotations.",
																MarkdownDescription: "service account annotations.",
																Default:             booldefault.StaticBool(false),
															},
															"aws_load_balancer_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds policies for using the aws-load-balancer-controller.",
																MarkdownDescription: "adds policies for using the aws-load-balancer-controller.",
																Default:             booldefault.StaticBool(false),
															},
															"cert_manager": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds cert-manager policies.",
																MarkdownDescription: "adds cert-manager policies.",
																Default:             booldefault.StaticBool(false),
															},
															"ebs_csi_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds ebs-csi-controller policies.",
																MarkdownDescription: "adds ebs-csi-controller policies.",
																Default:             booldefault.StaticBool(false),
															},
															"efs_csi_controller": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds policies for using the efs-csi-driver controller.",
																MarkdownDescription: "adds policies for using the efs-csi-driver controller.",
																Default:             booldefault.StaticBool(false),
															},
															"external_dns": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "adds external-dns policies for Amazon Route 53.",
																MarkdownDescription: "adds external-dns policies for Amazon Route 53.",
																Default:             booldefault.StaticBool(false),
															},
															"image_builder": schema.BoolAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "allows for full ECR (Elastic Container Registry) access.",
																MarkdownDescription: "allows for full ECR (Elastic Container Registry) access.",
																Default:             booldefault.StaticBool(false),
															},
														},
														CustomType: WellKnownPolicies2Type{
															ObjectType: types.ObjectType{
																AttrTypes: WellKnownPolicies2Value{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: ServiceAccountsType{
												ObjectType: types.ObjectType{
													AttrTypes: ServiceAccountsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: Iam3Type{
									ObjectType: types.ObjectType{
										AttrTypes: Iam3Value{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"identity_mappings": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"accounts": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of IAM accounts to map.",
										MarkdownDescription: "List of IAM accounts to map.",
									},
								},
								Blocks: map[string]schema.Block{
									"arns": schema.SetNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"arn": schema.StringAttribute{
													Optional:            true,
													Description:         "IAM role or user ARN.",
													MarkdownDescription: "IAM role or user ARN.",
												},
												"group": schema.SetAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "List of kubernetes groups to be mapped to.",
													MarkdownDescription: "List of kubernetes groups to be mapped to.",
												},
												"username": schema.StringAttribute{
													Optional:            true,
													Description:         "The username to be used by kubernetes.",
													MarkdownDescription: "The username to be used by kubernetes.",
												},
											},
											CustomType: ArnsType{
												ObjectType: types.ObjectType{
													AttrTypes: ArnsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: IdentityMappingsType{
									ObjectType: types.ObjectType{
										AttrTypes: IdentityMappingsValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"identity_providers": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Valid variants are: 'oidc': OIDC identity provider",
										MarkdownDescription: "Valid variants are: 'oidc': OIDC identity provider",
										Default:             stringdefault.StaticString("oidc"),
									},
								},
								CustomType: IdentityProvidersType{
									ObjectType: types.ObjectType{
										AttrTypes: IdentityProvidersValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"kubernetes_network_config": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"ip_family": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The IP family for the Kubernetes network. Valid variants are: IPv4, IPv6",
										MarkdownDescription: "The IP family for the Kubernetes network. Valid variants are: IPv4, IPv6",
										Default:             stringdefault.StaticString("IPv4"),
									},
									"service_ipv4_cidr": schema.StringAttribute{
										Optional:            true,
										Description:         "CIDR range from where ClusterIPs are assigned.",
										MarkdownDescription: "CIDR range from where ClusterIPs are assigned.",
									},
								},
								CustomType: KubernetesNetworkConfigType{
									ObjectType: types.ObjectType{
										AttrTypes: KubernetesNetworkConfigValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"managed_nodegroups": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"ami": schema.StringAttribute{
										Optional:            true,
										Description:         "Specify custom AMIs, auto-ssm, auto, or static.",
										MarkdownDescription: "Specify custom AMIs, auto-ssm, auto, or static.",
									},
									"ami_family": schema.StringAttribute{
										Optional:            true,
										Description:         "The AMI family for the node group.",
										MarkdownDescription: "The AMI family for the node group.",
									},
									"asg_suspend_processes": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of autoscaling processes to suspend.",
										MarkdownDescription: "List of autoscaling processes to suspend.",
									},
									"availability_zones": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Limit nodes to specific AZs",
										MarkdownDescription: "Limit nodes to specific AZs",
									},
									"desired_capacity": schema.Int64Attribute{
										Optional:            true,
										Description:         "desired capacity of instances in the nodegroup",
										MarkdownDescription: "desired capacity of instances in the nodegroup",
									},
									"disable_imdsv1": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to disable IMDSv1 on the node group.",
										MarkdownDescription: "Whether to disable IMDSv1 on the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"disable_pods_imds": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to disable IMDS for pods in the node group.",
										MarkdownDescription: "Whether to disable IMDS for pods in the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"ebs_optimized": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enables EBS optimization.",
										MarkdownDescription: "enables EBS optimization.",
										Default:             booldefault.StaticBool(false),
									},
									"efa_enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										MarkdownDescription: "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										Default:             booldefault.StaticBool(false),
									},
									"enable_detailed_monitoring": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable EC2 detailed monitoring",
										MarkdownDescription: "Enable EC2 detailed monitoring",
										Default:             booldefault.StaticBool(false),
									},
									"instance_name": schema.StringAttribute{
										Optional:            true,
										Description:         "Name for the instance.",
										MarkdownDescription: "Name for the instance.",
									},
									"instance_prefix": schema.StringAttribute{
										Optional:            true,
										Description:         "Prefix for the instance name.",
										MarkdownDescription: "Prefix for the instance name.",
									},
									"instance_type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of EC2 instance to use for the nodes in this group.",
										MarkdownDescription: "The type of EC2 instance to use for the nodes in this group.",
									},
									"instance_types": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of instance types for the node group.",
										MarkdownDescription: "List of instance types for the node group.",
									},
									"labels": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of labels to assign to the nodes in the group.",
										MarkdownDescription: "A map of labels to assign to the nodes in the group.",
									},
									"max_pods_per_node": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"max_size": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"min_size": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the node group.",
										MarkdownDescription: "The name of the node group.",
									},
									"override_bootstrap_command": schema.StringAttribute{
										Optional:            true,
										Description:         "Override the vendor's bootstrapping script.",
										MarkdownDescription: "Override the vendor's bootstrapping script.",
									},
									"pre_bootstrap_commands": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "executed before bootstrapping instances to the cluster.",
										MarkdownDescription: "executed before bootstrapping instances to the cluster.",
									},
									"private_networking": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable private networking for the node group.",
										MarkdownDescription: "Enable private networking for the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"spot": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to use spot instances for the node group.",
										MarkdownDescription: "Whether to use spot instances for the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"subnets": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Limit nodes to specific subnets.",
										MarkdownDescription: "Limit nodes to specific subnets.",
									},
									"tags": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed).",
										MarkdownDescription: "Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed).",
									},
									"version": schema.StringAttribute{
										Optional:            true,
										Description:         "Kuberenetes version for the nodegroup.",
										MarkdownDescription: "Kuberenetes version for the nodegroup.",
									},
									"volume_encrypted": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "whether to encrypt volumes attached to instances in the nodegroup.",
										MarkdownDescription: "whether to encrypt volumes attached to instances in the nodegroup.",
										Default:             booldefault.StaticBool(false),
									},
									"volume_iops": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										MarkdownDescription: "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										Default:             int64default.StaticInt64(3000),
									},
									"volume_kms_key_id": schema.StringAttribute{
										Optional:            true,
										Description:         "of volumes attached to instances in the nodegroup.",
										MarkdownDescription: "of volumes attached to instances in the nodegroup.",
									},
									"volume_name": schema.StringAttribute{
										Optional:            true,
										Description:         "of volumes attached to instances in the nodegroup.",
										MarkdownDescription: "of volumes attached to instances in the nodegroup.",
									},
									"volume_size": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										MarkdownDescription: "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										Default:             int64default.StaticInt64(80),
									},
									"volume_throughput": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										MarkdownDescription: "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										Default:             int64default.StaticInt64(125),
									},
									"volume_type": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The type of EBS volume to use for the nodes in this group.",
										MarkdownDescription: "The type of EBS volume to use for the nodes in this group.",
										Default:             stringdefault.StaticString("gp3"),
									},
								},
								Blocks: map[string]schema.Block{
									"bottle_rocket": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"enable_admin_container": schema.BoolAttribute{
													Optional:            true,
													Description:         "Enable admin container.",
													MarkdownDescription: "Enable admin container.",
												},
												"settings": schema.StringAttribute{
													Optional:            true,
													Description:         "contains any bottlerocket settings",
													MarkdownDescription: "contains any bottlerocket settings",
												},
											},
											CustomType: BottleRocket4Type{
												ObjectType: types.ObjectType{
													AttrTypes: BottleRocket4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"iam": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attach_policy_arns": schema.SetAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "Attach policy ARNs.",
													MarkdownDescription: "Attach policy ARNs.",
												},
												"attach_policy_v2": schema.StringAttribute{
													Optional:            true,
													Description:         "Attach policy v2.",
													MarkdownDescription: "Attach policy v2.",
												},
												"instance_profile_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "Instance profile ARN.",
													MarkdownDescription: "Instance profile ARN.",
												},
												"instance_role_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "Instance role ARN.",
													MarkdownDescription: "Instance role ARN.",
												},
												"instance_role_name": schema.StringAttribute{
													Optional:            true,
													Description:         "Instance role name.",
													MarkdownDescription: "Instance role name.",
												},
												"instance_role_permission_boundary": schema.StringAttribute{
													Optional:            true,
													Description:         "Instance role permission boundary.",
													MarkdownDescription: "Instance role permission boundary.",
												},
											},
											Blocks: map[string]schema.Block{
												"attach_policy": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"id": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy ID.",
																MarkdownDescription: "Attach policy ID.",
															},
															"version": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy version.",
																MarkdownDescription: "Attach policy version.",
															},
														},
														Blocks: map[string]schema.Block{
															"statement": schema.SetNestedBlock{
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																		"action": schema.SetAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "Attach policy action",
																			MarkdownDescription: "Attach policy action",
																		},
																		"condition": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy condition",
																			MarkdownDescription: "Attach policy condition",
																		},
																		"effect": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy effect",
																			MarkdownDescription: "Attach policy effect",
																		},
																		"not_action": schema.SetAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "Attach policy not_action",
																			MarkdownDescription: "Attach policy not_action",
																		},
																		"not_principal": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy not_principal",
																			MarkdownDescription: "Attach policy not_principal",
																		},
																		"not_resource": schema.SetAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "Attach policy not_resource",
																			MarkdownDescription: "Attach policy not_resource",
																		},
																		"principal": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy principal",
																			MarkdownDescription: "Attach policy principal",
																		},
																		"resource": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy resource",
																			MarkdownDescription: "Attach policy resource",
																		},
																		"sid": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy sid",
																			MarkdownDescription: "Attach policy sid",
																		},
																	},
																	CustomType: Statement4Type{
																		ObjectType: types.ObjectType{
																			AttrTypes: Statement4Value{}.AttributeTypes(ctx),
																		},
																	},
																},
															},
														},
														CustomType: AttachPolicy4Type{
															ObjectType: types.ObjectType{
																AttrTypes: AttachPolicy4Value{}.AttributeTypes(ctx),
															},
														},
													},
												},
												"iam_node_group_with_addon_policies": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"alb_ingress": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"app_mesh": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"app_mesh_review": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"auto_scaler": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(true),
															},
															"cert_manager": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"cloud_watch": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"ebs": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"efs": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"external_dns": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"fsx": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"image_builder": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(true),
															},
															"xray": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
														},
														CustomType: IamNodeGroupWithAddonPolicies4Type{
															ObjectType: types.ObjectType{
																AttrTypes: IamNodeGroupWithAddonPolicies4Value{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: Iam4Type{
												ObjectType: types.ObjectType{
													AttrTypes: Iam4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"instance_selector": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"cpu_architecture": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'",
													MarkdownDescription: "CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'",
													Default:             stringdefault.StaticString("x86_64"),
												},
												"gpus": schema.Int64Attribute{
													Optional:            true,
													Description:         "specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.",
													MarkdownDescription: "specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.",
												},
												"memory": schema.StringAttribute{
													Optional:            true,
													Description:         "specifies the memory The unit defaults to GiB.",
													MarkdownDescription: "specifies the memory The unit defaults to GiB.",
												},
												"vcpus": schema.Int64Attribute{
													Optional:            true,
													Description:         "specifies the number of vCPUs.",
													MarkdownDescription: "specifies the number of vCPUs.",
												},
											},
											CustomType: InstanceSelector4Type{
												ObjectType: types.ObjectType{
													AttrTypes: InstanceSelector4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"launch_template": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Optional:            true,
													Description:         "ID of the launch template.",
													MarkdownDescription: "ID of the launch template.",
												},
												"version": schema.StringAttribute{
													Optional:            true,
													Description:         "Version of the launch template.",
													MarkdownDescription: "Version of the launch template.",
												},
											},
											CustomType: LaunchTemplate4Type{
												ObjectType: types.ObjectType{
													AttrTypes: LaunchTemplate4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"node_repair_config": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"enabled": schema.BoolAttribute{
													Optional:            true,
													Description:         "Enable node repair for nodegroup",
													MarkdownDescription: "Enable node repair for nodegroup",
												},
											},
											CustomType: NodeRepairConfig4Type{
												ObjectType: types.ObjectType{
													AttrTypes: NodeRepairConfig4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"placement": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"group": schema.StringAttribute{
													Optional:            true,
													Description:         "placement group name.",
													MarkdownDescription: "placement group name.",
												},
											},
											CustomType: Placement4Type{
												ObjectType: types.ObjectType{
													AttrTypes: Placement4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"security_groups": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attach_ids": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "attaches additional security groups to the nodegroup",
													MarkdownDescription: "attaches additional security groups to the nodegroup",
												},
												"with_local": schema.BoolAttribute{
													Optional:            true,
													Description:         "attach a security group local to this nodegroup Not supported for managed nodegroups",
													MarkdownDescription: "attach a security group local to this nodegroup Not supported for managed nodegroups",
												},
												"with_shared": schema.BoolAttribute{
													Optional:            true,
													Description:         "attach the security group shared among all nodegroups in the cluster",
													MarkdownDescription: "attach the security group shared among all nodegroups in the cluster",
												},
											},
											CustomType: SecurityGroups4Type{
												ObjectType: types.ObjectType{
													AttrTypes: SecurityGroups4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"ssh": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"allow": schema.BoolAttribute{
													Optional:            true,
													Description:         "If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured.",
													MarkdownDescription: "If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured.",
												},
												"enable_ssm": schema.BoolAttribute{
													Optional:            true,
													Description:         "Enables the ability to SSH onto nodes using SSM.",
													MarkdownDescription: "Enables the ability to SSH onto nodes using SSM.",
												},
												"public_key": schema.StringAttribute{
													Optional:            true,
													Description:         "Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
													MarkdownDescription: "Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
												},
												"public_key_name": schema.StringAttribute{
													Optional:            true,
													Description:         "Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
													MarkdownDescription: "Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
												},
												"source_security_group_ids": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "source securitgy group IDs.",
													MarkdownDescription: "source securitgy group IDs.",
												},
											},
											CustomType: Ssh4Type{
												ObjectType: types.ObjectType{
													AttrTypes: Ssh4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"taints": schema.SetNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"effect": schema.StringAttribute{
													Optional:            true,
													Description:         "effect of the taint.",
													MarkdownDescription: "effect of the taint.",
												},
												"key": schema.StringAttribute{
													Optional:            true,
													Description:         "key of the taint.",
													MarkdownDescription: "key of the taint.",
												},
												"value": schema.StringAttribute{
													Optional:            true,
													Description:         "value of the taint.",
													MarkdownDescription: "value of the taint.",
												},
											},
											CustomType: Taints4Type{
												ObjectType: types.ObjectType{
													AttrTypes: Taints4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"update_config": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"max_unavailable": schema.Int64Attribute{
													Optional:            true,
													Description:         "max unavailable nodes during update.",
													MarkdownDescription: "max unavailable nodes during update.",
												},
												"max_unavailable_percentage": schema.Int64Attribute{
													Optional:            true,
													Description:         "max unavailable percentage during update.",
													MarkdownDescription: "max unavailable percentage during update.",
												},
											},
											CustomType: UpdateConfig4Type{
												ObjectType: types.ObjectType{
													AttrTypes: UpdateConfig4Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: ManagedNodegroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: ManagedNodegroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							DeprecationMessage: "The 'managed_nodegroups' block is deprecated and will be removed in a future release. Use 'managed_nodegroups_map' for new configs. Existing setups still work, but migration is recommended.",
						},
						"metadata": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"annotations": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of annotations to assign to the EKS cluster.",
										MarkdownDescription: "A map of annotations to assign to the EKS cluster.",
									},
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "EKS Cluster name.",
										MarkdownDescription: "EKS Cluster name.",
									},
									"region": schema.StringAttribute{
										Required:            true,
										Description:         "The AWS region hosting this cluster.",
										MarkdownDescription: "The AWS region hosting this cluster.",
									},
									"tags": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of tags to assign to the EKS cluster.",
										MarkdownDescription: "A map of tags to assign to the EKS cluster.",
									},
									"version": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The version of the EKS control plane.",
										MarkdownDescription: "The version of the EKS control plane.",
										Default:             stringdefault.StaticString("1.20"),
									},
								},
								CustomType: Metadata2Type{
									ObjectType: types.ObjectType{
										AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"node_groups": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"ami": schema.StringAttribute{
										Optional:            true,
										Description:         "Specify custom AMIs, auto-ssm, auto, or static.",
										MarkdownDescription: "Specify custom AMIs, auto-ssm, auto, or static.",
									},
									"ami_family": schema.StringAttribute{
										Optional: true,
									},
									"asg_suspend_processes": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of autoscaling processes to suspend.",
										MarkdownDescription: "List of autoscaling processes to suspend.",
									},
									"availability_zones": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Limit nodes to specific AZs",
										MarkdownDescription: "Limit nodes to specific AZs",
									},
									"classic_load_balancer_names": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Associate load balancers with auto scaling group.",
										MarkdownDescription: "Associate load balancers with auto scaling group.",
									},
									"cluster_dns": schema.StringAttribute{
										Optional:            true,
										Description:         "Custom address used for DNS lookups.",
										MarkdownDescription: "Custom address used for DNS lookups.",
									},
									"cpu_credits": schema.StringAttribute{
										Optional:            true,
										Description:         "configures T3 Unlimited, valid only for T-type instances",
										MarkdownDescription: "configures T3 Unlimited, valid only for T-type instances",
									},
									"desired_capacity": schema.Int64Attribute{
										Optional: true,
									},
									"disable_imdsv1": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to disable IMDSv1 on the node group.",
										MarkdownDescription: "Whether to disable IMDSv1 on the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"disable_pods_imds": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to disable IMDS for pods in the node group.",
										MarkdownDescription: "Whether to disable IMDS for pods in the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"ebs_optimized": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enables EBS optimization.",
										MarkdownDescription: "enables EBS optimization.",
										Default:             booldefault.StaticBool(false),
									},
									"efa_enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										MarkdownDescription: "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										Default:             booldefault.StaticBool(false),
									},
									"enable_detailed_monitoring": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable EC2 detailed monitoring",
										MarkdownDescription: "Enable EC2 detailed monitoring",
										Default:             booldefault.StaticBool(false),
									},
									"instance_name": schema.StringAttribute{
										Optional:            true,
										Description:         "Name for the instance.",
										MarkdownDescription: "Name for the instance.",
									},
									"instance_prefix": schema.StringAttribute{
										Optional:            true,
										Description:         "Prefix for the instance name.",
										MarkdownDescription: "Prefix for the instance name.",
									},
									"instance_type": schema.StringAttribute{
										Required:            true,
										Description:         "The type of EC2 instance to use for the nodes in this group.",
										MarkdownDescription: "The type of EC2 instance to use for the nodes in this group.",
									},
									"labels": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of labels to assign to the nodes in the group.",
										MarkdownDescription: "A map of labels to assign to the nodes in the group.",
									},
									"max_pods_per_node": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"max_size": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"min_size": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Default:  int64default.StaticInt64(0),
									},
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the node group.",
										MarkdownDescription: "The name of the node group.",
									},
									"override_bootstrap_command": schema.StringAttribute{
										Optional:            true,
										Description:         "Override the vendor's bootstrapping script.",
										MarkdownDescription: "Override the vendor's bootstrapping script.",
									},
									"pre_bootstrap_commands": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "executed before bootstrapping instances to the cluster.",
										MarkdownDescription: "executed before bootstrapping instances to the cluster.",
									},
									"private_networking": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enable private networking for the node group.",
										MarkdownDescription: "Enable private networking for the node group.",
										Default:             booldefault.StaticBool(false),
									},
									"subnet_cidr": schema.StringAttribute{
										Optional:            true,
										Description:         "Create new subnet from the CIDR block and limit nodes to this subnet (Applicable only for the WavelenghZone nodes).",
										MarkdownDescription: "Create new subnet from the CIDR block and limit nodes to this subnet (Applicable only for the WavelenghZone nodes).",
									},
									"subnets": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Limit nodes to specific subnets.",
										MarkdownDescription: "Limit nodes to specific subnets.",
									},
									"tags": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed).",
										MarkdownDescription: "Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed).",
									},
									"target_group_arns": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Associate target group with auto scaling group.",
										MarkdownDescription: "Associate target group with auto scaling group.",
									},
									"version": schema.StringAttribute{
										Optional:            true,
										Description:         "Kuberenetes version for the nodegroup.",
										MarkdownDescription: "Kuberenetes version for the nodegroup.",
									},
									"volume_encrypted": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "whether to encrypt volumes attached to instances in the nodegroup.",
										MarkdownDescription: "whether to encrypt volumes attached to instances in the nodegroup.",
										Default:             booldefault.StaticBool(false),
									},
									"volume_iops": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										MarkdownDescription: "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										Default:             int64default.StaticInt64(3000),
									},
									"volume_kms_key_id": schema.StringAttribute{
										Optional:            true,
										Description:         "of volumes attached to instances in the nodegroup.",
										MarkdownDescription: "of volumes attached to instances in the nodegroup.",
									},
									"volume_name": schema.StringAttribute{
										Optional:            true,
										Description:         "of volumes attached to instances in the nodegroup.",
										MarkdownDescription: "of volumes attached to instances in the nodegroup.",
									},
									"volume_size": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										MarkdownDescription: "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										Default:             int64default.StaticInt64(80),
									},
									"volume_throughput": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										MarkdownDescription: "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										Default:             int64default.StaticInt64(125),
									},
									"volume_type": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The type of EBS volume to use for the nodes in this group.",
										MarkdownDescription: "The type of EBS volume to use for the nodes in this group.",
										Default:             stringdefault.StaticString("gp3"),
									},
								},
								Blocks: map[string]schema.Block{
									"asg_metrics_collection": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"granularity": schema.StringAttribute{
													Optional:            true,
													Description:         "of metrics collected.",
													MarkdownDescription: "of metrics collected.",
												},
												"metrics": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "list of metrics to collect. Valid values are: GroupMinSize, GroupMaxSize, GroupDesiredCapacity, GroupInServiceInstances, GroupPendingInstances, GroupStandbyInstances, GroupTerminatingInstances, GroupTotalInstances.",
													MarkdownDescription: "list of metrics to collect. Valid values are: GroupMinSize, GroupMaxSize, GroupDesiredCapacity, GroupInServiceInstances, GroupPendingInstances, GroupStandbyInstances, GroupTerminatingInstances, GroupTotalInstances.",
												},
											},
											CustomType: AsgMetricsCollectionType{
												ObjectType: types.ObjectType{
													AttrTypes: AsgMetricsCollectionValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"bottle_rocket": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"enable_admin_container": schema.BoolAttribute{
													Optional:            true,
													Description:         "Enable admin container.",
													MarkdownDescription: "Enable admin container.",
												},
												"settings": schema.StringAttribute{
													Optional:            true,
													Description:         "contains any bottlerocket settings",
													MarkdownDescription: "contains any bottlerocket settings",
												},
											},
											CustomType: BottleRocketType{
												ObjectType: types.ObjectType{
													AttrTypes: BottleRocketValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"iam": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attach_policy_arns": schema.SetAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "Attach policy ARNs.",
													MarkdownDescription: "Attach policy ARNs.",
												},
												"attach_policy_v2": schema.StringAttribute{
													Optional:            true,
													Description:         "Attach policy v2.",
													MarkdownDescription: "Attach policy v2.",
												},
												"instance_profile_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "Instance profile ARN.",
													MarkdownDescription: "Instance profile ARN.",
												},
												"instance_role_arn": schema.StringAttribute{
													Optional:            true,
													Description:         "Instance role ARN.",
													MarkdownDescription: "Instance role ARN.",
												},
												"instance_role_name": schema.StringAttribute{
													Optional:            true,
													Description:         "Instance role name.",
													MarkdownDescription: "Instance role name.",
												},
												"instance_role_permission_boundary": schema.StringAttribute{
													Optional:            true,
													Description:         "Instance role permission boundary.",
													MarkdownDescription: "Instance role permission boundary.",
												},
											},
											Blocks: map[string]schema.Block{
												"attach_policy": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"id": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy ID.",
																MarkdownDescription: "Attach policy ID.",
															},
															"version": schema.StringAttribute{
																Optional:            true,
																Description:         "Attach policy version.",
																MarkdownDescription: "Attach policy version.",
															},
														},
														Blocks: map[string]schema.Block{
															"statement": schema.SetNestedBlock{
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																		"action": schema.SetAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "Attach policy action",
																			MarkdownDescription: "Attach policy action",
																		},
																		"condition": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy condition",
																			MarkdownDescription: "Attach policy condition",
																		},
																		"effect": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy effect",
																			MarkdownDescription: "Attach policy effect",
																		},
																		"not_action": schema.SetAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "Attach policy not_action",
																			MarkdownDescription: "Attach policy not_action",
																		},
																		"not_principal": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy not_principal",
																			MarkdownDescription: "Attach policy not_principal",
																		},
																		"not_resource": schema.SetAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "Attach policy not_resource",
																			MarkdownDescription: "Attach policy not_resource",
																		},
																		"principal": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy principal",
																			MarkdownDescription: "Attach policy principal",
																		},
																		"resource": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy resource",
																			MarkdownDescription: "Attach policy resource",
																		},
																		"sid": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Attach policy sid",
																			MarkdownDescription: "Attach policy sid",
																		},
																	},
																	CustomType: StatementType{
																		ObjectType: types.ObjectType{
																			AttrTypes: StatementValue{}.AttributeTypes(ctx),
																		},
																	},
																},
															},
														},
														CustomType: AttachPolicyType{
															ObjectType: types.ObjectType{
																AttrTypes: AttachPolicyValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
												"iam_node_group_with_addon_policies": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"alb_ingress": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"app_mesh": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"app_mesh_review": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"auto_scaler": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(true),
															},
															"cert_manager": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"cloud_watch": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"ebs": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"efs": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"external_dns": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"fsx": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
															"image_builder": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(true),
															},
															"xray": schema.BoolAttribute{
																Optional: true,
																Computed: true,
																Default:  booldefault.StaticBool(false),
															},
														},
														CustomType: IamNodeGroupWithAddonPoliciesType{
															ObjectType: types.ObjectType{
																AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: IamType{
												ObjectType: types.ObjectType{
													AttrTypes: IamValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"instance_selector": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"cpu_architecture": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'",
													MarkdownDescription: "CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'",
													Default:             stringdefault.StaticString("x86_64"),
												},
												"gpus": schema.Int64Attribute{
													Optional:            true,
													Description:         "specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.",
													MarkdownDescription: "specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.",
												},
												"memory": schema.StringAttribute{
													Optional:            true,
													Description:         "specifies the memory The unit defaults to GiB.",
													MarkdownDescription: "specifies the memory The unit defaults to GiB.",
												},
												"vcpus": schema.Int64Attribute{
													Optional:            true,
													Description:         "specifies the number of vCPUs.",
													MarkdownDescription: "specifies the number of vCPUs.",
												},
											},
											CustomType: InstanceSelectorType{
												ObjectType: types.ObjectType{
													AttrTypes: InstanceSelectorValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"instances_distribution": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"capacity_rebalance": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "Enable capacity rebalancing for spot instances.",
													MarkdownDescription: "Enable capacity rebalancing for spot instances.",
													Default:             booldefault.StaticBool(false),
												},
												"instance_types": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "instance types.",
													MarkdownDescription: "instance types.",
												},
												"max_price": schema.Float64Attribute{
													Optional:            true,
													Description:         "Maximum bid price in USD.",
													MarkdownDescription: "Maximum bid price in USD.",
												},
												"on_demand_base_capacity": schema.Int64Attribute{
													Optional:            true,
													Computed:            true,
													Description:         "base number of on-demand instances (non-negative).",
													MarkdownDescription: "base number of on-demand instances (non-negative).",
													Default:             int64default.StaticInt64(0),
												},
												"on_demand_percentage_above_base_capacity": schema.Int64Attribute{
													Optional:            true,
													Computed:            true,
													Description:         "percentage of on-demand instances above base capacity (0-100).",
													MarkdownDescription: "percentage of on-demand instances above base capacity (0-100).",
													Default:             int64default.StaticInt64(100),
												},
												"spot_allocation_strategy": schema.StringAttribute{
													Optional:            true,
													Description:         "allocation strategy for spot instances. Valid values are capacity-optimized and lowest-price.",
													MarkdownDescription: "allocation strategy for spot instances. Valid values are capacity-optimized and lowest-price.",
												},
												"spot_instance_pools": schema.Int64Attribute{
													Optional:            true,
													Computed:            true,
													Description:         "number of spot instance pools to use (1-20).",
													MarkdownDescription: "number of spot instance pools to use (1-20).",
													Default:             int64default.StaticInt64(2),
												},
											},
											CustomType: InstancesDistributionType{
												ObjectType: types.ObjectType{
													AttrTypes: InstancesDistributionValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"kubelet_extra_config": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"eviction_hard": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "eviction hard resources.",
													MarkdownDescription: "eviction hard resources.",
												},
												"feature_gates": schema.MapAttribute{
													ElementType:         types.BoolType,
													Optional:            true,
													Description:         "feature gates.",
													MarkdownDescription: "feature gates.",
												},
												"kube_reserved": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "kube reserved resources.",
													MarkdownDescription: "kube reserved resources.",
												},
												"kube_reserved_cgroup": schema.StringAttribute{
													Optional:            true,
													Description:         "kube reserved cgroup.",
													MarkdownDescription: "kube reserved cgroup.",
												},
												"system_reserved": schema.MapAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "system reserved resources.",
													MarkdownDescription: "system reserved resources.",
												},
											},
											CustomType: KubeletExtraConfigType{
												ObjectType: types.ObjectType{
													AttrTypes: KubeletExtraConfigValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"placement": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"group": schema.StringAttribute{
													Optional:            true,
													Description:         "placement group name.",
													MarkdownDescription: "placement group name.",
												},
											},
											CustomType: PlacementType{
												ObjectType: types.ObjectType{
													AttrTypes: PlacementValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"security_groups": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attach_ids": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "attaches additional security groups to the nodegroup",
													MarkdownDescription: "attaches additional security groups to the nodegroup",
												},
												"with_local": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "attach a security group local to this nodegroup Not supported for managed nodegroups",
													MarkdownDescription: "attach a security group local to this nodegroup Not supported for managed nodegroups",
													Default:             booldefault.StaticBool(true),
												},
												"with_shared": schema.BoolAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "attach the security group shared among all nodegroups in the cluster",
													MarkdownDescription: "attach the security group shared among all nodegroups in the cluster",
													Default:             booldefault.StaticBool(true),
												},
											},
											CustomType: SecurityGroupsType{
												ObjectType: types.ObjectType{
													AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"ssh": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"allow": schema.BoolAttribute{
													Optional:            true,
													Description:         "If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured.",
													MarkdownDescription: "If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured.",
												},
												"enable_ssm": schema.BoolAttribute{
													Optional:            true,
													Description:         "Enables the ability to SSH onto nodes using SSM.",
													MarkdownDescription: "Enables the ability to SSH onto nodes using SSM.",
												},
												"public_key": schema.StringAttribute{
													Optional:            true,
													Description:         "Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
													MarkdownDescription: "Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
												},
												"public_key_name": schema.StringAttribute{
													Optional:            true,
													Description:         "Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
													MarkdownDescription: "Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.",
												},
												"source_security_group_ids": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Description:         "source securitgy group IDs.",
													MarkdownDescription: "source securitgy group IDs.",
												},
											},
											CustomType: SshType{
												ObjectType: types.ObjectType{
													AttrTypes: SshValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"taints": schema.SetNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"effect": schema.StringAttribute{
													Optional:            true,
													Description:         "effect of the taint.",
													MarkdownDescription: "effect of the taint.",
												},
												"key": schema.StringAttribute{
													Optional:            true,
													Description:         "key of the taint.",
													MarkdownDescription: "key of the taint.",
												},
												"value": schema.StringAttribute{
													Optional:            true,
													Description:         "value of the taint.",
													MarkdownDescription: "value of the taint.",
												},
											},
											CustomType: TaintsType{
												ObjectType: types.ObjectType{
													AttrTypes: TaintsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"update_config": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"max_unavaliable": schema.Int64Attribute{
													Optional:            true,
													Description:         "max unavaliable nodes during update.",
													MarkdownDescription: "max unavaliable nodes during update.",
												},
												"max_unavaliable_percetage": schema.Int64Attribute{
													Optional:            true,
													Description:         "max unavaliable percentage during update.",
													MarkdownDescription: "max unavaliable percentage during update.",
												},
											},
											CustomType: UpdateConfigType{
												ObjectType: types.ObjectType{
													AttrTypes: UpdateConfigValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: NodeGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							DeprecationMessage: "The 'node_groups' block is deprecated and will be removed in a future release. Use 'node_groups_map'                                                                                                             for new configs. Existing setups still work, but migration is recommended.",
						},
						"private_cluster": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"additional_endpoint_services": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "specifies additional endpoint services that must be enabled for private access. Valid entries are: 'cloudformation', 'autoscaling', 'logs'.",
										MarkdownDescription: "specifies additional endpoint services that must be enabled for private access. Valid entries are: 'cloudformation', 'autoscaling', 'logs'.",
									},
									"enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to create the cluster as a private cluster.",
										MarkdownDescription: "Whether to create the cluster as a private cluster.",
										Default:             booldefault.StaticBool(false),
									},
									"skip_endpoint_creation": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "skips the creation process for endpoints completely. This is only used in case of an already provided VPC and if the user decided to set it to true..",
										MarkdownDescription: "skips the creation process for endpoints completely. This is only used in case of an already provided VPC and if the user decided to set it to true..",
										Default:             booldefault.StaticBool(false),
									},
								},
								CustomType: PrivateClusterType{
									ObjectType: types.ObjectType{
										AttrTypes: PrivateClusterValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"secrets_encryption": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"encrypt_existing_secrets": schema.BoolAttribute{
										Optional:            true,
										Description:         "Flag to encrypt existing secrets.",
										MarkdownDescription: "Flag to encrypt existing secrets.",
									},
									"key_arn": schema.StringAttribute{
										Optional:            true,
										Description:         "KMS key ARN.",
										MarkdownDescription: "KMS key ARN.",
									},
								},
								CustomType: SecretsEncryptionType{
									ObjectType: types.ObjectType{
										AttrTypes: SecretsEncryptionValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"vpc": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"auto_allocate_ipv6": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "AutoAllocateIPV6 requests an IPv6 CIDR block with /56 prefix for the VPC.",
										MarkdownDescription: "AutoAllocateIPV6 requests an IPv6 CIDR block with /56 prefix for the VPC.",
										Default:             booldefault.StaticBool(false),
									},
									"cidr": schema.StringAttribute{
										Optional:            true,
										Description:         "CIDR range of the VPC.",
										MarkdownDescription: "CIDR range of the VPC.",
									},
									"extra_cidrs": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Additional CIDRs for the VPC.",
										MarkdownDescription: "Additional CIDRs for the VPC.",
									},
									"extra_ipv6_cidrs": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Additional IPv6 CIDRs for the VPC.",
										MarkdownDescription: "Additional IPv6 CIDRs for the VPC.",
									},
									"id": schema.StringAttribute{
										Optional:            true,
										Description:         "AWS VPC ID.",
										MarkdownDescription: "AWS VPC ID.",
									},
									"ipv6_cidr": schema.StringAttribute{
										Optional:            true,
										Description:         "IPv6 CIDR range of the VPC.",
										MarkdownDescription: "IPv6 CIDR range of the VPC.",
									},
									"ipv6_pool": schema.StringAttribute{
										Optional:            true,
										Description:         "IPv6 pool of the VPC.",
										MarkdownDescription: "IPv6 pool of the VPC.",
									},
									"manage_shared_node_security_group_rules": schema.BoolAttribute{
										Optional:            true,
										Description:         "Automatically add security group rules to and from the default cluster security group and the shared node security group. This allows unmanaged nodes to communicate with the control plane and managed nodes. This option cannot be disabled when using vendor created security groups.",
										MarkdownDescription: "Automatically add security group rules to and from the default cluster security group and the shared node security group. This allows unmanaged nodes to communicate with the control plane and managed nodes. This option cannot be disabled when using vendor created security groups.",
									},
									"public_access_cidrs": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "which CIDR blocks to allow access to public k8s API endpoint.",
										MarkdownDescription: "which CIDR blocks to allow access to public k8s API endpoint.",
									},
									"security_group": schema.StringAttribute{
										Optional:            true,
										Description:         "Security group ID for the VPC.",
										MarkdownDescription: "Security group ID for the VPC.",
									},
									"shared_node_security_group": schema.StringAttribute{
										Optional:            true,
										Description:         "Shared node security group ID for the VPC.",
										MarkdownDescription: "Shared node security group ID for the VPC.",
									},
								},
								Blocks: map[string]schema.Block{
									"cluster_endpoints": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"private_access": schema.BoolAttribute{
													Optional:            true,
													Description:         "enable private access to the Kubernetes API server endpoints.",
													MarkdownDescription: "enable private access to the Kubernetes API server endpoints.",
												},
												"public_access": schema.BoolAttribute{
													Optional:            true,
													Description:         "enable public access to the Kubernetes API server endpoints.",
													MarkdownDescription: "enable public access to the Kubernetes API server endpoints.",
												},
											},
											CustomType: ClusterEndpointsType{
												ObjectType: types.ObjectType{
													AttrTypes: ClusterEndpointsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"nat": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"gateway": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "Valid variants are: 'HighlyAvailable' configures a highly available NAT gateway, 'Single' configures a single NAT gateway (default), 'Disable' disables NAT.",
													MarkdownDescription: "Valid variants are: 'HighlyAvailable' configures a highly available NAT gateway, 'Single' configures a single NAT gateway (default), 'Disable' disables NAT.",
													Default:             stringdefault.StaticString("Single"),
												},
											},
											CustomType: NatType{
												ObjectType: types.ObjectType{
													AttrTypes: NatValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"subnets": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Blocks: map[string]schema.Block{
												"private": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"az": schema.StringAttribute{
																Optional:            true,
																Description:         "Availability zone of the subnet.",
																MarkdownDescription: "Availability zone of the subnet.",
															},
															"cidr": schema.StringAttribute{
																Optional:            true,
																Description:         "CIDR range of the subnet.",
																MarkdownDescription: "CIDR range of the subnet.",
															},
															"id": schema.StringAttribute{
																Optional:            true,
																Description:         "id of subnet.",
																MarkdownDescription: "id of subnet.",
															},
															"name": schema.StringAttribute{
																Required:            true,
																Description:         "Name of the private subnet.",
																MarkdownDescription: "Name of the private subnet.",
															},
														},
														CustomType: PrivateType{
															ObjectType: types.ObjectType{
																AttrTypes: PrivateValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
												"public": schema.SetNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"az": schema.StringAttribute{
																Optional:            true,
																Description:         "Availability zone of the subnet.",
																MarkdownDescription: "Availability zone of the subnet.",
															},
															"cidr": schema.StringAttribute{
																Optional:            true,
																Description:         "CIDR range of the subnet.",
																MarkdownDescription: "CIDR range of the subnet.",
															},
															"id": schema.StringAttribute{
																Optional:            true,
																Description:         "id of subnet.",
																MarkdownDescription: "id of subnet.",
															},
															"name": schema.StringAttribute{
																Required:            true,
																Description:         "Name of the private subnet.",
																MarkdownDescription: "Name of the private subnet.",
															},
														},
														CustomType: PublicType{
															ObjectType: types.ObjectType{
																AttrTypes: PublicValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: Subnets3Type{
												ObjectType: types.ObjectType{
													AttrTypes: Subnets3Value{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: VpcType{
									ObjectType: types.ObjectType{
										AttrTypes: VpcValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
					},
					CustomType: ClusterConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"timeouts": schema.SingleNestedBlock{
				Attributes: map[string]schema.Attribute{
					"create": schema.StringAttribute{
						Optional:            true,
						Description:         "Specifies the amount of time to wait for the creation of the EKS Cluster.",
						MarkdownDescription: "Specifies the amount of time to wait for the creation of the EKS Cluster.",
					},
					"delete": schema.StringAttribute{
						Optional:            true,
						Description:         "Specifies the amount of time to wait for the deletion of the EKS Cluster.",
						MarkdownDescription: "Specifies the amount of time to wait for the deletion of the EKS Cluster.",
					},
					"update": schema.StringAttribute{
						Optional:            true,
						Description:         "Specifies the amount of time to wait for the update of the EKS Cluster.",
						MarkdownDescription: "Specifies the amount of time to wait for the update of the EKS Cluster.",
					},
				},
				CustomType: TimeoutsType{
					ObjectType: types.ObjectType{
						AttrTypes: TimeoutsValue{}.AttributeTypes(ctx),
					},
				},
			},
		},
	}
}

type EksClusterModel struct {
	Id            types.String  `tfsdk:"id"`
	Cluster       types.List    `tfsdk:"cluster"`
	ClusterConfig types.List    `tfsdk:"cluster_config"`
	Timeouts      TimeoutsValue `tfsdk:"timeouts"`
}

var _ basetypes.ObjectTypable = ClusterType{}

type ClusterType struct {
	basetypes.ObjectType
}

func (t ClusterType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterType) String() string {
	return "ClusterType"
}

func (t ClusterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ListValue, was: %T`, specAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterValue{
		Kind:     kindVal,
		Metadata: metadataVal,
		Spec:     specVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterValueNull() ClusterValue {
	return ClusterValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterValueUnknown() ClusterValue {
	return ClusterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterValue Attribute Value",
				"While creating a ClusterValue value, a missing attribute value was detected. "+
					"A ClusterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterValue Attribute Type",
				"While creating a ClusterValue value, an invalid attribute value was detected. "+
					"A ClusterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterValue Attribute Value",
				"While creating a ClusterValue value, an extra attribute value was detected. "+
					"A ClusterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterValueUnknown(), diags
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ListValue, was: %T`, specAttribute))
	}

	if diags.HasError() {
		return NewClusterValueUnknown(), diags
	}

	return ClusterValue{
		Kind:     kindVal,
		Metadata: metadataVal,
		Spec:     specVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterValue {
	object, diags := NewClusterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterValueMust(ClusterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterType) ValueType(ctx context.Context) attr.Value {
	return ClusterValue{}
}

var _ basetypes.ObjectValuable = ClusterValue{}

type ClusterValue struct {
	Kind     basetypes.StringValue `tfsdk:"kind"`
	Metadata basetypes.ListValue   `tfsdk:"metadata"`
	Spec     basetypes.ListValue   `tfsdk:"spec"`
	state    attr.ValueState
}

func (v ClusterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: MetadataValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ListType{
		ElemType: SpecValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterValue) String() string {
	return "ClusterValue"
}

func (v ClusterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	metadata := types.ListValueMust(
		MetadataType{
			basetypes.ObjectType{
				AttrTypes: MetadataValue{}.AttributeTypes(ctx),
			},
		},
		v.Metadata.Elements(),
	)

	if v.Metadata.IsNull() {
		metadata = types.ListNull(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ListUnknown(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	spec := types.ListValueMust(
		SpecType{
			basetypes.ObjectType{
				AttrTypes: SpecValue{}.AttributeTypes(ctx),
			},
		},
		v.Spec.Elements(),
	)

	if v.Spec.IsNull() {
		spec = types.ListNull(
			SpecType{
				basetypes.ObjectType{
					AttrTypes: SpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ListUnknown(
			SpecType{
				basetypes.ObjectType{
					AttrTypes: SpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"kind": basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"spec": basetypes.ListType{
			ElemType: SpecValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"kind":     v.Kind,
			"metadata": metadata,
			"spec":     spec,
		})

	return objVal, diags
}

func (v ClusterValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	return true
}

func (v ClusterValue) Type(ctx context.Context) attr.Type {
	return ClusterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"kind": basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"spec": basetypes.ListType{
			ElemType: SpecValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Labels:  labelsVal,
		Name:    nameVal,
		Project: projectVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Labels:  labelsVal,
		Name:    nameVal,
		Project: projectVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Labels  basetypes.MapValue    `tfsdk:"labels"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Project basetypes.StringValue `tfsdk:"project"`
	state   attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":    basetypes.StringType{},
			"project": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":    basetypes.StringType{},
		"project": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"labels":  labelsVal,
			"name":    v.Name,
			"project": v.Project,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":    basetypes.StringType{},
		"project": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return nil, diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.StringValue, was: %T`, blueprintAttribute))
	}

	blueprintVersionAttribute, ok := attributes["blueprint_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint_version is missing from object`)

		return nil, diags
	}

	blueprintVersionVal, ok := blueprintVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint_version expected to be basetypes.StringValue, was: %T`, blueprintVersionAttribute))
	}

	cloudProviderAttribute, ok := attributes["cloud_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider is missing from object`)

		return nil, diags
	}

	cloudProviderVal, ok := cloudProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider expected to be basetypes.StringValue, was: %T`, cloudProviderAttribute))
	}

	cniParamsAttribute, ok := attributes["cni_params"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_params is missing from object`)

		return nil, diags
	}

	cniParamsVal, ok := cniParamsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_params expected to be basetypes.ListValue, was: %T`, cniParamsAttribute))
	}

	cniProviderAttribute, ok := attributes["cni_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_provider is missing from object`)

		return nil, diags
	}

	cniProviderVal, ok := cniProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_provider expected to be basetypes.StringValue, was: %T`, cniProviderAttribute))
	}

	crossAccountRoleArnAttribute, ok := attributes["cross_account_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cross_account_role_arn is missing from object`)

		return nil, diags
	}

	crossAccountRoleArnVal, ok := crossAccountRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cross_account_role_arn expected to be basetypes.StringValue, was: %T`, crossAccountRoleArnAttribute))
	}

	proxyConfigAttribute, ok := attributes["proxy_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_config is missing from object`)

		return nil, diags
	}

	proxyConfigVal, ok := proxyConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_config expected to be basetypes.MapValue, was: %T`, proxyConfigAttribute))
	}

	sharingAttribute, ok := attributes["sharing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sharing is missing from object`)

		return nil, diags
	}

	sharingVal, ok := sharingAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sharing expected to be basetypes.ListValue, was: %T`, sharingAttribute))
	}

	systemComponentsPlacementAttribute, ok := attributes["system_components_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_components_placement is missing from object`)

		return nil, diags
	}

	systemComponentsPlacementVal, ok := systemComponentsPlacementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_components_placement expected to be basetypes.ListValue, was: %T`, systemComponentsPlacementAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Blueprint:                 blueprintVal,
		BlueprintVersion:          blueprintVersionVal,
		CloudProvider:             cloudProviderVal,
		CniParams:                 cniParamsVal,
		CniProvider:               cniProviderVal,
		CrossAccountRoleArn:       crossAccountRoleArnVal,
		ProxyConfig:               proxyConfigVal,
		Sharing:                   sharingVal,
		SystemComponentsPlacement: systemComponentsPlacementVal,
		SpecType:                  typeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.StringValue, was: %T`, blueprintAttribute))
	}

	blueprintVersionAttribute, ok := attributes["blueprint_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint_version is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	blueprintVersionVal, ok := blueprintVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint_version expected to be basetypes.StringValue, was: %T`, blueprintVersionAttribute))
	}

	cloudProviderAttribute, ok := attributes["cloud_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cloudProviderVal, ok := cloudProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider expected to be basetypes.StringValue, was: %T`, cloudProviderAttribute))
	}

	cniParamsAttribute, ok := attributes["cni_params"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_params is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cniParamsVal, ok := cniParamsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_params expected to be basetypes.ListValue, was: %T`, cniParamsAttribute))
	}

	cniProviderAttribute, ok := attributes["cni_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_provider is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cniProviderVal, ok := cniProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_provider expected to be basetypes.StringValue, was: %T`, cniProviderAttribute))
	}

	crossAccountRoleArnAttribute, ok := attributes["cross_account_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cross_account_role_arn is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	crossAccountRoleArnVal, ok := crossAccountRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cross_account_role_arn expected to be basetypes.StringValue, was: %T`, crossAccountRoleArnAttribute))
	}

	proxyConfigAttribute, ok := attributes["proxy_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_config is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	proxyConfigVal, ok := proxyConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_config expected to be basetypes.MapValue, was: %T`, proxyConfigAttribute))
	}

	sharingAttribute, ok := attributes["sharing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sharing is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sharingVal, ok := sharingAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sharing expected to be basetypes.ListValue, was: %T`, sharingAttribute))
	}

	systemComponentsPlacementAttribute, ok := attributes["system_components_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_components_placement is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemComponentsPlacementVal, ok := systemComponentsPlacementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_components_placement expected to be basetypes.ListValue, was: %T`, systemComponentsPlacementAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Blueprint:                 blueprintVal,
		BlueprintVersion:          blueprintVersionVal,
		CloudProvider:             cloudProviderVal,
		CniParams:                 cniParamsVal,
		CniProvider:               cniProviderVal,
		CrossAccountRoleArn:       crossAccountRoleArnVal,
		ProxyConfig:               proxyConfigVal,
		Sharing:                   sharingVal,
		SystemComponentsPlacement: systemComponentsPlacementVal,
		SpecType:                  typeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Blueprint                 basetypes.StringValue `tfsdk:"blueprint"`
	BlueprintVersion          basetypes.StringValue `tfsdk:"blueprint_version"`
	CloudProvider             basetypes.StringValue `tfsdk:"cloud_provider"`
	CniParams                 basetypes.ListValue   `tfsdk:"cni_params"`
	CniProvider               basetypes.StringValue `tfsdk:"cni_provider"`
	CrossAccountRoleArn       basetypes.StringValue `tfsdk:"cross_account_role_arn"`
	ProxyConfig               basetypes.MapValue    `tfsdk:"proxy_config"`
	Sharing                   basetypes.ListValue   `tfsdk:"sharing"`
	SystemComponentsPlacement basetypes.ListValue   `tfsdk:"system_components_placement"`
	SpecType                  basetypes.StringValue `tfsdk:"type"`
	state                     attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["blueprint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["blueprint_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cloud_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cni_params"] = basetypes.ListType{
		ElemType: CniParamsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["cni_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cross_account_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["proxy_config"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sharing"] = basetypes.ListType{
		ElemType: SharingValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["system_components_placement"] = basetypes.ListType{
		ElemType: SystemComponentsPlacementValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Blueprint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blueprint"] = val

		val, err = v.BlueprintVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blueprint_version"] = val

		val, err = v.CloudProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_provider"] = val

		val, err = v.CniParams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cni_params"] = val

		val, err = v.CniProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cni_provider"] = val

		val, err = v.CrossAccountRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cross_account_role_arn"] = val

		val, err = v.ProxyConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_config"] = val

		val, err = v.Sharing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sharing"] = val

		val, err = v.SystemComponentsPlacement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_components_placement"] = val

		val, err = v.SpecType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	cniParams := types.ListValueMust(
		CniParamsType{
			basetypes.ObjectType{
				AttrTypes: CniParamsValue{}.AttributeTypes(ctx),
			},
		},
		v.CniParams.Elements(),
	)

	if v.CniParams.IsNull() {
		cniParams = types.ListNull(
			CniParamsType{
				basetypes.ObjectType{
					AttrTypes: CniParamsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CniParams.IsUnknown() {
		cniParams = types.ListUnknown(
			CniParamsType{
				basetypes.ObjectType{
					AttrTypes: CniParamsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	sharing := types.ListValueMust(
		SharingType{
			basetypes.ObjectType{
				AttrTypes: SharingValue{}.AttributeTypes(ctx),
			},
		},
		v.Sharing.Elements(),
	)

	if v.Sharing.IsNull() {
		sharing = types.ListNull(
			SharingType{
				basetypes.ObjectType{
					AttrTypes: SharingValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Sharing.IsUnknown() {
		sharing = types.ListUnknown(
			SharingType{
				basetypes.ObjectType{
					AttrTypes: SharingValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	systemComponentsPlacement := types.ListValueMust(
		SystemComponentsPlacementType{
			basetypes.ObjectType{
				AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
			},
		},
		v.SystemComponentsPlacement.Elements(),
	)

	if v.SystemComponentsPlacement.IsNull() {
		systemComponentsPlacement = types.ListNull(
			SystemComponentsPlacementType{
				basetypes.ObjectType{
					AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SystemComponentsPlacement.IsUnknown() {
		systemComponentsPlacement = types.ListUnknown(
			SystemComponentsPlacementType{
				basetypes.ObjectType{
					AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var proxyConfigVal basetypes.MapValue
	switch {
	case v.ProxyConfig.IsUnknown():
		proxyConfigVal = types.MapUnknown(types.StringType)
	case v.ProxyConfig.IsNull():
		proxyConfigVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		proxyConfigVal, d = types.MapValue(types.StringType, v.ProxyConfig.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"blueprint":         basetypes.StringType{},
			"blueprint_version": basetypes.StringType{},
			"cloud_provider":    basetypes.StringType{},
			"cni_params": basetypes.ListType{
				ElemType: CniParamsValue{}.Type(ctx),
			},
			"cni_provider":           basetypes.StringType{},
			"cross_account_role_arn": basetypes.StringType{},
			"proxy_config": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sharing": basetypes.ListType{
				ElemType: SharingValue{}.Type(ctx),
			},
			"system_components_placement": basetypes.ListType{
				ElemType: SystemComponentsPlacementValue{}.Type(ctx),
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"blueprint":         basetypes.StringType{},
		"blueprint_version": basetypes.StringType{},
		"cloud_provider":    basetypes.StringType{},
		"cni_params": basetypes.ListType{
			ElemType: CniParamsValue{}.Type(ctx),
		},
		"cni_provider":           basetypes.StringType{},
		"cross_account_role_arn": basetypes.StringType{},
		"proxy_config": basetypes.MapType{
			ElemType: types.StringType,
		},
		"sharing": basetypes.ListType{
			ElemType: SharingValue{}.Type(ctx),
		},
		"system_components_placement": basetypes.ListType{
			ElemType: SystemComponentsPlacementValue{}.Type(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"blueprint":                   v.Blueprint,
			"blueprint_version":           v.BlueprintVersion,
			"cloud_provider":              v.CloudProvider,
			"cni_params":                  cniParams,
			"cni_provider":                v.CniProvider,
			"cross_account_role_arn":      v.CrossAccountRoleArn,
			"proxy_config":                proxyConfigVal,
			"sharing":                     sharing,
			"system_components_placement": systemComponentsPlacement,
			"type":                        v.SpecType,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Blueprint.Equal(other.Blueprint) {
		return false
	}

	if !v.BlueprintVersion.Equal(other.BlueprintVersion) {
		return false
	}

	if !v.CloudProvider.Equal(other.CloudProvider) {
		return false
	}

	if !v.CniParams.Equal(other.CniParams) {
		return false
	}

	if !v.CniProvider.Equal(other.CniProvider) {
		return false
	}

	if !v.CrossAccountRoleArn.Equal(other.CrossAccountRoleArn) {
		return false
	}

	if !v.ProxyConfig.Equal(other.ProxyConfig) {
		return false
	}

	if !v.Sharing.Equal(other.Sharing) {
		return false
	}

	if !v.SystemComponentsPlacement.Equal(other.SystemComponentsPlacement) {
		return false
	}

	if !v.SpecType.Equal(other.SpecType) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"blueprint":         basetypes.StringType{},
		"blueprint_version": basetypes.StringType{},
		"cloud_provider":    basetypes.StringType{},
		"cni_params": basetypes.ListType{
			ElemType: CniParamsValue{}.Type(ctx),
		},
		"cni_provider":           basetypes.StringType{},
		"cross_account_role_arn": basetypes.StringType{},
		"proxy_config": basetypes.MapType{
			ElemType: types.StringType,
		},
		"sharing": basetypes.ListType{
			ElemType: SharingValue{}.Type(ctx),
		},
		"system_components_placement": basetypes.ListType{
			ElemType: SystemComponentsPlacementValue{}.Type(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CniParamsType{}

type CniParamsType struct {
	basetypes.ObjectType
}

func (t CniParamsType) Equal(o attr.Type) bool {
	other, ok := o.(CniParamsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CniParamsType) String() string {
	return "CniParamsType"
}

func (t CniParamsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customCniCidrAttribute, ok := attributes["custom_cni_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_cni_cidr is missing from object`)

		return nil, diags
	}

	customCniCidrVal, ok := customCniCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_cni_cidr expected to be basetypes.StringValue, was: %T`, customCniCidrAttribute))
	}

	customCniCrdSpecAttribute, ok := attributes["custom_cni_crd_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_cni_crd_spec is missing from object`)

		return nil, diags
	}

	customCniCrdSpecVal, ok := customCniCrdSpecAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_cni_crd_spec expected to be basetypes.SetValue, was: %T`, customCniCrdSpecAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CniParamsValue{
		CustomCniCidr:    customCniCidrVal,
		CustomCniCrdSpec: customCniCrdSpecVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCniParamsValueNull() CniParamsValue {
	return CniParamsValue{
		state: attr.ValueStateNull,
	}
}

func NewCniParamsValueUnknown() CniParamsValue {
	return CniParamsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCniParamsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CniParamsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CniParamsValue Attribute Value",
				"While creating a CniParamsValue value, a missing attribute value was detected. "+
					"A CniParamsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniParamsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CniParamsValue Attribute Type",
				"While creating a CniParamsValue value, an invalid attribute value was detected. "+
					"A CniParamsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniParamsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CniParamsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CniParamsValue Attribute Value",
				"While creating a CniParamsValue value, an extra attribute value was detected. "+
					"A CniParamsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CniParamsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCniParamsValueUnknown(), diags
	}

	customCniCidrAttribute, ok := attributes["custom_cni_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_cni_cidr is missing from object`)

		return NewCniParamsValueUnknown(), diags
	}

	customCniCidrVal, ok := customCniCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_cni_cidr expected to be basetypes.StringValue, was: %T`, customCniCidrAttribute))
	}

	customCniCrdSpecAttribute, ok := attributes["custom_cni_crd_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_cni_crd_spec is missing from object`)

		return NewCniParamsValueUnknown(), diags
	}

	customCniCrdSpecVal, ok := customCniCrdSpecAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_cni_crd_spec expected to be basetypes.SetValue, was: %T`, customCniCrdSpecAttribute))
	}

	if diags.HasError() {
		return NewCniParamsValueUnknown(), diags
	}

	return CniParamsValue{
		CustomCniCidr:    customCniCidrVal,
		CustomCniCrdSpec: customCniCrdSpecVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCniParamsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CniParamsValue {
	object, diags := NewCniParamsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCniParamsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CniParamsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCniParamsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCniParamsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCniParamsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCniParamsValueMust(CniParamsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CniParamsType) ValueType(ctx context.Context) attr.Value {
	return CniParamsValue{}
}

var _ basetypes.ObjectValuable = CniParamsValue{}

type CniParamsValue struct {
	CustomCniCidr    basetypes.StringValue `tfsdk:"custom_cni_cidr"`
	CustomCniCrdSpec basetypes.SetValue    `tfsdk:"custom_cni_crd_spec"`
	state            attr.ValueState
}

func (v CniParamsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["custom_cni_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_cni_crd_spec"] = basetypes.SetType{
		ElemType: CustomCniCrdSpecValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CustomCniCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_cni_cidr"] = val

		val, err = v.CustomCniCrdSpec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_cni_crd_spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CniParamsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CniParamsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CniParamsValue) String() string {
	return "CniParamsValue"
}

func (v CniParamsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	customCniCrdSpec := types.SetValueMust(
		CustomCniCrdSpecType{
			basetypes.ObjectType{
				AttrTypes: CustomCniCrdSpecValue{}.AttributeTypes(ctx),
			},
		},
		v.CustomCniCrdSpec.Elements(),
	)

	if v.CustomCniCrdSpec.IsNull() {
		customCniCrdSpec = types.SetNull(
			CustomCniCrdSpecType{
				basetypes.ObjectType{
					AttrTypes: CustomCniCrdSpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CustomCniCrdSpec.IsUnknown() {
		customCniCrdSpec = types.SetUnknown(
			CustomCniCrdSpecType{
				basetypes.ObjectType{
					AttrTypes: CustomCniCrdSpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"custom_cni_cidr": basetypes.StringType{},
		"custom_cni_crd_spec": basetypes.SetType{
			ElemType: CustomCniCrdSpecValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_cni_cidr":     v.CustomCniCidr,
			"custom_cni_crd_spec": customCniCrdSpec,
		})

	return objVal, diags
}

func (v CniParamsValue) Equal(o attr.Value) bool {
	other, ok := o.(CniParamsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomCniCidr.Equal(other.CustomCniCidr) {
		return false
	}

	if !v.CustomCniCrdSpec.Equal(other.CustomCniCrdSpec) {
		return false
	}

	return true
}

func (v CniParamsValue) Type(ctx context.Context) attr.Type {
	return CniParamsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CniParamsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_cni_cidr": basetypes.StringType{},
		"custom_cni_crd_spec": basetypes.SetType{
			ElemType: CustomCniCrdSpecValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = CustomCniCrdSpecType{}

type CustomCniCrdSpecType struct {
	basetypes.ObjectType
}

func (t CustomCniCrdSpecType) Equal(o attr.Type) bool {
	other, ok := o.(CustomCniCrdSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomCniCrdSpecType) String() string {
	return "CustomCniCrdSpecType"
}

func (t CustomCniCrdSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cniSpecAttribute, ok := attributes["cni_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_spec is missing from object`)

		return nil, diags
	}

	cniSpecVal, ok := cniSpecAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_spec expected to be basetypes.SetValue, was: %T`, cniSpecAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomCniCrdSpecValue{
		CniSpec: cniSpecVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCustomCniCrdSpecValueNull() CustomCniCrdSpecValue {
	return CustomCniCrdSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomCniCrdSpecValueUnknown() CustomCniCrdSpecValue {
	return CustomCniCrdSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomCniCrdSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomCniCrdSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomCniCrdSpecValue Attribute Value",
				"While creating a CustomCniCrdSpecValue value, a missing attribute value was detected. "+
					"A CustomCniCrdSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomCniCrdSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomCniCrdSpecValue Attribute Type",
				"While creating a CustomCniCrdSpecValue value, an invalid attribute value was detected. "+
					"A CustomCniCrdSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomCniCrdSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomCniCrdSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomCniCrdSpecValue Attribute Value",
				"While creating a CustomCniCrdSpecValue value, an extra attribute value was detected. "+
					"A CustomCniCrdSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomCniCrdSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomCniCrdSpecValueUnknown(), diags
	}

	cniSpecAttribute, ok := attributes["cni_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_spec is missing from object`)

		return NewCustomCniCrdSpecValueUnknown(), diags
	}

	cniSpecVal, ok := cniSpecAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_spec expected to be basetypes.SetValue, was: %T`, cniSpecAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCustomCniCrdSpecValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewCustomCniCrdSpecValueUnknown(), diags
	}

	return CustomCniCrdSpecValue{
		CniSpec: cniSpecVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCustomCniCrdSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomCniCrdSpecValue {
	object, diags := NewCustomCniCrdSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomCniCrdSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomCniCrdSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomCniCrdSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomCniCrdSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomCniCrdSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomCniCrdSpecValueMust(CustomCniCrdSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomCniCrdSpecType) ValueType(ctx context.Context) attr.Value {
	return CustomCniCrdSpecValue{}
}

var _ basetypes.ObjectValuable = CustomCniCrdSpecValue{}

type CustomCniCrdSpecValue struct {
	CniSpec basetypes.SetValue    `tfsdk:"cni_spec"`
	Name    basetypes.StringValue `tfsdk:"name"`
	state   attr.ValueState
}

func (v CustomCniCrdSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cni_spec"] = basetypes.SetType{
		ElemType: CniSpecValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CniSpec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cni_spec"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomCniCrdSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomCniCrdSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomCniCrdSpecValue) String() string {
	return "CustomCniCrdSpecValue"
}

func (v CustomCniCrdSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	cniSpec := types.SetValueMust(
		CniSpecType{
			basetypes.ObjectType{
				AttrTypes: CniSpecValue{}.AttributeTypes(ctx),
			},
		},
		v.CniSpec.Elements(),
	)

	if v.CniSpec.IsNull() {
		cniSpec = types.SetNull(
			CniSpecType{
				basetypes.ObjectType{
					AttrTypes: CniSpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CniSpec.IsUnknown() {
		cniSpec = types.SetUnknown(
			CniSpecType{
				basetypes.ObjectType{
					AttrTypes: CniSpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"cni_spec": basetypes.SetType{
			ElemType: CniSpecValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cni_spec": cniSpec,
			"name":     v.Name,
		})

	return objVal, diags
}

func (v CustomCniCrdSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomCniCrdSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CniSpec.Equal(other.CniSpec) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v CustomCniCrdSpecValue) Type(ctx context.Context) attr.Type {
	return CustomCniCrdSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomCniCrdSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cni_spec": basetypes.SetType{
			ElemType: CniSpecValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CniSpecType{}

type CniSpecType struct {
	basetypes.ObjectType
}

func (t CniSpecType) Equal(o attr.Type) bool {
	other, ok := o.(CniSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CniSpecType) String() string {
	return "CniSpecType"
}

func (t CniSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	securityGroups2Attribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups2 is missing from object`)

		return nil, diags
	}

	securityGroups2Val, ok := securityGroups2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups2 expected to be basetypes.SetValue, was: %T`, securityGroups2Attribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CniSpecValue{
		SecurityGroups2: securityGroups2Val,
		Subnet:          subnetVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewCniSpecValueNull() CniSpecValue {
	return CniSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewCniSpecValueUnknown() CniSpecValue {
	return CniSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCniSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CniSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CniSpecValue Attribute Value",
				"While creating a CniSpecValue value, a missing attribute value was detected. "+
					"A CniSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CniSpecValue Attribute Type",
				"While creating a CniSpecValue value, an invalid attribute value was detected. "+
					"A CniSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CniSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CniSpecValue Attribute Value",
				"While creating a CniSpecValue value, an extra attribute value was detected. "+
					"A CniSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CniSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCniSpecValueUnknown(), diags
	}

	securityGroups2Attribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups2 is missing from object`)

		return NewCniSpecValueUnknown(), diags
	}

	securityGroups2Val, ok := securityGroups2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups2 expected to be basetypes.SetValue, was: %T`, securityGroups2Attribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewCniSpecValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return NewCniSpecValueUnknown(), diags
	}

	return CniSpecValue{
		SecurityGroups2: securityGroups2Val,
		Subnet:          subnetVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewCniSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CniSpecValue {
	object, diags := NewCniSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCniSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CniSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCniSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCniSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCniSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCniSpecValueMust(CniSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CniSpecType) ValueType(ctx context.Context) attr.Value {
	return CniSpecValue{}
}

var _ basetypes.ObjectValuable = CniSpecValue{}

type CniSpecValue struct {
	SecurityGroups2 basetypes.SetValue    `tfsdk:"security_groups"`
	Subnet          basetypes.StringValue `tfsdk:"subnet"`
	state           attr.ValueState
}

func (v CniSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["security_groups"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SecurityGroups2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CniSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CniSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CniSpecValue) String() string {
	return "CniSpecValue"
}

func (v CniSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var securityGroups2Val basetypes.SetValue
	switch {
	case v.SecurityGroups2.IsUnknown():
		securityGroups2Val = types.SetUnknown(types.StringType)
	case v.SecurityGroups2.IsNull():
		securityGroups2Val = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		securityGroups2Val, d = types.SetValue(types.StringType, v.SecurityGroups2.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"security_groups": basetypes.SetType{
				ElemType: types.StringType,
			},
			"subnet": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"security_groups": basetypes.SetType{
			ElemType: types.StringType,
		},
		"subnet": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"security_groups": securityGroups2Val,
			"subnet":          v.Subnet,
		})

	return objVal, diags
}

func (v CniSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(CniSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SecurityGroups2.Equal(other.SecurityGroups2) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	return true
}

func (v CniSpecValue) Type(ctx context.Context) attr.Type {
	return CniSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CniSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"security_groups": basetypes.SetType{
			ElemType: types.StringType,
		},
		"subnet": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SharingType{}

type SharingType struct {
	basetypes.ObjectType
}

func (t SharingType) Equal(o attr.Type) bool {
	other, ok := o.(SharingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SharingType) String() string {
	return "SharingType"
}

func (t SharingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	projectsAttribute, ok := attributes["projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`projects is missing from object`)

		return nil, diags
	}

	projectsVal, ok := projectsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`projects expected to be basetypes.ListValue, was: %T`, projectsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SharingValue{
		Enabled:  enabledVal,
		Projects: projectsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSharingValueNull() SharingValue {
	return SharingValue{
		state: attr.ValueStateNull,
	}
}

func NewSharingValueUnknown() SharingValue {
	return SharingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSharingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SharingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SharingValue Attribute Value",
				"While creating a SharingValue value, a missing attribute value was detected. "+
					"A SharingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SharingValue Attribute Type",
				"While creating a SharingValue value, an invalid attribute value was detected. "+
					"A SharingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SharingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SharingValue Attribute Value",
				"While creating a SharingValue value, an extra attribute value was detected. "+
					"A SharingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SharingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSharingValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSharingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	projectsAttribute, ok := attributes["projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`projects is missing from object`)

		return NewSharingValueUnknown(), diags
	}

	projectsVal, ok := projectsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`projects expected to be basetypes.ListValue, was: %T`, projectsAttribute))
	}

	if diags.HasError() {
		return NewSharingValueUnknown(), diags
	}

	return SharingValue{
		Enabled:  enabledVal,
		Projects: projectsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSharingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SharingValue {
	object, diags := NewSharingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSharingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SharingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSharingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSharingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSharingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSharingValueMust(SharingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SharingType) ValueType(ctx context.Context) attr.Value {
	return SharingValue{}
}

var _ basetypes.ObjectValuable = SharingValue{}

type SharingValue struct {
	Enabled  basetypes.BoolValue `tfsdk:"enabled"`
	Projects basetypes.ListValue `tfsdk:"projects"`
	state    attr.ValueState
}

func (v SharingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["projects"] = basetypes.ListType{
		ElemType: ProjectsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Projects.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["projects"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SharingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SharingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SharingValue) String() string {
	return "SharingValue"
}

func (v SharingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	projects := types.ListValueMust(
		ProjectsType{
			basetypes.ObjectType{
				AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
			},
		},
		v.Projects.Elements(),
	)

	if v.Projects.IsNull() {
		projects = types.ListNull(
			ProjectsType{
				basetypes.ObjectType{
					AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Projects.IsUnknown() {
		projects = types.ListUnknown(
			ProjectsType{
				basetypes.ObjectType{
					AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"projects": basetypes.ListType{
			ElemType: ProjectsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":  v.Enabled,
			"projects": projects,
		})

	return objVal, diags
}

func (v SharingValue) Equal(o attr.Value) bool {
	other, ok := o.(SharingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Projects.Equal(other.Projects) {
		return false
	}

	return true
}

func (v SharingValue) Type(ctx context.Context) attr.Type {
	return SharingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SharingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"projects": basetypes.ListType{
			ElemType: ProjectsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ProjectsType{}

type ProjectsType struct {
	basetypes.ObjectType
}

func (t ProjectsType) Equal(o attr.Type) bool {
	other, ok := o.(ProjectsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProjectsType) String() string {
	return "ProjectsType"
}

func (t ProjectsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProjectsValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProjectsValueNull() ProjectsValue {
	return ProjectsValue{
		state: attr.ValueStateNull,
	}
}

func NewProjectsValueUnknown() ProjectsValue {
	return ProjectsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProjectsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProjectsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProjectsValue Attribute Value",
				"While creating a ProjectsValue value, a missing attribute value was detected. "+
					"A ProjectsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProjectsValue Attribute Type",
				"While creating a ProjectsValue value, an invalid attribute value was detected. "+
					"A ProjectsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProjectsValue Attribute Value",
				"While creating a ProjectsValue value, an extra attribute value was detected. "+
					"A ProjectsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProjectsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProjectsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewProjectsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewProjectsValueUnknown(), diags
	}

	return ProjectsValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProjectsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProjectsValue {
	object, diags := NewProjectsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProjectsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProjectsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProjectsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProjectsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProjectsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProjectsValueMust(ProjectsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProjectsType) ValueType(ctx context.Context) attr.Value {
	return ProjectsValue{}
}

var _ basetypes.ObjectValuable = ProjectsValue{}

type ProjectsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v ProjectsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProjectsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProjectsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProjectsValue) String() string {
	return "ProjectsValue"
}

func (v ProjectsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v ProjectsValue) Equal(o attr.Value) bool {
	other, ok := o.(ProjectsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ProjectsValue) Type(ctx context.Context) attr.Type {
	return ProjectsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProjectsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SystemComponentsPlacementType{}

type SystemComponentsPlacementType struct {
	basetypes.ObjectType
}

func (t SystemComponentsPlacementType) Equal(o attr.Type) bool {
	other, ok := o.(SystemComponentsPlacementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SystemComponentsPlacementType) String() string {
	return "SystemComponentsPlacementType"
}

func (t SystemComponentsPlacementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	daemonsetOverrideAttribute, ok := attributes["daemonset_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daemonset_override is missing from object`)

		return nil, diags
	}

	daemonsetOverrideVal, ok := daemonsetOverrideAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daemonset_override expected to be basetypes.ListValue, was: %T`, daemonsetOverrideAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return nil, diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.MapValue, was: %T`, nodeSelectorAttribute))
	}

	tolerationsAttribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations is missing from object`)

		return nil, diags
	}

	tolerationsVal, ok := tolerationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations expected to be basetypes.ListValue, was: %T`, tolerationsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SystemComponentsPlacementValue{
		DaemonsetOverride: daemonsetOverrideVal,
		NodeSelector:      nodeSelectorVal,
		Tolerations:       tolerationsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSystemComponentsPlacementValueNull() SystemComponentsPlacementValue {
	return SystemComponentsPlacementValue{
		state: attr.ValueStateNull,
	}
}

func NewSystemComponentsPlacementValueUnknown() SystemComponentsPlacementValue {
	return SystemComponentsPlacementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSystemComponentsPlacementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SystemComponentsPlacementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SystemComponentsPlacementValue Attribute Value",
				"While creating a SystemComponentsPlacementValue value, a missing attribute value was detected. "+
					"A SystemComponentsPlacementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SystemComponentsPlacementValue Attribute Type",
				"While creating a SystemComponentsPlacementValue value, an invalid attribute value was detected. "+
					"A SystemComponentsPlacementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SystemComponentsPlacementValue Attribute Value",
				"While creating a SystemComponentsPlacementValue value, an extra attribute value was detected. "+
					"A SystemComponentsPlacementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SystemComponentsPlacementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	daemonsetOverrideAttribute, ok := attributes["daemonset_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daemonset_override is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	daemonsetOverrideVal, ok := daemonsetOverrideAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daemonset_override expected to be basetypes.ListValue, was: %T`, daemonsetOverrideAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.MapValue, was: %T`, nodeSelectorAttribute))
	}

	tolerationsAttribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	tolerationsVal, ok := tolerationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations expected to be basetypes.ListValue, was: %T`, tolerationsAttribute))
	}

	if diags.HasError() {
		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	return SystemComponentsPlacementValue{
		DaemonsetOverride: daemonsetOverrideVal,
		NodeSelector:      nodeSelectorVal,
		Tolerations:       tolerationsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSystemComponentsPlacementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SystemComponentsPlacementValue {
	object, diags := NewSystemComponentsPlacementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSystemComponentsPlacementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SystemComponentsPlacementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSystemComponentsPlacementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSystemComponentsPlacementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSystemComponentsPlacementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSystemComponentsPlacementValueMust(SystemComponentsPlacementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SystemComponentsPlacementType) ValueType(ctx context.Context) attr.Value {
	return SystemComponentsPlacementValue{}
}

var _ basetypes.ObjectValuable = SystemComponentsPlacementValue{}

type SystemComponentsPlacementValue struct {
	DaemonsetOverride basetypes.ListValue `tfsdk:"daemonset_override"`
	NodeSelector      basetypes.MapValue  `tfsdk:"node_selector"`
	Tolerations       basetypes.ListValue `tfsdk:"tolerations"`
	state             attr.ValueState
}

func (v SystemComponentsPlacementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["daemonset_override"] = basetypes.ListType{
		ElemType: DaemonsetOverrideValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_selector"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tolerations"] = basetypes.ListType{
		ElemType: TolerationsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DaemonsetOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daemonset_override"] = val

		val, err = v.NodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selector"] = val

		val, err = v.Tolerations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tolerations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SystemComponentsPlacementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SystemComponentsPlacementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SystemComponentsPlacementValue) String() string {
	return "SystemComponentsPlacementValue"
}

func (v SystemComponentsPlacementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	daemonsetOverride := types.ListValueMust(
		DaemonsetOverrideType{
			basetypes.ObjectType{
				AttrTypes: DaemonsetOverrideValue{}.AttributeTypes(ctx),
			},
		},
		v.DaemonsetOverride.Elements(),
	)

	if v.DaemonsetOverride.IsNull() {
		daemonsetOverride = types.ListNull(
			DaemonsetOverrideType{
				basetypes.ObjectType{
					AttrTypes: DaemonsetOverrideValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DaemonsetOverride.IsUnknown() {
		daemonsetOverride = types.ListUnknown(
			DaemonsetOverrideType{
				basetypes.ObjectType{
					AttrTypes: DaemonsetOverrideValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	tolerations := types.ListValueMust(
		TolerationsType{
			basetypes.ObjectType{
				AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
			},
		},
		v.Tolerations.Elements(),
	)

	if v.Tolerations.IsNull() {
		tolerations = types.ListNull(
			TolerationsType{
				basetypes.ObjectType{
					AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tolerations.IsUnknown() {
		tolerations = types.ListUnknown(
			TolerationsType{
				basetypes.ObjectType{
					AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var nodeSelectorVal basetypes.MapValue
	switch {
	case v.NodeSelector.IsUnknown():
		nodeSelectorVal = types.MapUnknown(types.StringType)
	case v.NodeSelector.IsNull():
		nodeSelectorVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorVal, d = types.MapValue(types.StringType, v.NodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"daemonset_override": basetypes.ListType{
				ElemType: DaemonsetOverrideValue{}.Type(ctx),
			},
			"node_selector": basetypes.MapType{
				ElemType: types.StringType,
			},
			"tolerations": basetypes.ListType{
				ElemType: TolerationsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"daemonset_override": basetypes.ListType{
			ElemType: DaemonsetOverrideValue{}.Type(ctx),
		},
		"node_selector": basetypes.MapType{
			ElemType: types.StringType,
		},
		"tolerations": basetypes.ListType{
			ElemType: TolerationsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"daemonset_override": daemonsetOverride,
			"node_selector":      nodeSelectorVal,
			"tolerations":        tolerations,
		})

	return objVal, diags
}

func (v SystemComponentsPlacementValue) Equal(o attr.Value) bool {
	other, ok := o.(SystemComponentsPlacementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DaemonsetOverride.Equal(other.DaemonsetOverride) {
		return false
	}

	if !v.NodeSelector.Equal(other.NodeSelector) {
		return false
	}

	if !v.Tolerations.Equal(other.Tolerations) {
		return false
	}

	return true
}

func (v SystemComponentsPlacementValue) Type(ctx context.Context) attr.Type {
	return SystemComponentsPlacementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SystemComponentsPlacementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daemonset_override": basetypes.ListType{
			ElemType: DaemonsetOverrideValue{}.Type(ctx),
		},
		"node_selector": basetypes.MapType{
			ElemType: types.StringType,
		},
		"tolerations": basetypes.ListType{
			ElemType: TolerationsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DaemonsetOverrideType{}

type DaemonsetOverrideType struct {
	basetypes.ObjectType
}

func (t DaemonsetOverrideType) Equal(o attr.Type) bool {
	other, ok := o.(DaemonsetOverrideType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DaemonsetOverrideType) String() string {
	return "DaemonsetOverrideType"
}

func (t DaemonsetOverrideType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeSelectionEnabledAttribute, ok := attributes["node_selection_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selection_enabled is missing from object`)

		return nil, diags
	}

	nodeSelectionEnabledVal, ok := nodeSelectionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selection_enabled expected to be basetypes.BoolValue, was: %T`, nodeSelectionEnabledAttribute))
	}

	tolerations2Attribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations2 is missing from object`)

		return nil, diags
	}

	tolerations2Val, ok := tolerations2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations2 expected to be basetypes.ListValue, was: %T`, tolerations2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DaemonsetOverrideValue{
		NodeSelectionEnabled: nodeSelectionEnabledVal,
		Tolerations2:         tolerations2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDaemonsetOverrideValueNull() DaemonsetOverrideValue {
	return DaemonsetOverrideValue{
		state: attr.ValueStateNull,
	}
}

func NewDaemonsetOverrideValueUnknown() DaemonsetOverrideValue {
	return DaemonsetOverrideValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDaemonsetOverrideValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DaemonsetOverrideValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DaemonsetOverrideValue Attribute Value",
				"While creating a DaemonsetOverrideValue value, a missing attribute value was detected. "+
					"A DaemonsetOverrideValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DaemonsetOverrideValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DaemonsetOverrideValue Attribute Type",
				"While creating a DaemonsetOverrideValue value, an invalid attribute value was detected. "+
					"A DaemonsetOverrideValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DaemonsetOverrideValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DaemonsetOverrideValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DaemonsetOverrideValue Attribute Value",
				"While creating a DaemonsetOverrideValue value, an extra attribute value was detected. "+
					"A DaemonsetOverrideValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DaemonsetOverrideValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDaemonsetOverrideValueUnknown(), diags
	}

	nodeSelectionEnabledAttribute, ok := attributes["node_selection_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selection_enabled is missing from object`)

		return NewDaemonsetOverrideValueUnknown(), diags
	}

	nodeSelectionEnabledVal, ok := nodeSelectionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selection_enabled expected to be basetypes.BoolValue, was: %T`, nodeSelectionEnabledAttribute))
	}

	tolerations2Attribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations2 is missing from object`)

		return NewDaemonsetOverrideValueUnknown(), diags
	}

	tolerations2Val, ok := tolerations2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations2 expected to be basetypes.ListValue, was: %T`, tolerations2Attribute))
	}

	if diags.HasError() {
		return NewDaemonsetOverrideValueUnknown(), diags
	}

	return DaemonsetOverrideValue{
		NodeSelectionEnabled: nodeSelectionEnabledVal,
		Tolerations2:         tolerations2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDaemonsetOverrideValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DaemonsetOverrideValue {
	object, diags := NewDaemonsetOverrideValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDaemonsetOverrideValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DaemonsetOverrideType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDaemonsetOverrideValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDaemonsetOverrideValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDaemonsetOverrideValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDaemonsetOverrideValueMust(DaemonsetOverrideValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DaemonsetOverrideType) ValueType(ctx context.Context) attr.Value {
	return DaemonsetOverrideValue{}
}

var _ basetypes.ObjectValuable = DaemonsetOverrideValue{}

type DaemonsetOverrideValue struct {
	NodeSelectionEnabled basetypes.BoolValue `tfsdk:"node_selection_enabled"`
	Tolerations2         basetypes.ListValue `tfsdk:"tolerations"`
	state                attr.ValueState
}

func (v DaemonsetOverrideValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["node_selection_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tolerations"] = basetypes.ListType{
		ElemType: Tolerations2Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NodeSelectionEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selection_enabled"] = val

		val, err = v.Tolerations2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tolerations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DaemonsetOverrideValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DaemonsetOverrideValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DaemonsetOverrideValue) String() string {
	return "DaemonsetOverrideValue"
}

func (v DaemonsetOverrideValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	tolerations2 := types.ListValueMust(
		Tolerations2Type{
			basetypes.ObjectType{
				AttrTypes: Tolerations2Value{}.AttributeTypes(ctx),
			},
		},
		v.Tolerations2.Elements(),
	)

	if v.Tolerations2.IsNull() {
		tolerations2 = types.ListNull(
			Tolerations2Type{
				basetypes.ObjectType{
					AttrTypes: Tolerations2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tolerations2.IsUnknown() {
		tolerations2 = types.ListUnknown(
			Tolerations2Type{
				basetypes.ObjectType{
					AttrTypes: Tolerations2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"node_selection_enabled": basetypes.BoolType{},
		"tolerations": basetypes.ListType{
			ElemType: Tolerations2Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node_selection_enabled": v.NodeSelectionEnabled,
			"tolerations":            tolerations2,
		})

	return objVal, diags
}

func (v DaemonsetOverrideValue) Equal(o attr.Value) bool {
	other, ok := o.(DaemonsetOverrideValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NodeSelectionEnabled.Equal(other.NodeSelectionEnabled) {
		return false
	}

	if !v.Tolerations2.Equal(other.Tolerations2) {
		return false
	}

	return true
}

func (v DaemonsetOverrideValue) Type(ctx context.Context) attr.Type {
	return DaemonsetOverrideType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DaemonsetOverrideValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node_selection_enabled": basetypes.BoolType{},
		"tolerations": basetypes.ListType{
			ElemType: Tolerations2Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Tolerations2Type{}

type Tolerations2Type struct {
	basetypes.ObjectType
}

func (t Tolerations2Type) Equal(o attr.Type) bool {
	other, ok := o.(Tolerations2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Tolerations2Type) String() string {
	return "Tolerations2Type"
}

func (t Tolerations2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return nil, diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return nil, diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Tolerations2Value{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerations2ValueNull() Tolerations2Value {
	return Tolerations2Value{
		state: attr.ValueStateNull,
	}
}

func NewTolerations2ValueUnknown() Tolerations2Value {
	return Tolerations2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTolerations2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Tolerations2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Tolerations2Value Attribute Value",
				"While creating a Tolerations2Value value, a missing attribute value was detected. "+
					"A Tolerations2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Tolerations2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Tolerations2Value Attribute Type",
				"While creating a Tolerations2Value value, an invalid attribute value was detected. "+
					"A Tolerations2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Tolerations2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Tolerations2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Tolerations2Value Attribute Value",
				"While creating a Tolerations2Value value, an extra attribute value was detected. "+
					"A Tolerations2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Tolerations2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTolerations2ValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTolerations2ValueUnknown(), diags
	}

	return Tolerations2Value{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerations2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Tolerations2Value {
	object, diags := NewTolerations2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTolerations2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Tolerations2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTolerations2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTolerations2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTolerations2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTolerations2ValueMust(Tolerations2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Tolerations2Type) ValueType(ctx context.Context) attr.Value {
	return Tolerations2Value{}
}

var _ basetypes.ObjectValuable = Tolerations2Value{}

type Tolerations2Value struct {
	Effect            basetypes.StringValue `tfsdk:"effect"`
	Key               basetypes.StringValue `tfsdk:"key"`
	Operator          basetypes.StringValue `tfsdk:"operator"`
	TolerationSeconds basetypes.Int64Value  `tfsdk:"toleration_seconds"`
	Value             basetypes.StringValue `tfsdk:"value"`
	state             attr.ValueState
}

func (v Tolerations2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["toleration_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Operator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operator"] = val

		val, err = v.TolerationSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["toleration_seconds"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Tolerations2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Tolerations2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Tolerations2Value) String() string {
	return "Tolerations2Value"
}

func (v Tolerations2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect":             v.Effect,
			"key":                v.Key,
			"operator":           v.Operator,
			"toleration_seconds": v.TolerationSeconds,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v Tolerations2Value) Equal(o attr.Value) bool {
	other, ok := o.(Tolerations2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Operator.Equal(other.Operator) {
		return false
	}

	if !v.TolerationSeconds.Equal(other.TolerationSeconds) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v Tolerations2Value) Type(ctx context.Context) attr.Type {
	return Tolerations2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Tolerations2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TolerationsType{}

type TolerationsType struct {
	basetypes.ObjectType
}

func (t TolerationsType) Equal(o attr.Type) bool {
	other, ok := o.(TolerationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TolerationsType) String() string {
	return "TolerationsType"
}

func (t TolerationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return nil, diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return nil, diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TolerationsValue{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerationsValueNull() TolerationsValue {
	return TolerationsValue{
		state: attr.ValueStateNull,
	}
}

func NewTolerationsValueUnknown() TolerationsValue {
	return TolerationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTolerationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TolerationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TolerationsValue Attribute Value",
				"While creating a TolerationsValue value, a missing attribute value was detected. "+
					"A TolerationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TolerationsValue Attribute Type",
				"While creating a TolerationsValue value, an invalid attribute value was detected. "+
					"A TolerationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TolerationsValue Attribute Value",
				"While creating a TolerationsValue value, an extra attribute value was detected. "+
					"A TolerationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TolerationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTolerationsValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTolerationsValueUnknown(), diags
	}

	return TolerationsValue{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TolerationsValue {
	object, diags := NewTolerationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTolerationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TolerationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTolerationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTolerationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTolerationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTolerationsValueMust(TolerationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TolerationsType) ValueType(ctx context.Context) attr.Value {
	return TolerationsValue{}
}

var _ basetypes.ObjectValuable = TolerationsValue{}

type TolerationsValue struct {
	Effect            basetypes.StringValue `tfsdk:"effect"`
	Key               basetypes.StringValue `tfsdk:"key"`
	Operator          basetypes.StringValue `tfsdk:"operator"`
	TolerationSeconds basetypes.Int64Value  `tfsdk:"toleration_seconds"`
	Value             basetypes.StringValue `tfsdk:"value"`
	state             attr.ValueState
}

func (v TolerationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["toleration_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Operator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operator"] = val

		val, err = v.TolerationSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["toleration_seconds"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TolerationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TolerationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TolerationsValue) String() string {
	return "TolerationsValue"
}

func (v TolerationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect":             v.Effect,
			"key":                v.Key,
			"operator":           v.Operator,
			"toleration_seconds": v.TolerationSeconds,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v TolerationsValue) Equal(o attr.Value) bool {
	other, ok := o.(TolerationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Operator.Equal(other.Operator) {
		return false
	}

	if !v.TolerationSeconds.Equal(other.TolerationSeconds) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TolerationsValue) Type(ctx context.Context) attr.Type {
	return TolerationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TolerationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterConfigType{}

type ClusterConfigType struct {
	basetypes.ObjectType
}

func (t ClusterConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterConfigType) String() string {
	return "ClusterConfigType"
}

func (t ClusterConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessConfigAttribute, ok := attributes["access_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_config is missing from object`)

		return nil, diags
	}

	accessConfigVal, ok := accessConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_config expected to be basetypes.ListValue, was: %T`, accessConfigAttribute))
	}

	addonsAttribute, ok := attributes["addons"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addons is missing from object`)

		return nil, diags
	}

	addonsVal, ok := addonsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addons expected to be basetypes.SetValue, was: %T`, addonsAttribute))
	}

	addonsConfigAttribute, ok := attributes["addons_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addons_config is missing from object`)

		return nil, diags
	}

	addonsConfigVal, ok := addonsConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addons_config expected to be basetypes.ListValue, was: %T`, addonsConfigAttribute))
	}

	apiversionAttribute, ok := attributes["apiversion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apiversion is missing from object`)

		return nil, diags
	}

	apiversionVal, ok := apiversionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apiversion expected to be basetypes.StringValue, was: %T`, apiversionAttribute))
	}

	autoModeConfigAttribute, ok := attributes["auto_mode_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_mode_config is missing from object`)

		return nil, diags
	}

	autoModeConfigVal, ok := autoModeConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_mode_config expected to be basetypes.ListValue, was: %T`, autoModeConfigAttribute))
	}

	availabilityZonesAttribute, ok := attributes["availability_zones"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones is missing from object`)

		return nil, diags
	}

	availabilityZonesVal, ok := availabilityZonesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones expected to be basetypes.ListValue, was: %T`, availabilityZonesAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.ListValue, was: %T`, cloudWatchAttribute))
	}

	fargateProfilesAttribute, ok := attributes["fargate_profiles"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fargate_profiles is missing from object`)

		return nil, diags
	}

	fargateProfilesVal, ok := fargateProfilesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fargate_profiles expected to be basetypes.ListValue, was: %T`, fargateProfilesAttribute))
	}

	iam3Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam3 is missing from object`)

		return nil, diags
	}

	iam3Val, ok := iam3Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam3 expected to be basetypes.ListValue, was: %T`, iam3Attribute))
	}

	identityMappingsAttribute, ok := attributes["identity_mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity_mappings is missing from object`)

		return nil, diags
	}

	identityMappingsVal, ok := identityMappingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity_mappings expected to be basetypes.ListValue, was: %T`, identityMappingsAttribute))
	}

	identityProvidersAttribute, ok := attributes["identity_providers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity_providers is missing from object`)

		return nil, diags
	}

	identityProvidersVal, ok := identityProvidersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity_providers expected to be basetypes.ListValue, was: %T`, identityProvidersAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	kubernetesNetworkConfigAttribute, ok := attributes["kubernetes_network_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_network_config is missing from object`)

		return nil, diags
	}

	kubernetesNetworkConfigVal, ok := kubernetesNetworkConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_network_config expected to be basetypes.ListValue, was: %T`, kubernetesNetworkConfigAttribute))
	}

	managedNodegroupsAttribute, ok := attributes["managed_nodegroups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_nodegroups is missing from object`)

		return nil, diags
	}

	managedNodegroupsVal, ok := managedNodegroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_nodegroups expected to be basetypes.ListValue, was: %T`, managedNodegroupsAttribute))
	}

	managedNodegroupsMapAttribute, ok := attributes["managed_nodegroups_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_nodegroups_map is missing from object`)

		return nil, diags
	}

	managedNodegroupsMapVal, ok := managedNodegroupsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_nodegroups_map expected to be basetypes.MapValue, was: %T`, managedNodegroupsMapAttribute))
	}

	metadata2Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata2 is missing from object`)

		return nil, diags
	}

	metadata2Val, ok := metadata2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata2 expected to be basetypes.ListValue, was: %T`, metadata2Attribute))
	}

	nodeGroupsAttribute, ok := attributes["node_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups is missing from object`)

		return nil, diags
	}

	nodeGroupsVal, ok := nodeGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups expected to be basetypes.ListValue, was: %T`, nodeGroupsAttribute))
	}

	nodeGroupsMapAttribute, ok := attributes["node_groups_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups_map is missing from object`)

		return nil, diags
	}

	nodeGroupsMapVal, ok := nodeGroupsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups_map expected to be basetypes.MapValue, was: %T`, nodeGroupsMapAttribute))
	}

	privateClusterAttribute, ok := attributes["private_cluster"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_cluster is missing from object`)

		return nil, diags
	}

	privateClusterVal, ok := privateClusterAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_cluster expected to be basetypes.ListValue, was: %T`, privateClusterAttribute))
	}

	secretsEncryptionAttribute, ok := attributes["secrets_encryption"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secrets_encryption is missing from object`)

		return nil, diags
	}

	secretsEncryptionVal, ok := secretsEncryptionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secrets_encryption expected to be basetypes.ListValue, was: %T`, secretsEncryptionAttribute))
	}

	vpcAttribute, ok := attributes["vpc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc is missing from object`)

		return nil, diags
	}

	vpcVal, ok := vpcAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc expected to be basetypes.ListValue, was: %T`, vpcAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterConfigValue{
		AccessConfig:            accessConfigVal,
		Addons:                  addonsVal,
		AddonsConfig:            addonsConfigVal,
		Apiversion:              apiversionVal,
		AutoModeConfig:          autoModeConfigVal,
		AvailabilityZones:       availabilityZonesVal,
		CloudWatch:              cloudWatchVal,
		FargateProfiles:         fargateProfilesVal,
		Iam3:                    iam3Val,
		IdentityMappings:        identityMappingsVal,
		IdentityProviders:       identityProvidersVal,
		Kind:                    kindVal,
		KubernetesNetworkConfig: kubernetesNetworkConfigVal,
		ManagedNodegroups:       managedNodegroupsVal,
		ManagedNodegroupsMap:    managedNodegroupsMapVal,
		Metadata2:               metadata2Val,
		NodeGroups:              nodeGroupsVal,
		NodeGroupsMap:           nodeGroupsMapVal,
		PrivateCluster:          privateClusterVal,
		SecretsEncryption:       secretsEncryptionVal,
		Vpc:                     vpcVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueNull() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterConfigValueUnknown() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, a missing attribute value was detected. "+
					"A ClusterConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterConfigValue Attribute Type",
				"While creating a ClusterConfigValue value, an invalid attribute value was detected. "+
					"A ClusterConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, an extra attribute value was detected. "+
					"A ClusterConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	accessConfigAttribute, ok := attributes["access_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_config is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	accessConfigVal, ok := accessConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_config expected to be basetypes.ListValue, was: %T`, accessConfigAttribute))
	}

	addonsAttribute, ok := attributes["addons"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addons is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	addonsVal, ok := addonsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addons expected to be basetypes.SetValue, was: %T`, addonsAttribute))
	}

	addonsConfigAttribute, ok := attributes["addons_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addons_config is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	addonsConfigVal, ok := addonsConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addons_config expected to be basetypes.ListValue, was: %T`, addonsConfigAttribute))
	}

	apiversionAttribute, ok := attributes["apiversion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apiversion is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	apiversionVal, ok := apiversionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apiversion expected to be basetypes.StringValue, was: %T`, apiversionAttribute))
	}

	autoModeConfigAttribute, ok := attributes["auto_mode_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_mode_config is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	autoModeConfigVal, ok := autoModeConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_mode_config expected to be basetypes.ListValue, was: %T`, autoModeConfigAttribute))
	}

	availabilityZonesAttribute, ok := attributes["availability_zones"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	availabilityZonesVal, ok := availabilityZonesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones expected to be basetypes.ListValue, was: %T`, availabilityZonesAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.ListValue, was: %T`, cloudWatchAttribute))
	}

	fargateProfilesAttribute, ok := attributes["fargate_profiles"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fargate_profiles is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	fargateProfilesVal, ok := fargateProfilesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fargate_profiles expected to be basetypes.ListValue, was: %T`, fargateProfilesAttribute))
	}

	iam3Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam3 is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	iam3Val, ok := iam3Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam3 expected to be basetypes.ListValue, was: %T`, iam3Attribute))
	}

	identityMappingsAttribute, ok := attributes["identity_mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity_mappings is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	identityMappingsVal, ok := identityMappingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity_mappings expected to be basetypes.ListValue, was: %T`, identityMappingsAttribute))
	}

	identityProvidersAttribute, ok := attributes["identity_providers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`identity_providers is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	identityProvidersVal, ok := identityProvidersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`identity_providers expected to be basetypes.ListValue, was: %T`, identityProvidersAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	kubernetesNetworkConfigAttribute, ok := attributes["kubernetes_network_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_network_config is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	kubernetesNetworkConfigVal, ok := kubernetesNetworkConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_network_config expected to be basetypes.ListValue, was: %T`, kubernetesNetworkConfigAttribute))
	}

	managedNodegroupsAttribute, ok := attributes["managed_nodegroups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_nodegroups is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	managedNodegroupsVal, ok := managedNodegroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_nodegroups expected to be basetypes.ListValue, was: %T`, managedNodegroupsAttribute))
	}

	managedNodegroupsMapAttribute, ok := attributes["managed_nodegroups_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_nodegroups_map is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	managedNodegroupsMapVal, ok := managedNodegroupsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_nodegroups_map expected to be basetypes.MapValue, was: %T`, managedNodegroupsMapAttribute))
	}

	metadata2Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata2 is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	metadata2Val, ok := metadata2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata2 expected to be basetypes.ListValue, was: %T`, metadata2Attribute))
	}

	nodeGroupsAttribute, ok := attributes["node_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	nodeGroupsVal, ok := nodeGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups expected to be basetypes.ListValue, was: %T`, nodeGroupsAttribute))
	}

	nodeGroupsMapAttribute, ok := attributes["node_groups_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups_map is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	nodeGroupsMapVal, ok := nodeGroupsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups_map expected to be basetypes.MapValue, was: %T`, nodeGroupsMapAttribute))
	}

	privateClusterAttribute, ok := attributes["private_cluster"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_cluster is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	privateClusterVal, ok := privateClusterAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_cluster expected to be basetypes.ListValue, was: %T`, privateClusterAttribute))
	}

	secretsEncryptionAttribute, ok := attributes["secrets_encryption"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secrets_encryption is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	secretsEncryptionVal, ok := secretsEncryptionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secrets_encryption expected to be basetypes.ListValue, was: %T`, secretsEncryptionAttribute))
	}

	vpcAttribute, ok := attributes["vpc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	vpcVal, ok := vpcAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc expected to be basetypes.ListValue, was: %T`, vpcAttribute))
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	return ClusterConfigValue{
		AccessConfig:            accessConfigVal,
		Addons:                  addonsVal,
		AddonsConfig:            addonsConfigVal,
		Apiversion:              apiversionVal,
		AutoModeConfig:          autoModeConfigVal,
		AvailabilityZones:       availabilityZonesVal,
		CloudWatch:              cloudWatchVal,
		FargateProfiles:         fargateProfilesVal,
		Iam3:                    iam3Val,
		IdentityMappings:        identityMappingsVal,
		IdentityProviders:       identityProvidersVal,
		Kind:                    kindVal,
		KubernetesNetworkConfig: kubernetesNetworkConfigVal,
		ManagedNodegroups:       managedNodegroupsVal,
		ManagedNodegroupsMap:    managedNodegroupsMapVal,
		Metadata2:               metadata2Val,
		NodeGroups:              nodeGroupsVal,
		NodeGroupsMap:           nodeGroupsMapVal,
		PrivateCluster:          privateClusterVal,
		SecretsEncryption:       secretsEncryptionVal,
		Vpc:                     vpcVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterConfigValue {
	object, diags := NewClusterConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterConfigValueMust(ClusterConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterConfigType) ValueType(ctx context.Context) attr.Value {
	return ClusterConfigValue{}
}

var _ basetypes.ObjectValuable = ClusterConfigValue{}

type ClusterConfigValue struct {
	AccessConfig            basetypes.ListValue   `tfsdk:"access_config"`
	Addons                  basetypes.SetValue    `tfsdk:"addons"`
	AddonsConfig            basetypes.ListValue   `tfsdk:"addons_config"`
	Apiversion              basetypes.StringValue `tfsdk:"apiversion"`
	AutoModeConfig          basetypes.ListValue   `tfsdk:"auto_mode_config"`
	AvailabilityZones       basetypes.ListValue   `tfsdk:"availability_zones"`
	CloudWatch              basetypes.ListValue   `tfsdk:"cloud_watch"`
	FargateProfiles         basetypes.ListValue   `tfsdk:"fargate_profiles"`
	Iam3                    basetypes.ListValue   `tfsdk:"iam"`
	IdentityMappings        basetypes.ListValue   `tfsdk:"identity_mappings"`
	IdentityProviders       basetypes.ListValue   `tfsdk:"identity_providers"`
	Kind                    basetypes.StringValue `tfsdk:"kind"`
	KubernetesNetworkConfig basetypes.ListValue   `tfsdk:"kubernetes_network_config"`
	ManagedNodegroups       basetypes.ListValue   `tfsdk:"managed_nodegroups"`
	ManagedNodegroupsMap    basetypes.MapValue    `tfsdk:"managed_nodegroups_map"`
	Metadata2               basetypes.ListValue   `tfsdk:"metadata"`
	NodeGroups              basetypes.ListValue   `tfsdk:"node_groups"`
	NodeGroupsMap           basetypes.MapValue    `tfsdk:"node_groups_map"`
	PrivateCluster          basetypes.ListValue   `tfsdk:"private_cluster"`
	SecretsEncryption       basetypes.ListValue   `tfsdk:"secrets_encryption"`
	Vpc                     basetypes.ListValue   `tfsdk:"vpc"`
	state                   attr.ValueState
}

func (v ClusterConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 21)

	var val tftypes.Value
	var err error

	attrTypes["access_config"] = basetypes.ListType{
		ElemType: AccessConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["addons"] = basetypes.SetType{
		ElemType: AddonsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["addons_config"] = basetypes.ListType{
		ElemType: AddonsConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["apiversion"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auto_mode_config"] = basetypes.ListType{
		ElemType: AutoModeConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["availability_zones"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.ListType{
		ElemType: CloudWatchValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["fargate_profiles"] = basetypes.ListType{
		ElemType: FargateProfilesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ListType{
		ElemType: Iam3Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["identity_mappings"] = basetypes.ListType{
		ElemType: IdentityMappingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["identity_providers"] = basetypes.ListType{
		ElemType: IdentityProvidersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kubernetes_network_config"] = basetypes.ListType{
		ElemType: KubernetesNetworkConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["managed_nodegroups"] = basetypes.ListType{
		ElemType: ManagedNodegroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["managed_nodegroups_map"] = basetypes.MapType{
		ElemType: ManagedNodegroupsMapValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: Metadata2Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_groups"] = basetypes.ListType{
		ElemType: NodeGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_groups_map"] = basetypes.MapType{
		ElemType: NodeGroupsMapValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["private_cluster"] = basetypes.ListType{
		ElemType: PrivateClusterValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["secrets_encryption"] = basetypes.ListType{
		ElemType: SecretsEncryptionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vpc"] = basetypes.ListType{
		ElemType: VpcValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 21)

		val, err = v.AccessConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_config"] = val

		val, err = v.Addons.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["addons"] = val

		val, err = v.AddonsConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["addons_config"] = val

		val, err = v.Apiversion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apiversion"] = val

		val, err = v.AutoModeConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_mode_config"] = val

		val, err = v.AvailabilityZones.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["availability_zones"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.FargateProfiles.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fargate_profiles"] = val

		val, err = v.Iam3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.IdentityMappings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identity_mappings"] = val

		val, err = v.IdentityProviders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["identity_providers"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.KubernetesNetworkConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubernetes_network_config"] = val

		val, err = v.ManagedNodegroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_nodegroups"] = val

		val, err = v.ManagedNodegroupsMap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_nodegroups_map"] = val

		val, err = v.Metadata2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.NodeGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_groups"] = val

		val, err = v.NodeGroupsMap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_groups_map"] = val

		val, err = v.PrivateCluster.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_cluster"] = val

		val, err = v.SecretsEncryption.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secrets_encryption"] = val

		val, err = v.Vpc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpc"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterConfigValue) String() string {
	return "ClusterConfigValue"
}

func (v ClusterConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	accessConfig := types.ListValueMust(
		AccessConfigType{
			basetypes.ObjectType{
				AttrTypes: AccessConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.AccessConfig.Elements(),
	)

	if v.AccessConfig.IsNull() {
		accessConfig = types.ListNull(
			AccessConfigType{
				basetypes.ObjectType{
					AttrTypes: AccessConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AccessConfig.IsUnknown() {
		accessConfig = types.ListUnknown(
			AccessConfigType{
				basetypes.ObjectType{
					AttrTypes: AccessConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	addons := types.SetValueMust(
		AddonsType{
			basetypes.ObjectType{
				AttrTypes: AddonsValue{}.AttributeTypes(ctx),
			},
		},
		v.Addons.Elements(),
	)

	if v.Addons.IsNull() {
		addons = types.SetNull(
			AddonsType{
				basetypes.ObjectType{
					AttrTypes: AddonsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Addons.IsUnknown() {
		addons = types.SetUnknown(
			AddonsType{
				basetypes.ObjectType{
					AttrTypes: AddonsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	addonsConfig := types.ListValueMust(
		AddonsConfigType{
			basetypes.ObjectType{
				AttrTypes: AddonsConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.AddonsConfig.Elements(),
	)

	if v.AddonsConfig.IsNull() {
		addonsConfig = types.ListNull(
			AddonsConfigType{
				basetypes.ObjectType{
					AttrTypes: AddonsConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AddonsConfig.IsUnknown() {
		addonsConfig = types.ListUnknown(
			AddonsConfigType{
				basetypes.ObjectType{
					AttrTypes: AddonsConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	autoModeConfig := types.ListValueMust(
		AutoModeConfigType{
			basetypes.ObjectType{
				AttrTypes: AutoModeConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.AutoModeConfig.Elements(),
	)

	if v.AutoModeConfig.IsNull() {
		autoModeConfig = types.ListNull(
			AutoModeConfigType{
				basetypes.ObjectType{
					AttrTypes: AutoModeConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AutoModeConfig.IsUnknown() {
		autoModeConfig = types.ListUnknown(
			AutoModeConfigType{
				basetypes.ObjectType{
					AttrTypes: AutoModeConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	cloudWatch := types.ListValueMust(
		CloudWatchType{
			basetypes.ObjectType{
				AttrTypes: CloudWatchValue{}.AttributeTypes(ctx),
			},
		},
		v.CloudWatch.Elements(),
	)

	if v.CloudWatch.IsNull() {
		cloudWatch = types.ListNull(
			CloudWatchType{
				basetypes.ObjectType{
					AttrTypes: CloudWatchValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CloudWatch.IsUnknown() {
		cloudWatch = types.ListUnknown(
			CloudWatchType{
				basetypes.ObjectType{
					AttrTypes: CloudWatchValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	fargateProfiles := types.ListValueMust(
		FargateProfilesType{
			basetypes.ObjectType{
				AttrTypes: FargateProfilesValue{}.AttributeTypes(ctx),
			},
		},
		v.FargateProfiles.Elements(),
	)

	if v.FargateProfiles.IsNull() {
		fargateProfiles = types.ListNull(
			FargateProfilesType{
				basetypes.ObjectType{
					AttrTypes: FargateProfilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FargateProfiles.IsUnknown() {
		fargateProfiles = types.ListUnknown(
			FargateProfilesType{
				basetypes.ObjectType{
					AttrTypes: FargateProfilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	iam3 := types.ListValueMust(
		Iam3Type{
			basetypes.ObjectType{
				AttrTypes: Iam3Value{}.AttributeTypes(ctx),
			},
		},
		v.Iam3.Elements(),
	)

	if v.Iam3.IsNull() {
		iam3 = types.ListNull(
			Iam3Type{
				basetypes.ObjectType{
					AttrTypes: Iam3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Iam3.IsUnknown() {
		iam3 = types.ListUnknown(
			Iam3Type{
				basetypes.ObjectType{
					AttrTypes: Iam3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	identityMappings := types.ListValueMust(
		IdentityMappingsType{
			basetypes.ObjectType{
				AttrTypes: IdentityMappingsValue{}.AttributeTypes(ctx),
			},
		},
		v.IdentityMappings.Elements(),
	)

	if v.IdentityMappings.IsNull() {
		identityMappings = types.ListNull(
			IdentityMappingsType{
				basetypes.ObjectType{
					AttrTypes: IdentityMappingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IdentityMappings.IsUnknown() {
		identityMappings = types.ListUnknown(
			IdentityMappingsType{
				basetypes.ObjectType{
					AttrTypes: IdentityMappingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	identityProviders := types.ListValueMust(
		IdentityProvidersType{
			basetypes.ObjectType{
				AttrTypes: IdentityProvidersValue{}.AttributeTypes(ctx),
			},
		},
		v.IdentityProviders.Elements(),
	)

	if v.IdentityProviders.IsNull() {
		identityProviders = types.ListNull(
			IdentityProvidersType{
				basetypes.ObjectType{
					AttrTypes: IdentityProvidersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IdentityProviders.IsUnknown() {
		identityProviders = types.ListUnknown(
			IdentityProvidersType{
				basetypes.ObjectType{
					AttrTypes: IdentityProvidersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	kubernetesNetworkConfig := types.ListValueMust(
		KubernetesNetworkConfigType{
			basetypes.ObjectType{
				AttrTypes: KubernetesNetworkConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.KubernetesNetworkConfig.Elements(),
	)

	if v.KubernetesNetworkConfig.IsNull() {
		kubernetesNetworkConfig = types.ListNull(
			KubernetesNetworkConfigType{
				basetypes.ObjectType{
					AttrTypes: KubernetesNetworkConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.KubernetesNetworkConfig.IsUnknown() {
		kubernetesNetworkConfig = types.ListUnknown(
			KubernetesNetworkConfigType{
				basetypes.ObjectType{
					AttrTypes: KubernetesNetworkConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	managedNodegroups := types.ListValueMust(
		ManagedNodegroupsType{
			basetypes.ObjectType{
				AttrTypes: ManagedNodegroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.ManagedNodegroups.Elements(),
	)

	if v.ManagedNodegroups.IsNull() {
		managedNodegroups = types.ListNull(
			ManagedNodegroupsType{
				basetypes.ObjectType{
					AttrTypes: ManagedNodegroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ManagedNodegroups.IsUnknown() {
		managedNodegroups = types.ListUnknown(
			ManagedNodegroupsType{
				basetypes.ObjectType{
					AttrTypes: ManagedNodegroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	managedNodegroupsMap := types.MapValueMust(
		ManagedNodegroupsMapType{
			basetypes.ObjectType{
				AttrTypes: ManagedNodegroupsMapValue{}.AttributeTypes(ctx),
			},
		},
		v.ManagedNodegroupsMap.Elements(),
	)

	if v.ManagedNodegroupsMap.IsNull() {
		managedNodegroupsMap = types.MapNull(
			ManagedNodegroupsMapType{
				basetypes.ObjectType{
					AttrTypes: ManagedNodegroupsMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ManagedNodegroupsMap.IsUnknown() {
		managedNodegroupsMap = types.MapUnknown(
			ManagedNodegroupsMapType{
				basetypes.ObjectType{
					AttrTypes: ManagedNodegroupsMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	metadata2 := types.ListValueMust(
		Metadata2Type{
			basetypes.ObjectType{
				AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
			},
		},
		v.Metadata2.Elements(),
	)

	if v.Metadata2.IsNull() {
		metadata2 = types.ListNull(
			Metadata2Type{
				basetypes.ObjectType{
					AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata2.IsUnknown() {
		metadata2 = types.ListUnknown(
			Metadata2Type{
				basetypes.ObjectType{
					AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeGroups := types.ListValueMust(
		NodeGroupsType{
			basetypes.ObjectType{
				AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeGroups.Elements(),
	)

	if v.NodeGroups.IsNull() {
		nodeGroups = types.ListNull(
			NodeGroupsType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeGroups.IsUnknown() {
		nodeGroups = types.ListUnknown(
			NodeGroupsType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeGroupsMap := types.MapValueMust(
		NodeGroupsMapType{
			basetypes.ObjectType{
				AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeGroupsMap.Elements(),
	)

	if v.NodeGroupsMap.IsNull() {
		nodeGroupsMap = types.MapNull(
			NodeGroupsMapType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeGroupsMap.IsUnknown() {
		nodeGroupsMap = types.MapUnknown(
			NodeGroupsMapType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	privateCluster := types.ListValueMust(
		PrivateClusterType{
			basetypes.ObjectType{
				AttrTypes: PrivateClusterValue{}.AttributeTypes(ctx),
			},
		},
		v.PrivateCluster.Elements(),
	)

	if v.PrivateCluster.IsNull() {
		privateCluster = types.ListNull(
			PrivateClusterType{
				basetypes.ObjectType{
					AttrTypes: PrivateClusterValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PrivateCluster.IsUnknown() {
		privateCluster = types.ListUnknown(
			PrivateClusterType{
				basetypes.ObjectType{
					AttrTypes: PrivateClusterValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	secretsEncryption := types.ListValueMust(
		SecretsEncryptionType{
			basetypes.ObjectType{
				AttrTypes: SecretsEncryptionValue{}.AttributeTypes(ctx),
			},
		},
		v.SecretsEncryption.Elements(),
	)

	if v.SecretsEncryption.IsNull() {
		secretsEncryption = types.ListNull(
			SecretsEncryptionType{
				basetypes.ObjectType{
					AttrTypes: SecretsEncryptionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecretsEncryption.IsUnknown() {
		secretsEncryption = types.ListUnknown(
			SecretsEncryptionType{
				basetypes.ObjectType{
					AttrTypes: SecretsEncryptionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vpc := types.ListValueMust(
		VpcType{
			basetypes.ObjectType{
				AttrTypes: VpcValue{}.AttributeTypes(ctx),
			},
		},
		v.Vpc.Elements(),
	)

	if v.Vpc.IsNull() {
		vpc = types.ListNull(
			VpcType{
				basetypes.ObjectType{
					AttrTypes: VpcValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Vpc.IsUnknown() {
		vpc = types.ListUnknown(
			VpcType{
				basetypes.ObjectType{
					AttrTypes: VpcValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var availabilityZonesVal basetypes.ListValue
	switch {
	case v.AvailabilityZones.IsUnknown():
		availabilityZonesVal = types.ListUnknown(types.StringType)
	case v.AvailabilityZones.IsNull():
		availabilityZonesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		availabilityZonesVal, d = types.ListValue(types.StringType, v.AvailabilityZones.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"access_config": basetypes.ListType{
				ElemType: AccessConfigValue{}.Type(ctx),
			},
			"addons": basetypes.SetType{
				ElemType: AddonsValue{}.Type(ctx),
			},
			"addons_config": basetypes.ListType{
				ElemType: AddonsConfigValue{}.Type(ctx),
			},
			"apiversion": basetypes.StringType{},
			"auto_mode_config": basetypes.ListType{
				ElemType: AutoModeConfigValue{}.Type(ctx),
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cloud_watch": basetypes.ListType{
				ElemType: CloudWatchValue{}.Type(ctx),
			},
			"fargate_profiles": basetypes.ListType{
				ElemType: FargateProfilesValue{}.Type(ctx),
			},
			"iam": basetypes.ListType{
				ElemType: Iam3Value{}.Type(ctx),
			},
			"identity_mappings": basetypes.ListType{
				ElemType: IdentityMappingsValue{}.Type(ctx),
			},
			"identity_providers": basetypes.ListType{
				ElemType: IdentityProvidersValue{}.Type(ctx),
			},
			"kind": basetypes.StringType{},
			"kubernetes_network_config": basetypes.ListType{
				ElemType: KubernetesNetworkConfigValue{}.Type(ctx),
			},
			"managed_nodegroups": basetypes.ListType{
				ElemType: ManagedNodegroupsValue{}.Type(ctx),
			},
			"managed_nodegroups_map": basetypes.MapType{
				ElemType: ManagedNodegroupsMapValue{}.Type(ctx),
			},
			"metadata": basetypes.ListType{
				ElemType: Metadata2Value{}.Type(ctx),
			},
			"node_groups": basetypes.ListType{
				ElemType: NodeGroupsValue{}.Type(ctx),
			},
			"node_groups_map": basetypes.MapType{
				ElemType: NodeGroupsMapValue{}.Type(ctx),
			},
			"private_cluster": basetypes.ListType{
				ElemType: PrivateClusterValue{}.Type(ctx),
			},
			"secrets_encryption": basetypes.ListType{
				ElemType: SecretsEncryptionValue{}.Type(ctx),
			},
			"vpc": basetypes.ListType{
				ElemType: VpcValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"access_config": basetypes.ListType{
			ElemType: AccessConfigValue{}.Type(ctx),
		},
		"addons": basetypes.SetType{
			ElemType: AddonsValue{}.Type(ctx),
		},
		"addons_config": basetypes.ListType{
			ElemType: AddonsConfigValue{}.Type(ctx),
		},
		"apiversion": basetypes.StringType{},
		"auto_mode_config": basetypes.ListType{
			ElemType: AutoModeConfigValue{}.Type(ctx),
		},
		"availability_zones": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cloud_watch": basetypes.ListType{
			ElemType: CloudWatchValue{}.Type(ctx),
		},
		"fargate_profiles": basetypes.ListType{
			ElemType: FargateProfilesValue{}.Type(ctx),
		},
		"iam": basetypes.ListType{
			ElemType: Iam3Value{}.Type(ctx),
		},
		"identity_mappings": basetypes.ListType{
			ElemType: IdentityMappingsValue{}.Type(ctx),
		},
		"identity_providers": basetypes.ListType{
			ElemType: IdentityProvidersValue{}.Type(ctx),
		},
		"kind": basetypes.StringType{},
		"kubernetes_network_config": basetypes.ListType{
			ElemType: KubernetesNetworkConfigValue{}.Type(ctx),
		},
		"managed_nodegroups": basetypes.ListType{
			ElemType: ManagedNodegroupsValue{}.Type(ctx),
		},
		"managed_nodegroups_map": basetypes.MapType{
			ElemType: ManagedNodegroupsMapValue{}.Type(ctx),
		},
		"metadata": basetypes.ListType{
			ElemType: Metadata2Value{}.Type(ctx),
		},
		"node_groups": basetypes.ListType{
			ElemType: NodeGroupsValue{}.Type(ctx),
		},
		"node_groups_map": basetypes.MapType{
			ElemType: NodeGroupsMapValue{}.Type(ctx),
		},
		"private_cluster": basetypes.ListType{
			ElemType: PrivateClusterValue{}.Type(ctx),
		},
		"secrets_encryption": basetypes.ListType{
			ElemType: SecretsEncryptionValue{}.Type(ctx),
		},
		"vpc": basetypes.ListType{
			ElemType: VpcValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_config":             accessConfig,
			"addons":                    addons,
			"addons_config":             addonsConfig,
			"apiversion":                v.Apiversion,
			"auto_mode_config":          autoModeConfig,
			"availability_zones":        availabilityZonesVal,
			"cloud_watch":               cloudWatch,
			"fargate_profiles":          fargateProfiles,
			"iam":                       iam3,
			"identity_mappings":         identityMappings,
			"identity_providers":        identityProviders,
			"kind":                      v.Kind,
			"kubernetes_network_config": kubernetesNetworkConfig,
			"managed_nodegroups":        managedNodegroups,
			"managed_nodegroups_map":    managedNodegroupsMap,
			"metadata":                  metadata2,
			"node_groups":               nodeGroups,
			"node_groups_map":           nodeGroupsMap,
			"private_cluster":           privateCluster,
			"secrets_encryption":        secretsEncryption,
			"vpc":                       vpc,
		})

	return objVal, diags
}

func (v ClusterConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessConfig.Equal(other.AccessConfig) {
		return false
	}

	if !v.Addons.Equal(other.Addons) {
		return false
	}

	if !v.AddonsConfig.Equal(other.AddonsConfig) {
		return false
	}

	if !v.Apiversion.Equal(other.Apiversion) {
		return false
	}

	if !v.AutoModeConfig.Equal(other.AutoModeConfig) {
		return false
	}

	if !v.AvailabilityZones.Equal(other.AvailabilityZones) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.FargateProfiles.Equal(other.FargateProfiles) {
		return false
	}

	if !v.Iam3.Equal(other.Iam3) {
		return false
	}

	if !v.IdentityMappings.Equal(other.IdentityMappings) {
		return false
	}

	if !v.IdentityProviders.Equal(other.IdentityProviders) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.KubernetesNetworkConfig.Equal(other.KubernetesNetworkConfig) {
		return false
	}

	if !v.ManagedNodegroups.Equal(other.ManagedNodegroups) {
		return false
	}

	if !v.ManagedNodegroupsMap.Equal(other.ManagedNodegroupsMap) {
		return false
	}

	if !v.Metadata2.Equal(other.Metadata2) {
		return false
	}

	if !v.NodeGroups.Equal(other.NodeGroups) {
		return false
	}

	if !v.NodeGroupsMap.Equal(other.NodeGroupsMap) {
		return false
	}

	if !v.PrivateCluster.Equal(other.PrivateCluster) {
		return false
	}

	if !v.SecretsEncryption.Equal(other.SecretsEncryption) {
		return false
	}

	if !v.Vpc.Equal(other.Vpc) {
		return false
	}

	return true
}

func (v ClusterConfigValue) Type(ctx context.Context) attr.Type {
	return ClusterConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_config": basetypes.ListType{
			ElemType: AccessConfigValue{}.Type(ctx),
		},
		"addons": basetypes.SetType{
			ElemType: AddonsValue{}.Type(ctx),
		},
		"addons_config": basetypes.ListType{
			ElemType: AddonsConfigValue{}.Type(ctx),
		},
		"apiversion": basetypes.StringType{},
		"auto_mode_config": basetypes.ListType{
			ElemType: AutoModeConfigValue{}.Type(ctx),
		},
		"availability_zones": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cloud_watch": basetypes.ListType{
			ElemType: CloudWatchValue{}.Type(ctx),
		},
		"fargate_profiles": basetypes.ListType{
			ElemType: FargateProfilesValue{}.Type(ctx),
		},
		"iam": basetypes.ListType{
			ElemType: Iam3Value{}.Type(ctx),
		},
		"identity_mappings": basetypes.ListType{
			ElemType: IdentityMappingsValue{}.Type(ctx),
		},
		"identity_providers": basetypes.ListType{
			ElemType: IdentityProvidersValue{}.Type(ctx),
		},
		"kind": basetypes.StringType{},
		"kubernetes_network_config": basetypes.ListType{
			ElemType: KubernetesNetworkConfigValue{}.Type(ctx),
		},
		"managed_nodegroups": basetypes.ListType{
			ElemType: ManagedNodegroupsValue{}.Type(ctx),
		},
		"managed_nodegroups_map": basetypes.MapType{
			ElemType: ManagedNodegroupsMapValue{}.Type(ctx),
		},
		"metadata": basetypes.ListType{
			ElemType: Metadata2Value{}.Type(ctx),
		},
		"node_groups": basetypes.ListType{
			ElemType: NodeGroupsValue{}.Type(ctx),
		},
		"node_groups_map": basetypes.MapType{
			ElemType: NodeGroupsMapValue{}.Type(ctx),
		},
		"private_cluster": basetypes.ListType{
			ElemType: PrivateClusterValue{}.Type(ctx),
		},
		"secrets_encryption": basetypes.ListType{
			ElemType: SecretsEncryptionValue{}.Type(ctx),
		},
		"vpc": basetypes.ListType{
			ElemType: VpcValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ManagedNodegroupsMapType{}

type ManagedNodegroupsMapType struct {
	basetypes.ObjectType
}

func (t ManagedNodegroupsMapType) Equal(o attr.Type) bool {
	other, ok := o.(ManagedNodegroupsMapType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ManagedNodegroupsMapType) String() string {
	return "ManagedNodegroupsMapType"
}

func (t ManagedNodegroupsMapType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return nil, diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return nil, diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	asgSuspendProcessesAttribute, ok := attributes["asg_suspend_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_suspend_processes is missing from object`)

		return nil, diags
	}

	asgSuspendProcessesVal, ok := asgSuspendProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_suspend_processes expected to be basetypes.ListValue, was: %T`, asgSuspendProcessesAttribute))
	}

	availabilityZonesAttribute, ok := attributes["availability_zones"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones is missing from object`)

		return nil, diags
	}

	availabilityZonesVal, ok := availabilityZonesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones expected to be basetypes.ListValue, was: %T`, availabilityZonesAttribute))
	}

	bottleRocket5Attribute, ok := attributes["bottle_rocket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bottle_rocket5 is missing from object`)

		return nil, diags
	}

	bottleRocket5Val, ok := bottleRocket5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bottle_rocket5 expected to be basetypes.ObjectValue, was: %T`, bottleRocket5Attribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return nil, diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return nil, diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return nil, diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	ebsOptimizedAttribute, ok := attributes["ebs_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_optimized is missing from object`)

		return nil, diags
	}

	ebsOptimizedVal, ok := ebsOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_optimized expected to be basetypes.BoolValue, was: %T`, ebsOptimizedAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return nil, diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	enableDetailedMonitoringAttribute, ok := attributes["enable_detailed_monitoring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_detailed_monitoring is missing from object`)

		return nil, diags
	}

	enableDetailedMonitoringVal, ok := enableDetailedMonitoringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_detailed_monitoring expected to be basetypes.BoolValue, was: %T`, enableDetailedMonitoringAttribute))
	}

	iam5Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam5 is missing from object`)

		return nil, diags
	}

	iam5Val, ok := iam5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam5 expected to be basetypes.ObjectValue, was: %T`, iam5Attribute))
	}

	instanceNameAttribute, ok := attributes["instance_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_name is missing from object`)

		return nil, diags
	}

	instanceNameVal, ok := instanceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_name expected to be basetypes.StringValue, was: %T`, instanceNameAttribute))
	}

	instancePrefixAttribute, ok := attributes["instance_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_prefix is missing from object`)

		return nil, diags
	}

	instancePrefixVal, ok := instancePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_prefix expected to be basetypes.StringValue, was: %T`, instancePrefixAttribute))
	}

	instanceSelector5Attribute, ok := attributes["instance_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_selector5 is missing from object`)

		return nil, diags
	}

	instanceSelector5Val, ok := instanceSelector5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_selector5 expected to be basetypes.ObjectValue, was: %T`, instanceSelector5Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return nil, diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	instanceTypesAttribute, ok := attributes["instance_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_types is missing from object`)

		return nil, diags
	}

	instanceTypesVal, ok := instanceTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_types expected to be basetypes.ListValue, was: %T`, instanceTypesAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	launchTemplate5Attribute, ok := attributes["launch_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`launch_template5 is missing from object`)

		return nil, diags
	}

	launchTemplate5Val, ok := launchTemplate5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`launch_template5 expected to be basetypes.ObjectValue, was: %T`, launchTemplate5Attribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return nil, diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nodeRepairConfig5Attribute, ok := attributes["node_repair_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_repair_config5 is missing from object`)

		return nil, diags
	}

	nodeRepairConfig5Val, ok := nodeRepairConfig5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_repair_config5 expected to be basetypes.ObjectValue, was: %T`, nodeRepairConfig5Attribute))
	}

	overrideBootstrapCommandAttribute, ok := attributes["override_bootstrap_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_bootstrap_command is missing from object`)

		return nil, diags
	}

	overrideBootstrapCommandVal, ok := overrideBootstrapCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_bootstrap_command expected to be basetypes.StringValue, was: %T`, overrideBootstrapCommandAttribute))
	}

	placement5Attribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement5 is missing from object`)

		return nil, diags
	}

	placement5Val, ok := placement5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement5 expected to be basetypes.ObjectValue, was: %T`, placement5Attribute))
	}

	preBootstrapCommandsAttribute, ok := attributes["pre_bootstrap_commands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_bootstrap_commands is missing from object`)

		return nil, diags
	}

	preBootstrapCommandsVal, ok := preBootstrapCommandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_bootstrap_commands expected to be basetypes.ListValue, was: %T`, preBootstrapCommandsAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return nil, diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	securityGroups5Attribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups5 is missing from object`)

		return nil, diags
	}

	securityGroups5Val, ok := securityGroups5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups5 expected to be basetypes.ObjectValue, was: %T`, securityGroups5Attribute))
	}

	spotAttribute, ok := attributes["spot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot is missing from object`)

		return nil, diags
	}

	spotVal, ok := spotAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot expected to be basetypes.BoolValue, was: %T`, spotAttribute))
	}

	ssh5Attribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh5 is missing from object`)

		return nil, diags
	}

	ssh5Val, ok := ssh5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh5 expected to be basetypes.ObjectValue, was: %T`, ssh5Attribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.SetValue, was: %T`, subnetsAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	taints5Attribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints5 is missing from object`)

		return nil, diags
	}

	taints5Val, ok := taints5Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints5 expected to be basetypes.SetValue, was: %T`, taints5Attribute))
	}

	updateConfig5Attribute, ok := attributes["update_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update_config5 is missing from object`)

		return nil, diags
	}

	updateConfig5Val, ok := updateConfig5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update_config5 expected to be basetypes.ObjectValue, was: %T`, updateConfig5Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return nil, diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return nil, diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeKmsKeyIdAttribute, ok := attributes["volume_kms_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_kms_key_id is missing from object`)

		return nil, diags
	}

	volumeKmsKeyIdVal, ok := volumeKmsKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_kms_key_id expected to be basetypes.StringValue, was: %T`, volumeKmsKeyIdAttribute))
	}

	volumeNameAttribute, ok := attributes["volume_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_name is missing from object`)

		return nil, diags
	}

	volumeNameVal, ok := volumeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_name expected to be basetypes.StringValue, was: %T`, volumeNameAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return nil, diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ManagedNodegroupsMapValue{
		Ami:                      amiVal,
		AmiFamily:                amiFamilyVal,
		AsgSuspendProcesses:      asgSuspendProcessesVal,
		AvailabilityZones:        availabilityZonesVal,
		BottleRocket5:            bottleRocket5Val,
		DesiredCapacity:          desiredCapacityVal,
		DisableImdsv1:            disableImdsv1Val,
		DisablePodsImds:          disablePodsImdsVal,
		EbsOptimized:             ebsOptimizedVal,
		EfaEnabled:               efaEnabledVal,
		EnableDetailedMonitoring: enableDetailedMonitoringVal,
		Iam5:                     iam5Val,
		InstanceName:             instanceNameVal,
		InstancePrefix:           instancePrefixVal,
		InstanceSelector5:        instanceSelector5Val,
		InstanceType:             instanceTypeVal,
		InstanceTypes:            instanceTypesVal,
		Labels:                   labelsVal,
		LaunchTemplate5:          launchTemplate5Val,
		MaxPodsPerNode:           maxPodsPerNodeVal,
		MaxSize:                  maxSizeVal,
		MinSize:                  minSizeVal,
		NodeRepairConfig5:        nodeRepairConfig5Val,
		OverrideBootstrapCommand: overrideBootstrapCommandVal,
		Placement5:               placement5Val,
		PreBootstrapCommands:     preBootstrapCommandsVal,
		PrivateNetworking:        privateNetworkingVal,
		SecurityGroups5:          securityGroups5Val,
		Spot:                     spotVal,
		Ssh5:                     ssh5Val,
		Subnets:                  subnetsVal,
		Tags:                     tagsVal,
		Taints5:                  taints5Val,
		UpdateConfig5:            updateConfig5Val,
		Version:                  versionVal,
		VolumeEncrypted:          volumeEncryptedVal,
		VolumeIops:               volumeIopsVal,
		VolumeKmsKeyId:           volumeKmsKeyIdVal,
		VolumeName:               volumeNameVal,
		VolumeSize:               volumeSizeVal,
		VolumeThroughput:         volumeThroughputVal,
		VolumeType:               volumeTypeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewManagedNodegroupsMapValueNull() ManagedNodegroupsMapValue {
	return ManagedNodegroupsMapValue{
		state: attr.ValueStateNull,
	}
}

func NewManagedNodegroupsMapValueUnknown() ManagedNodegroupsMapValue {
	return ManagedNodegroupsMapValue{
		state: attr.ValueStateUnknown,
	}
}

func NewManagedNodegroupsMapValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ManagedNodegroupsMapValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ManagedNodegroupsMapValue Attribute Value",
				"While creating a ManagedNodegroupsMapValue value, a missing attribute value was detected. "+
					"A ManagedNodegroupsMapValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ManagedNodegroupsMapValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ManagedNodegroupsMapValue Attribute Type",
				"While creating a ManagedNodegroupsMapValue value, an invalid attribute value was detected. "+
					"A ManagedNodegroupsMapValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ManagedNodegroupsMapValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ManagedNodegroupsMapValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ManagedNodegroupsMapValue Attribute Value",
				"While creating a ManagedNodegroupsMapValue value, an extra attribute value was detected. "+
					"A ManagedNodegroupsMapValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ManagedNodegroupsMapValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	asgSuspendProcessesAttribute, ok := attributes["asg_suspend_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_suspend_processes is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	asgSuspendProcessesVal, ok := asgSuspendProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_suspend_processes expected to be basetypes.ListValue, was: %T`, asgSuspendProcessesAttribute))
	}

	availabilityZonesAttribute, ok := attributes["availability_zones"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	availabilityZonesVal, ok := availabilityZonesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones expected to be basetypes.ListValue, was: %T`, availabilityZonesAttribute))
	}

	bottleRocket5Attribute, ok := attributes["bottle_rocket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bottle_rocket5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	bottleRocket5Val, ok := bottleRocket5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bottle_rocket5 expected to be basetypes.ObjectValue, was: %T`, bottleRocket5Attribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	ebsOptimizedAttribute, ok := attributes["ebs_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_optimized is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	ebsOptimizedVal, ok := ebsOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_optimized expected to be basetypes.BoolValue, was: %T`, ebsOptimizedAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	enableDetailedMonitoringAttribute, ok := attributes["enable_detailed_monitoring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_detailed_monitoring is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	enableDetailedMonitoringVal, ok := enableDetailedMonitoringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_detailed_monitoring expected to be basetypes.BoolValue, was: %T`, enableDetailedMonitoringAttribute))
	}

	iam5Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	iam5Val, ok := iam5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam5 expected to be basetypes.ObjectValue, was: %T`, iam5Attribute))
	}

	instanceNameAttribute, ok := attributes["instance_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_name is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	instanceNameVal, ok := instanceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_name expected to be basetypes.StringValue, was: %T`, instanceNameAttribute))
	}

	instancePrefixAttribute, ok := attributes["instance_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_prefix is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	instancePrefixVal, ok := instancePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_prefix expected to be basetypes.StringValue, was: %T`, instancePrefixAttribute))
	}

	instanceSelector5Attribute, ok := attributes["instance_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_selector5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	instanceSelector5Val, ok := instanceSelector5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_selector5 expected to be basetypes.ObjectValue, was: %T`, instanceSelector5Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	instanceTypesAttribute, ok := attributes["instance_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_types is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	instanceTypesVal, ok := instanceTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_types expected to be basetypes.ListValue, was: %T`, instanceTypesAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	launchTemplate5Attribute, ok := attributes["launch_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`launch_template5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	launchTemplate5Val, ok := launchTemplate5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`launch_template5 expected to be basetypes.ObjectValue, was: %T`, launchTemplate5Attribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nodeRepairConfig5Attribute, ok := attributes["node_repair_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_repair_config5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	nodeRepairConfig5Val, ok := nodeRepairConfig5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_repair_config5 expected to be basetypes.ObjectValue, was: %T`, nodeRepairConfig5Attribute))
	}

	overrideBootstrapCommandAttribute, ok := attributes["override_bootstrap_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_bootstrap_command is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	overrideBootstrapCommandVal, ok := overrideBootstrapCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_bootstrap_command expected to be basetypes.StringValue, was: %T`, overrideBootstrapCommandAttribute))
	}

	placement5Attribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	placement5Val, ok := placement5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement5 expected to be basetypes.ObjectValue, was: %T`, placement5Attribute))
	}

	preBootstrapCommandsAttribute, ok := attributes["pre_bootstrap_commands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_bootstrap_commands is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	preBootstrapCommandsVal, ok := preBootstrapCommandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_bootstrap_commands expected to be basetypes.ListValue, was: %T`, preBootstrapCommandsAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	securityGroups5Attribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	securityGroups5Val, ok := securityGroups5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups5 expected to be basetypes.ObjectValue, was: %T`, securityGroups5Attribute))
	}

	spotAttribute, ok := attributes["spot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	spotVal, ok := spotAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot expected to be basetypes.BoolValue, was: %T`, spotAttribute))
	}

	ssh5Attribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	ssh5Val, ok := ssh5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh5 expected to be basetypes.ObjectValue, was: %T`, ssh5Attribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.SetValue, was: %T`, subnetsAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	taints5Attribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	taints5Val, ok := taints5Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints5 expected to be basetypes.SetValue, was: %T`, taints5Attribute))
	}

	updateConfig5Attribute, ok := attributes["update_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update_config5 is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	updateConfig5Val, ok := updateConfig5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update_config5 expected to be basetypes.ObjectValue, was: %T`, updateConfig5Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeKmsKeyIdAttribute, ok := attributes["volume_kms_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_kms_key_id is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	volumeKmsKeyIdVal, ok := volumeKmsKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_kms_key_id expected to be basetypes.StringValue, was: %T`, volumeKmsKeyIdAttribute))
	}

	volumeNameAttribute, ok := attributes["volume_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_name is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	volumeNameVal, ok := volumeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_name expected to be basetypes.StringValue, was: %T`, volumeNameAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewManagedNodegroupsMapValueUnknown(), diags
	}

	return ManagedNodegroupsMapValue{
		Ami:                      amiVal,
		AmiFamily:                amiFamilyVal,
		AsgSuspendProcesses:      asgSuspendProcessesVal,
		AvailabilityZones:        availabilityZonesVal,
		BottleRocket5:            bottleRocket5Val,
		DesiredCapacity:          desiredCapacityVal,
		DisableImdsv1:            disableImdsv1Val,
		DisablePodsImds:          disablePodsImdsVal,
		EbsOptimized:             ebsOptimizedVal,
		EfaEnabled:               efaEnabledVal,
		EnableDetailedMonitoring: enableDetailedMonitoringVal,
		Iam5:                     iam5Val,
		InstanceName:             instanceNameVal,
		InstancePrefix:           instancePrefixVal,
		InstanceSelector5:        instanceSelector5Val,
		InstanceType:             instanceTypeVal,
		InstanceTypes:            instanceTypesVal,
		Labels:                   labelsVal,
		LaunchTemplate5:          launchTemplate5Val,
		MaxPodsPerNode:           maxPodsPerNodeVal,
		MaxSize:                  maxSizeVal,
		MinSize:                  minSizeVal,
		NodeRepairConfig5:        nodeRepairConfig5Val,
		OverrideBootstrapCommand: overrideBootstrapCommandVal,
		Placement5:               placement5Val,
		PreBootstrapCommands:     preBootstrapCommandsVal,
		PrivateNetworking:        privateNetworkingVal,
		SecurityGroups5:          securityGroups5Val,
		Spot:                     spotVal,
		Ssh5:                     ssh5Val,
		Subnets:                  subnetsVal,
		Tags:                     tagsVal,
		Taints5:                  taints5Val,
		UpdateConfig5:            updateConfig5Val,
		Version:                  versionVal,
		VolumeEncrypted:          volumeEncryptedVal,
		VolumeIops:               volumeIopsVal,
		VolumeKmsKeyId:           volumeKmsKeyIdVal,
		VolumeName:               volumeNameVal,
		VolumeSize:               volumeSizeVal,
		VolumeThroughput:         volumeThroughputVal,
		VolumeType:               volumeTypeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewManagedNodegroupsMapValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ManagedNodegroupsMapValue {
	object, diags := NewManagedNodegroupsMapValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewManagedNodegroupsMapValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ManagedNodegroupsMapType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewManagedNodegroupsMapValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewManagedNodegroupsMapValueUnknown(), nil
	}

	if in.IsNull() {
		return NewManagedNodegroupsMapValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewManagedNodegroupsMapValueMust(ManagedNodegroupsMapValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ManagedNodegroupsMapType) ValueType(ctx context.Context) attr.Value {
	return ManagedNodegroupsMapValue{}
}

var _ basetypes.ObjectValuable = ManagedNodegroupsMapValue{}

type ManagedNodegroupsMapValue struct {
	Ami                      basetypes.StringValue `tfsdk:"ami"`
	AmiFamily                basetypes.StringValue `tfsdk:"ami_family"`
	AsgSuspendProcesses      basetypes.ListValue   `tfsdk:"asg_suspend_processes"`
	AvailabilityZones        basetypes.ListValue   `tfsdk:"availability_zones"`
	BottleRocket5            basetypes.ObjectValue `tfsdk:"bottle_rocket"`
	DesiredCapacity          basetypes.Int64Value  `tfsdk:"desired_capacity"`
	DisableImdsv1            basetypes.BoolValue   `tfsdk:"disable_imdsv1"`
	DisablePodsImds          basetypes.BoolValue   `tfsdk:"disable_pods_imds"`
	EbsOptimized             basetypes.BoolValue   `tfsdk:"ebs_optimized"`
	EfaEnabled               basetypes.BoolValue   `tfsdk:"efa_enabled"`
	EnableDetailedMonitoring basetypes.BoolValue   `tfsdk:"enable_detailed_monitoring"`
	Iam5                     basetypes.ObjectValue `tfsdk:"iam"`
	InstanceName             basetypes.StringValue `tfsdk:"instance_name"`
	InstancePrefix           basetypes.StringValue `tfsdk:"instance_prefix"`
	InstanceSelector5        basetypes.ObjectValue `tfsdk:"instance_selector"`
	InstanceType             basetypes.StringValue `tfsdk:"instance_type"`
	InstanceTypes            basetypes.ListValue   `tfsdk:"instance_types"`
	Labels                   basetypes.MapValue    `tfsdk:"labels"`
	LaunchTemplate5          basetypes.ObjectValue `tfsdk:"launch_template"`
	MaxPodsPerNode           basetypes.Int64Value  `tfsdk:"max_pods_per_node"`
	MaxSize                  basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize                  basetypes.Int64Value  `tfsdk:"min_size"`
	NodeRepairConfig5        basetypes.ObjectValue `tfsdk:"node_repair_config"`
	OverrideBootstrapCommand basetypes.StringValue `tfsdk:"override_bootstrap_command"`
	Placement5               basetypes.ObjectValue `tfsdk:"placement"`
	PreBootstrapCommands     basetypes.ListValue   `tfsdk:"pre_bootstrap_commands"`
	PrivateNetworking        basetypes.BoolValue   `tfsdk:"private_networking"`
	SecurityGroups5          basetypes.ObjectValue `tfsdk:"security_groups"`
	Spot                     basetypes.BoolValue   `tfsdk:"spot"`
	Ssh5                     basetypes.ObjectValue `tfsdk:"ssh"`
	Subnets                  basetypes.SetValue    `tfsdk:"subnets"`
	Tags                     basetypes.MapValue    `tfsdk:"tags"`
	Taints5                  basetypes.SetValue    `tfsdk:"taints"`
	UpdateConfig5            basetypes.ObjectValue `tfsdk:"update_config"`
	Version                  basetypes.StringValue `tfsdk:"version"`
	VolumeEncrypted          basetypes.BoolValue   `tfsdk:"volume_encrypted"`
	VolumeIops               basetypes.Int64Value  `tfsdk:"volume_iops"`
	VolumeKmsKeyId           basetypes.StringValue `tfsdk:"volume_kms_key_id"`
	VolumeName               basetypes.StringValue `tfsdk:"volume_name"`
	VolumeSize               basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeThroughput         basetypes.Int64Value  `tfsdk:"volume_throughput"`
	VolumeType               basetypes.StringValue `tfsdk:"volume_type"`
	state                    attr.ValueState
}

func (v ManagedNodegroupsMapValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 42)

	var val tftypes.Value
	var err error

	attrTypes["ami"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ami_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["asg_suspend_processes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["availability_zones"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["bottle_rocket"] = basetypes.ObjectType{
		AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["desired_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_imdsv1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_pods_imds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs_optimized"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_detailed_monitoring"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ObjectType{
		AttrTypes: Iam5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_selector"] = basetypes.ObjectType{
		AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_types"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["launch_template"] = basetypes.ObjectType{
		AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["max_pods_per_node"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["node_repair_config"] = basetypes.ObjectType{
		AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["override_bootstrap_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["placement"] = basetypes.ObjectType{
		AttrTypes: Placement5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["pre_bootstrap_commands"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["private_networking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ObjectType{
		AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spot"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ssh"] = basetypes.ObjectType{
		AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["taints"] = basetypes.SetType{
		ElemType: Taints5Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["update_config"] = basetypes.ObjectType{
		AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_encrypted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["volume_iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_kms_key_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_throughput"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 42)

		val, err = v.Ami.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami"] = val

		val, err = v.AmiFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami_family"] = val

		val, err = v.AsgSuspendProcesses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asg_suspend_processes"] = val

		val, err = v.AvailabilityZones.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["availability_zones"] = val

		val, err = v.BottleRocket5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bottle_rocket"] = val

		val, err = v.DesiredCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_capacity"] = val

		val, err = v.DisableImdsv1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_imdsv1"] = val

		val, err = v.DisablePodsImds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_pods_imds"] = val

		val, err = v.EbsOptimized.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs_optimized"] = val

		val, err = v.EfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efa_enabled"] = val

		val, err = v.EnableDetailedMonitoring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_detailed_monitoring"] = val

		val, err = v.Iam5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.InstanceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_name"] = val

		val, err = v.InstancePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_prefix"] = val

		val, err = v.InstanceSelector5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_selector"] = val

		val, err = v.InstanceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_type"] = val

		val, err = v.InstanceTypes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_types"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.LaunchTemplate5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["launch_template"] = val

		val, err = v.MaxPodsPerNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pods_per_node"] = val

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.NodeRepairConfig5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_repair_config"] = val

		val, err = v.OverrideBootstrapCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["override_bootstrap_command"] = val

		val, err = v.Placement5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["placement"] = val

		val, err = v.PreBootstrapCommands.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pre_bootstrap_commands"] = val

		val, err = v.PrivateNetworking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_networking"] = val

		val, err = v.SecurityGroups5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Spot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spot"] = val

		val, err = v.Ssh5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Taints5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taints"] = val

		val, err = v.UpdateConfig5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["update_config"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VolumeEncrypted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_encrypted"] = val

		val, err = v.VolumeIops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_iops"] = val

		val, err = v.VolumeKmsKeyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_kms_key_id"] = val

		val, err = v.VolumeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_name"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeThroughput.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_throughput"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ManagedNodegroupsMapValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ManagedNodegroupsMapValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ManagedNodegroupsMapValue) String() string {
	return "ManagedNodegroupsMapValue"
}

func (v ManagedNodegroupsMapValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bottleRocket5 basetypes.ObjectValue

	if v.BottleRocket5.IsNull() {
		bottleRocket5 = types.ObjectNull(
			BottleRocket5Value{}.AttributeTypes(ctx),
		)
	}

	if v.BottleRocket5.IsUnknown() {
		bottleRocket5 = types.ObjectUnknown(
			BottleRocket5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.BottleRocket5.IsNull() && !v.BottleRocket5.IsUnknown() {
		bottleRocket5 = types.ObjectValueMust(
			BottleRocket5Value{}.AttributeTypes(ctx),
			v.BottleRocket5.Attributes(),
		)
	}

	var iam5 basetypes.ObjectValue

	if v.Iam5.IsNull() {
		iam5 = types.ObjectNull(
			Iam5Value{}.AttributeTypes(ctx),
		)
	}

	if v.Iam5.IsUnknown() {
		iam5 = types.ObjectUnknown(
			Iam5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Iam5.IsNull() && !v.Iam5.IsUnknown() {
		iam5 = types.ObjectValueMust(
			Iam5Value{}.AttributeTypes(ctx),
			v.Iam5.Attributes(),
		)
	}

	var instanceSelector5 basetypes.ObjectValue

	if v.InstanceSelector5.IsNull() {
		instanceSelector5 = types.ObjectNull(
			InstanceSelector5Value{}.AttributeTypes(ctx),
		)
	}

	if v.InstanceSelector5.IsUnknown() {
		instanceSelector5 = types.ObjectUnknown(
			InstanceSelector5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.InstanceSelector5.IsNull() && !v.InstanceSelector5.IsUnknown() {
		instanceSelector5 = types.ObjectValueMust(
			InstanceSelector5Value{}.AttributeTypes(ctx),
			v.InstanceSelector5.Attributes(),
		)
	}

	var launchTemplate5 basetypes.ObjectValue

	if v.LaunchTemplate5.IsNull() {
		launchTemplate5 = types.ObjectNull(
			LaunchTemplate5Value{}.AttributeTypes(ctx),
		)
	}

	if v.LaunchTemplate5.IsUnknown() {
		launchTemplate5 = types.ObjectUnknown(
			LaunchTemplate5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.LaunchTemplate5.IsNull() && !v.LaunchTemplate5.IsUnknown() {
		launchTemplate5 = types.ObjectValueMust(
			LaunchTemplate5Value{}.AttributeTypes(ctx),
			v.LaunchTemplate5.Attributes(),
		)
	}

	var nodeRepairConfig5 basetypes.ObjectValue

	if v.NodeRepairConfig5.IsNull() {
		nodeRepairConfig5 = types.ObjectNull(
			NodeRepairConfig5Value{}.AttributeTypes(ctx),
		)
	}

	if v.NodeRepairConfig5.IsUnknown() {
		nodeRepairConfig5 = types.ObjectUnknown(
			NodeRepairConfig5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.NodeRepairConfig5.IsNull() && !v.NodeRepairConfig5.IsUnknown() {
		nodeRepairConfig5 = types.ObjectValueMust(
			NodeRepairConfig5Value{}.AttributeTypes(ctx),
			v.NodeRepairConfig5.Attributes(),
		)
	}

	var placement5 basetypes.ObjectValue

	if v.Placement5.IsNull() {
		placement5 = types.ObjectNull(
			Placement5Value{}.AttributeTypes(ctx),
		)
	}

	if v.Placement5.IsUnknown() {
		placement5 = types.ObjectUnknown(
			Placement5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Placement5.IsNull() && !v.Placement5.IsUnknown() {
		placement5 = types.ObjectValueMust(
			Placement5Value{}.AttributeTypes(ctx),
			v.Placement5.Attributes(),
		)
	}

	var securityGroups5 basetypes.ObjectValue

	if v.SecurityGroups5.IsNull() {
		securityGroups5 = types.ObjectNull(
			SecurityGroups5Value{}.AttributeTypes(ctx),
		)
	}

	if v.SecurityGroups5.IsUnknown() {
		securityGroups5 = types.ObjectUnknown(
			SecurityGroups5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.SecurityGroups5.IsNull() && !v.SecurityGroups5.IsUnknown() {
		securityGroups5 = types.ObjectValueMust(
			SecurityGroups5Value{}.AttributeTypes(ctx),
			v.SecurityGroups5.Attributes(),
		)
	}

	var ssh5 basetypes.ObjectValue

	if v.Ssh5.IsNull() {
		ssh5 = types.ObjectNull(
			Ssh5Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ssh5.IsUnknown() {
		ssh5 = types.ObjectUnknown(
			Ssh5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ssh5.IsNull() && !v.Ssh5.IsUnknown() {
		ssh5 = types.ObjectValueMust(
			Ssh5Value{}.AttributeTypes(ctx),
			v.Ssh5.Attributes(),
		)
	}

	taints5 := types.SetValueMust(
		Taints5Type{
			basetypes.ObjectType{
				AttrTypes: Taints5Value{}.AttributeTypes(ctx),
			},
		},
		v.Taints5.Elements(),
	)

	if v.Taints5.IsNull() {
		taints5 = types.SetNull(
			Taints5Type{
				basetypes.ObjectType{
					AttrTypes: Taints5Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taints5.IsUnknown() {
		taints5 = types.SetUnknown(
			Taints5Type{
				basetypes.ObjectType{
					AttrTypes: Taints5Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var updateConfig5 basetypes.ObjectValue

	if v.UpdateConfig5.IsNull() {
		updateConfig5 = types.ObjectNull(
			UpdateConfig5Value{}.AttributeTypes(ctx),
		)
	}

	if v.UpdateConfig5.IsUnknown() {
		updateConfig5 = types.ObjectUnknown(
			UpdateConfig5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.UpdateConfig5.IsNull() && !v.UpdateConfig5.IsUnknown() {
		updateConfig5 = types.ObjectValueMust(
			UpdateConfig5Value{}.AttributeTypes(ctx),
			v.UpdateConfig5.Attributes(),
		)
	}

	var asgSuspendProcessesVal basetypes.ListValue
	switch {
	case v.AsgSuspendProcesses.IsUnknown():
		asgSuspendProcessesVal = types.ListUnknown(types.StringType)
	case v.AsgSuspendProcesses.IsNull():
		asgSuspendProcessesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		asgSuspendProcessesVal, d = types.ListValue(types.StringType, v.AsgSuspendProcesses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam5Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ObjectType{
				AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"node_repair_config": basetypes.ObjectType{
				AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement5Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints5Value{}.Type(ctx),
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var availabilityZonesVal basetypes.ListValue
	switch {
	case v.AvailabilityZones.IsUnknown():
		availabilityZonesVal = types.ListUnknown(types.StringType)
	case v.AvailabilityZones.IsNull():
		availabilityZonesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		availabilityZonesVal, d = types.ListValue(types.StringType, v.AvailabilityZones.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam5Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ObjectType{
				AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"node_repair_config": basetypes.ObjectType{
				AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement5Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints5Value{}.Type(ctx),
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var instanceTypesVal basetypes.ListValue
	switch {
	case v.InstanceTypes.IsUnknown():
		instanceTypesVal = types.ListUnknown(types.StringType)
	case v.InstanceTypes.IsNull():
		instanceTypesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		instanceTypesVal, d = types.ListValue(types.StringType, v.InstanceTypes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam5Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ObjectType{
				AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"node_repair_config": basetypes.ObjectType{
				AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement5Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints5Value{}.Type(ctx),
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam5Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ObjectType{
				AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"node_repair_config": basetypes.ObjectType{
				AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement5Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints5Value{}.Type(ctx),
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var preBootstrapCommandsVal basetypes.ListValue
	switch {
	case v.PreBootstrapCommands.IsUnknown():
		preBootstrapCommandsVal = types.ListUnknown(types.StringType)
	case v.PreBootstrapCommands.IsNull():
		preBootstrapCommandsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		preBootstrapCommandsVal, d = types.ListValue(types.StringType, v.PreBootstrapCommands.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam5Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ObjectType{
				AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"node_repair_config": basetypes.ObjectType{
				AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement5Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints5Value{}.Type(ctx),
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var subnetsVal basetypes.SetValue
	switch {
	case v.Subnets.IsUnknown():
		subnetsVal = types.SetUnknown(types.StringType)
	case v.Subnets.IsNull():
		subnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		subnetsVal, d = types.SetValue(types.StringType, v.Subnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam5Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ObjectType{
				AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"node_repair_config": basetypes.ObjectType{
				AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement5Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints5Value{}.Type(ctx),
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam5Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ObjectType{
				AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"node_repair_config": basetypes.ObjectType{
				AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement5Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints5Value{}.Type(ctx),
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ami":        basetypes.StringType{},
		"ami_family": basetypes.StringType{},
		"asg_suspend_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"availability_zones": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bottle_rocket": basetypes.ObjectType{
			AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
		},
		"desired_capacity":           basetypes.Int64Type{},
		"disable_imdsv1":             basetypes.BoolType{},
		"disable_pods_imds":          basetypes.BoolType{},
		"ebs_optimized":              basetypes.BoolType{},
		"efa_enabled":                basetypes.BoolType{},
		"enable_detailed_monitoring": basetypes.BoolType{},
		"iam": basetypes.ObjectType{
			AttrTypes: Iam5Value{}.AttributeTypes(ctx),
		},
		"instance_name":   basetypes.StringType{},
		"instance_prefix": basetypes.StringType{},
		"instance_selector": basetypes.ObjectType{
			AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
		},
		"instance_type": basetypes.StringType{},
		"instance_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"launch_template": basetypes.ObjectType{
			AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
		},
		"max_pods_per_node": basetypes.Int64Type{},
		"max_size":          basetypes.Int64Type{},
		"min_size":          basetypes.Int64Type{},
		"node_repair_config": basetypes.ObjectType{
			AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
		},
		"override_bootstrap_command": basetypes.StringType{},
		"placement": basetypes.ObjectType{
			AttrTypes: Placement5Value{}.AttributeTypes(ctx),
		},
		"pre_bootstrap_commands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_networking": basetypes.BoolType{},
		"security_groups": basetypes.ObjectType{
			AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
		},
		"spot": basetypes.BoolType{},
		"ssh": basetypes.ObjectType{
			AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
		},
		"subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"taints": basetypes.SetType{
			ElemType: Taints5Value{}.Type(ctx),
		},
		"update_config": basetypes.ObjectType{
			AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
		},
		"version":           basetypes.StringType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_iops":       basetypes.Int64Type{},
		"volume_kms_key_id": basetypes.StringType{},
		"volume_name":       basetypes.StringType{},
		"volume_size":       basetypes.Int64Type{},
		"volume_throughput": basetypes.Int64Type{},
		"volume_type":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ami":                        v.Ami,
			"ami_family":                 v.AmiFamily,
			"asg_suspend_processes":      asgSuspendProcessesVal,
			"availability_zones":         availabilityZonesVal,
			"bottle_rocket":              bottleRocket5,
			"desired_capacity":           v.DesiredCapacity,
			"disable_imdsv1":             v.DisableImdsv1,
			"disable_pods_imds":          v.DisablePodsImds,
			"ebs_optimized":              v.EbsOptimized,
			"efa_enabled":                v.EfaEnabled,
			"enable_detailed_monitoring": v.EnableDetailedMonitoring,
			"iam":                        iam5,
			"instance_name":              v.InstanceName,
			"instance_prefix":            v.InstancePrefix,
			"instance_selector":          instanceSelector5,
			"instance_type":              v.InstanceType,
			"instance_types":             instanceTypesVal,
			"labels":                     labelsVal,
			"launch_template":            launchTemplate5,
			"max_pods_per_node":          v.MaxPodsPerNode,
			"max_size":                   v.MaxSize,
			"min_size":                   v.MinSize,
			"node_repair_config":         nodeRepairConfig5,
			"override_bootstrap_command": v.OverrideBootstrapCommand,
			"placement":                  placement5,
			"pre_bootstrap_commands":     preBootstrapCommandsVal,
			"private_networking":         v.PrivateNetworking,
			"security_groups":            securityGroups5,
			"spot":                       v.Spot,
			"ssh":                        ssh5,
			"subnets":                    subnetsVal,
			"tags":                       tagsVal,
			"taints":                     taints5,
			"update_config":              updateConfig5,
			"version":                    v.Version,
			"volume_encrypted":           v.VolumeEncrypted,
			"volume_iops":                v.VolumeIops,
			"volume_kms_key_id":          v.VolumeKmsKeyId,
			"volume_name":                v.VolumeName,
			"volume_size":                v.VolumeSize,
			"volume_throughput":          v.VolumeThroughput,
			"volume_type":                v.VolumeType,
		})

	return objVal, diags
}

func (v ManagedNodegroupsMapValue) Equal(o attr.Value) bool {
	other, ok := o.(ManagedNodegroupsMapValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ami.Equal(other.Ami) {
		return false
	}

	if !v.AmiFamily.Equal(other.AmiFamily) {
		return false
	}

	if !v.AsgSuspendProcesses.Equal(other.AsgSuspendProcesses) {
		return false
	}

	if !v.AvailabilityZones.Equal(other.AvailabilityZones) {
		return false
	}

	if !v.BottleRocket5.Equal(other.BottleRocket5) {
		return false
	}

	if !v.DesiredCapacity.Equal(other.DesiredCapacity) {
		return false
	}

	if !v.DisableImdsv1.Equal(other.DisableImdsv1) {
		return false
	}

	if !v.DisablePodsImds.Equal(other.DisablePodsImds) {
		return false
	}

	if !v.EbsOptimized.Equal(other.EbsOptimized) {
		return false
	}

	if !v.EfaEnabled.Equal(other.EfaEnabled) {
		return false
	}

	if !v.EnableDetailedMonitoring.Equal(other.EnableDetailedMonitoring) {
		return false
	}

	if !v.Iam5.Equal(other.Iam5) {
		return false
	}

	if !v.InstanceName.Equal(other.InstanceName) {
		return false
	}

	if !v.InstancePrefix.Equal(other.InstancePrefix) {
		return false
	}

	if !v.InstanceSelector5.Equal(other.InstanceSelector5) {
		return false
	}

	if !v.InstanceType.Equal(other.InstanceType) {
		return false
	}

	if !v.InstanceTypes.Equal(other.InstanceTypes) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.LaunchTemplate5.Equal(other.LaunchTemplate5) {
		return false
	}

	if !v.MaxPodsPerNode.Equal(other.MaxPodsPerNode) {
		return false
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.NodeRepairConfig5.Equal(other.NodeRepairConfig5) {
		return false
	}

	if !v.OverrideBootstrapCommand.Equal(other.OverrideBootstrapCommand) {
		return false
	}

	if !v.Placement5.Equal(other.Placement5) {
		return false
	}

	if !v.PreBootstrapCommands.Equal(other.PreBootstrapCommands) {
		return false
	}

	if !v.PrivateNetworking.Equal(other.PrivateNetworking) {
		return false
	}

	if !v.SecurityGroups5.Equal(other.SecurityGroups5) {
		return false
	}

	if !v.Spot.Equal(other.Spot) {
		return false
	}

	if !v.Ssh5.Equal(other.Ssh5) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Taints5.Equal(other.Taints5) {
		return false
	}

	if !v.UpdateConfig5.Equal(other.UpdateConfig5) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VolumeEncrypted.Equal(other.VolumeEncrypted) {
		return false
	}

	if !v.VolumeIops.Equal(other.VolumeIops) {
		return false
	}

	if !v.VolumeKmsKeyId.Equal(other.VolumeKmsKeyId) {
		return false
	}

	if !v.VolumeName.Equal(other.VolumeName) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeThroughput.Equal(other.VolumeThroughput) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v ManagedNodegroupsMapValue) Type(ctx context.Context) attr.Type {
	return ManagedNodegroupsMapType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ManagedNodegroupsMapValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami":        basetypes.StringType{},
		"ami_family": basetypes.StringType{},
		"asg_suspend_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"availability_zones": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bottle_rocket": basetypes.ObjectType{
			AttrTypes: BottleRocket5Value{}.AttributeTypes(ctx),
		},
		"desired_capacity":           basetypes.Int64Type{},
		"disable_imdsv1":             basetypes.BoolType{},
		"disable_pods_imds":          basetypes.BoolType{},
		"ebs_optimized":              basetypes.BoolType{},
		"efa_enabled":                basetypes.BoolType{},
		"enable_detailed_monitoring": basetypes.BoolType{},
		"iam": basetypes.ObjectType{
			AttrTypes: Iam5Value{}.AttributeTypes(ctx),
		},
		"instance_name":   basetypes.StringType{},
		"instance_prefix": basetypes.StringType{},
		"instance_selector": basetypes.ObjectType{
			AttrTypes: InstanceSelector5Value{}.AttributeTypes(ctx),
		},
		"instance_type": basetypes.StringType{},
		"instance_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"launch_template": basetypes.ObjectType{
			AttrTypes: LaunchTemplate5Value{}.AttributeTypes(ctx),
		},
		"max_pods_per_node": basetypes.Int64Type{},
		"max_size":          basetypes.Int64Type{},
		"min_size":          basetypes.Int64Type{},
		"node_repair_config": basetypes.ObjectType{
			AttrTypes: NodeRepairConfig5Value{}.AttributeTypes(ctx),
		},
		"override_bootstrap_command": basetypes.StringType{},
		"placement": basetypes.ObjectType{
			AttrTypes: Placement5Value{}.AttributeTypes(ctx),
		},
		"pre_bootstrap_commands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_networking": basetypes.BoolType{},
		"security_groups": basetypes.ObjectType{
			AttrTypes: SecurityGroups5Value{}.AttributeTypes(ctx),
		},
		"spot": basetypes.BoolType{},
		"ssh": basetypes.ObjectType{
			AttrTypes: Ssh5Value{}.AttributeTypes(ctx),
		},
		"subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"taints": basetypes.SetType{
			ElemType: Taints5Value{}.Type(ctx),
		},
		"update_config": basetypes.ObjectType{
			AttrTypes: UpdateConfig5Value{}.AttributeTypes(ctx),
		},
		"version":           basetypes.StringType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_iops":       basetypes.Int64Type{},
		"volume_kms_key_id": basetypes.StringType{},
		"volume_name":       basetypes.StringType{},
		"volume_size":       basetypes.Int64Type{},
		"volume_throughput": basetypes.Int64Type{},
		"volume_type":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BottleRocket5Type{}

type BottleRocket5Type struct {
	basetypes.ObjectType
}

func (t BottleRocket5Type) Equal(o attr.Type) bool {
	other, ok := o.(BottleRocket5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BottleRocket5Type) String() string {
	return "BottleRocket5Type"
}

func (t BottleRocket5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableAdminContainerAttribute, ok := attributes["enable_admin_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_admin_container is missing from object`)

		return nil, diags
	}

	enableAdminContainerVal, ok := enableAdminContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_admin_container expected to be basetypes.BoolValue, was: %T`, enableAdminContainerAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.StringValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BottleRocket5Value{
		EnableAdminContainer: enableAdminContainerVal,
		Settings:             settingsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBottleRocket5ValueNull() BottleRocket5Value {
	return BottleRocket5Value{
		state: attr.ValueStateNull,
	}
}

func NewBottleRocket5ValueUnknown() BottleRocket5Value {
	return BottleRocket5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBottleRocket5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BottleRocket5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BottleRocket5Value Attribute Value",
				"While creating a BottleRocket5Value value, a missing attribute value was detected. "+
					"A BottleRocket5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BottleRocket5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BottleRocket5Value Attribute Type",
				"While creating a BottleRocket5Value value, an invalid attribute value was detected. "+
					"A BottleRocket5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BottleRocket5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BottleRocket5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BottleRocket5Value Attribute Value",
				"While creating a BottleRocket5Value value, an extra attribute value was detected. "+
					"A BottleRocket5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BottleRocket5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBottleRocket5ValueUnknown(), diags
	}

	enableAdminContainerAttribute, ok := attributes["enable_admin_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_admin_container is missing from object`)

		return NewBottleRocket5ValueUnknown(), diags
	}

	enableAdminContainerVal, ok := enableAdminContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_admin_container expected to be basetypes.BoolValue, was: %T`, enableAdminContainerAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewBottleRocket5ValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.StringValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return NewBottleRocket5ValueUnknown(), diags
	}

	return BottleRocket5Value{
		EnableAdminContainer: enableAdminContainerVal,
		Settings:             settingsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBottleRocket5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BottleRocket5Value {
	object, diags := NewBottleRocket5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBottleRocket5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BottleRocket5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBottleRocket5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBottleRocket5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBottleRocket5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBottleRocket5ValueMust(BottleRocket5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t BottleRocket5Type) ValueType(ctx context.Context) attr.Value {
	return BottleRocket5Value{}
}

var _ basetypes.ObjectValuable = BottleRocket5Value{}

type BottleRocket5Value struct {
	EnableAdminContainer basetypes.BoolValue   `tfsdk:"enable_admin_container"`
	Settings             basetypes.StringValue `tfsdk:"settings"`
	state                attr.ValueState
}

func (v BottleRocket5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enable_admin_container"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EnableAdminContainer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_admin_container"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BottleRocket5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BottleRocket5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BottleRocket5Value) String() string {
	return "BottleRocket5Value"
}

func (v BottleRocket5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enable_admin_container": basetypes.BoolType{},
		"settings":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable_admin_container": v.EnableAdminContainer,
			"settings":               v.Settings,
		})

	return objVal, diags
}

func (v BottleRocket5Value) Equal(o attr.Value) bool {
	other, ok := o.(BottleRocket5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnableAdminContainer.Equal(other.EnableAdminContainer) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	return true
}

func (v BottleRocket5Value) Type(ctx context.Context) attr.Type {
	return BottleRocket5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BottleRocket5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable_admin_container": basetypes.BoolType{},
		"settings":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Iam5Type{}

type Iam5Type struct {
	basetypes.ObjectType
}

func (t Iam5Type) Equal(o attr.Type) bool {
	other, ok := o.(Iam5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Iam5Type) String() string {
	return "Iam5Type"
}

func (t Iam5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachPolicy5Attribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy5 is missing from object`)

		return nil, diags
	}

	attachPolicy5Val, ok := attachPolicy5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy5 expected to be basetypes.ObjectValue, was: %T`, attachPolicy5Attribute))
	}

	attachPolicyArnsAttribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns is missing from object`)

		return nil, diags
	}

	attachPolicyArnsVal, ok := attachPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns expected to be basetypes.SetValue, was: %T`, attachPolicyArnsAttribute))
	}

	attachPolicyV2Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2 is missing from object`)

		return nil, diags
	}

	attachPolicyV2Val, ok := attachPolicyV2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2 expected to be basetypes.StringValue, was: %T`, attachPolicyV2Attribute))
	}

	iamNodeGroupWithAddonPolicies5Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies5 is missing from object`)

		return nil, diags
	}

	iamNodeGroupWithAddonPolicies5Val, ok := iamNodeGroupWithAddonPolicies5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies5 expected to be basetypes.ObjectValue, was: %T`, iamNodeGroupWithAddonPolicies5Attribute))
	}

	instanceProfileArnAttribute, ok := attributes["instance_profile_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_profile_arn is missing from object`)

		return nil, diags
	}

	instanceProfileArnVal, ok := instanceProfileArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_profile_arn expected to be basetypes.StringValue, was: %T`, instanceProfileArnAttribute))
	}

	instanceRoleArnAttribute, ok := attributes["instance_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_arn is missing from object`)

		return nil, diags
	}

	instanceRoleArnVal, ok := instanceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_arn expected to be basetypes.StringValue, was: %T`, instanceRoleArnAttribute))
	}

	instanceRoleNameAttribute, ok := attributes["instance_role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_name is missing from object`)

		return nil, diags
	}

	instanceRoleNameVal, ok := instanceRoleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_name expected to be basetypes.StringValue, was: %T`, instanceRoleNameAttribute))
	}

	instanceRolePermissionBoundaryAttribute, ok := attributes["instance_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_permission_boundary is missing from object`)

		return nil, diags
	}

	instanceRolePermissionBoundaryVal, ok := instanceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_permission_boundary expected to be basetypes.StringValue, was: %T`, instanceRolePermissionBoundaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Iam5Value{
		AttachPolicy5:                  attachPolicy5Val,
		AttachPolicyArns:               attachPolicyArnsVal,
		AttachPolicyV2:                 attachPolicyV2Val,
		IamNodeGroupWithAddonPolicies5: iamNodeGroupWithAddonPolicies5Val,
		InstanceProfileArn:             instanceProfileArnVal,
		InstanceRoleArn:                instanceRoleArnVal,
		InstanceRoleName:               instanceRoleNameVal,
		InstanceRolePermissionBoundary: instanceRolePermissionBoundaryVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam5ValueNull() Iam5Value {
	return Iam5Value{
		state: attr.ValueStateNull,
	}
}

func NewIam5ValueUnknown() Iam5Value {
	return Iam5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIam5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Iam5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Iam5Value Attribute Value",
				"While creating a Iam5Value value, a missing attribute value was detected. "+
					"A Iam5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Iam5Value Attribute Type",
				"While creating a Iam5Value value, an invalid attribute value was detected. "+
					"A Iam5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Iam5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Iam5Value Attribute Value",
				"While creating a Iam5Value value, an extra attribute value was detected. "+
					"A Iam5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Iam5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIam5ValueUnknown(), diags
	}

	attachPolicy5Attribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy5 is missing from object`)

		return NewIam5ValueUnknown(), diags
	}

	attachPolicy5Val, ok := attachPolicy5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy5 expected to be basetypes.ObjectValue, was: %T`, attachPolicy5Attribute))
	}

	attachPolicyArnsAttribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns is missing from object`)

		return NewIam5ValueUnknown(), diags
	}

	attachPolicyArnsVal, ok := attachPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns expected to be basetypes.SetValue, was: %T`, attachPolicyArnsAttribute))
	}

	attachPolicyV2Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2 is missing from object`)

		return NewIam5ValueUnknown(), diags
	}

	attachPolicyV2Val, ok := attachPolicyV2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2 expected to be basetypes.StringValue, was: %T`, attachPolicyV2Attribute))
	}

	iamNodeGroupWithAddonPolicies5Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies5 is missing from object`)

		return NewIam5ValueUnknown(), diags
	}

	iamNodeGroupWithAddonPolicies5Val, ok := iamNodeGroupWithAddonPolicies5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies5 expected to be basetypes.ObjectValue, was: %T`, iamNodeGroupWithAddonPolicies5Attribute))
	}

	instanceProfileArnAttribute, ok := attributes["instance_profile_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_profile_arn is missing from object`)

		return NewIam5ValueUnknown(), diags
	}

	instanceProfileArnVal, ok := instanceProfileArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_profile_arn expected to be basetypes.StringValue, was: %T`, instanceProfileArnAttribute))
	}

	instanceRoleArnAttribute, ok := attributes["instance_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_arn is missing from object`)

		return NewIam5ValueUnknown(), diags
	}

	instanceRoleArnVal, ok := instanceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_arn expected to be basetypes.StringValue, was: %T`, instanceRoleArnAttribute))
	}

	instanceRoleNameAttribute, ok := attributes["instance_role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_name is missing from object`)

		return NewIam5ValueUnknown(), diags
	}

	instanceRoleNameVal, ok := instanceRoleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_name expected to be basetypes.StringValue, was: %T`, instanceRoleNameAttribute))
	}

	instanceRolePermissionBoundaryAttribute, ok := attributes["instance_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_permission_boundary is missing from object`)

		return NewIam5ValueUnknown(), diags
	}

	instanceRolePermissionBoundaryVal, ok := instanceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_permission_boundary expected to be basetypes.StringValue, was: %T`, instanceRolePermissionBoundaryAttribute))
	}

	if diags.HasError() {
		return NewIam5ValueUnknown(), diags
	}

	return Iam5Value{
		AttachPolicy5:                  attachPolicy5Val,
		AttachPolicyArns:               attachPolicyArnsVal,
		AttachPolicyV2:                 attachPolicyV2Val,
		IamNodeGroupWithAddonPolicies5: iamNodeGroupWithAddonPolicies5Val,
		InstanceProfileArn:             instanceProfileArnVal,
		InstanceRoleArn:                instanceRoleArnVal,
		InstanceRoleName:               instanceRoleNameVal,
		InstanceRolePermissionBoundary: instanceRolePermissionBoundaryVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Iam5Value {
	object, diags := NewIam5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIam5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Iam5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIam5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIam5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIam5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIam5ValueMust(Iam5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Iam5Type) ValueType(ctx context.Context) attr.Value {
	return Iam5Value{}
}

var _ basetypes.ObjectValuable = Iam5Value{}

type Iam5Value struct {
	AttachPolicy5                  basetypes.ObjectValue `tfsdk:"attach_policy"`
	AttachPolicyArns               basetypes.SetValue    `tfsdk:"attach_policy_arns"`
	AttachPolicyV2                 basetypes.StringValue `tfsdk:"attach_policy_v2"`
	IamNodeGroupWithAddonPolicies5 basetypes.ObjectValue `tfsdk:"iam_node_group_with_addon_policies"`
	InstanceProfileArn             basetypes.StringValue `tfsdk:"instance_profile_arn"`
	InstanceRoleArn                basetypes.StringValue `tfsdk:"instance_role_arn"`
	InstanceRoleName               basetypes.StringValue `tfsdk:"instance_role_name"`
	InstanceRolePermissionBoundary basetypes.StringValue `tfsdk:"instance_role_permission_boundary"`
	state                          attr.ValueState
}

func (v Iam5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["attach_policy"] = basetypes.ObjectType{
		AttrTypes: AttachPolicy5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["attach_policy_arns"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["attach_policy_v2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["iam_node_group_with_addon_policies"] = basetypes.ObjectType{
		AttrTypes: IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_profile_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_permission_boundary"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AttachPolicy5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy"] = val

		val, err = v.AttachPolicyArns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_arns"] = val

		val, err = v.AttachPolicyV2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_v2"] = val

		val, err = v.IamNodeGroupWithAddonPolicies5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_node_group_with_addon_policies"] = val

		val, err = v.InstanceProfileArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_profile_arn"] = val

		val, err = v.InstanceRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_arn"] = val

		val, err = v.InstanceRoleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_name"] = val

		val, err = v.InstanceRolePermissionBoundary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_permission_boundary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Iam5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Iam5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Iam5Value) String() string {
	return "Iam5Value"
}

func (v Iam5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attachPolicy5 basetypes.ObjectValue

	if v.AttachPolicy5.IsNull() {
		attachPolicy5 = types.ObjectNull(
			AttachPolicy5Value{}.AttributeTypes(ctx),
		)
	}

	if v.AttachPolicy5.IsUnknown() {
		attachPolicy5 = types.ObjectUnknown(
			AttachPolicy5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.AttachPolicy5.IsNull() && !v.AttachPolicy5.IsUnknown() {
		attachPolicy5 = types.ObjectValueMust(
			AttachPolicy5Value{}.AttributeTypes(ctx),
			v.AttachPolicy5.Attributes(),
		)
	}

	var iamNodeGroupWithAddonPolicies5 basetypes.ObjectValue

	if v.IamNodeGroupWithAddonPolicies5.IsNull() {
		iamNodeGroupWithAddonPolicies5 = types.ObjectNull(
			IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx),
		)
	}

	if v.IamNodeGroupWithAddonPolicies5.IsUnknown() {
		iamNodeGroupWithAddonPolicies5 = types.ObjectUnknown(
			IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.IamNodeGroupWithAddonPolicies5.IsNull() && !v.IamNodeGroupWithAddonPolicies5.IsUnknown() {
		iamNodeGroupWithAddonPolicies5 = types.ObjectValueMust(
			IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx),
			v.IamNodeGroupWithAddonPolicies5.Attributes(),
		)
	}

	var attachPolicyArnsVal basetypes.SetValue
	switch {
	case v.AttachPolicyArns.IsUnknown():
		attachPolicyArnsVal = types.SetUnknown(types.StringType)
	case v.AttachPolicyArns.IsNull():
		attachPolicyArnsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachPolicyArnsVal, d = types.SetValue(types.StringType, v.AttachPolicyArns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_policy": basetypes.ObjectType{
				AttrTypes: AttachPolicy5Value{}.AttributeTypes(ctx),
			},
			"attach_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"attach_policy_v2": basetypes.StringType{},
			"iam_node_group_with_addon_policies": basetypes.ObjectType{
				AttrTypes: IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx),
			},
			"instance_profile_arn":              basetypes.StringType{},
			"instance_role_arn":                 basetypes.StringType{},
			"instance_role_name":                basetypes.StringType{},
			"instance_role_permission_boundary": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_policy": basetypes.ObjectType{
			AttrTypes: AttachPolicy5Value{}.AttributeTypes(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2": basetypes.StringType{},
		"iam_node_group_with_addon_policies": basetypes.ObjectType{
			AttrTypes: IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx),
		},
		"instance_profile_arn":              basetypes.StringType{},
		"instance_role_arn":                 basetypes.StringType{},
		"instance_role_name":                basetypes.StringType{},
		"instance_role_permission_boundary": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_policy":                      attachPolicy5,
			"attach_policy_arns":                 attachPolicyArnsVal,
			"attach_policy_v2":                   v.AttachPolicyV2,
			"iam_node_group_with_addon_policies": iamNodeGroupWithAddonPolicies5,
			"instance_profile_arn":               v.InstanceProfileArn,
			"instance_role_arn":                  v.InstanceRoleArn,
			"instance_role_name":                 v.InstanceRoleName,
			"instance_role_permission_boundary":  v.InstanceRolePermissionBoundary,
		})

	return objVal, diags
}

func (v Iam5Value) Equal(o attr.Value) bool {
	other, ok := o.(Iam5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachPolicy5.Equal(other.AttachPolicy5) {
		return false
	}

	if !v.AttachPolicyArns.Equal(other.AttachPolicyArns) {
		return false
	}

	if !v.AttachPolicyV2.Equal(other.AttachPolicyV2) {
		return false
	}

	if !v.IamNodeGroupWithAddonPolicies5.Equal(other.IamNodeGroupWithAddonPolicies5) {
		return false
	}

	if !v.InstanceProfileArn.Equal(other.InstanceProfileArn) {
		return false
	}

	if !v.InstanceRoleArn.Equal(other.InstanceRoleArn) {
		return false
	}

	if !v.InstanceRoleName.Equal(other.InstanceRoleName) {
		return false
	}

	if !v.InstanceRolePermissionBoundary.Equal(other.InstanceRolePermissionBoundary) {
		return false
	}

	return true
}

func (v Iam5Value) Type(ctx context.Context) attr.Type {
	return Iam5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Iam5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_policy": basetypes.ObjectType{
			AttrTypes: AttachPolicy5Value{}.AttributeTypes(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2": basetypes.StringType{},
		"iam_node_group_with_addon_policies": basetypes.ObjectType{
			AttrTypes: IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx),
		},
		"instance_profile_arn":              basetypes.StringType{},
		"instance_role_arn":                 basetypes.StringType{},
		"instance_role_name":                basetypes.StringType{},
		"instance_role_permission_boundary": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttachPolicy5Type{}

type AttachPolicy5Type struct {
	basetypes.ObjectType
}

func (t AttachPolicy5Type) Equal(o attr.Type) bool {
	other, ok := o.(AttachPolicy5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachPolicy5Type) String() string {
	return "AttachPolicy5Type"
}

func (t AttachPolicy5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statement5Attribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement5 is missing from object`)

		return nil, diags
	}

	statement5Val, ok := statement5Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement5 expected to be basetypes.SetValue, was: %T`, statement5Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachPolicy5Value{
		Id:         idVal,
		Statement5: statement5Val,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicy5ValueNull() AttachPolicy5Value {
	return AttachPolicy5Value{
		state: attr.ValueStateNull,
	}
}

func NewAttachPolicy5ValueUnknown() AttachPolicy5Value {
	return AttachPolicy5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachPolicy5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachPolicy5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachPolicy5Value Attribute Value",
				"While creating a AttachPolicy5Value value, a missing attribute value was detected. "+
					"A AttachPolicy5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicy5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachPolicy5Value Attribute Type",
				"While creating a AttachPolicy5Value value, an invalid attribute value was detected. "+
					"A AttachPolicy5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicy5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachPolicy5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachPolicy5Value Attribute Value",
				"While creating a AttachPolicy5Value value, an extra attribute value was detected. "+
					"A AttachPolicy5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachPolicy5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachPolicy5ValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewAttachPolicy5ValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statement5Attribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement5 is missing from object`)

		return NewAttachPolicy5ValueUnknown(), diags
	}

	statement5Val, ok := statement5Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement5 expected to be basetypes.SetValue, was: %T`, statement5Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewAttachPolicy5ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewAttachPolicy5ValueUnknown(), diags
	}

	return AttachPolicy5Value{
		Id:         idVal,
		Statement5: statement5Val,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicy5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachPolicy5Value {
	object, diags := NewAttachPolicy5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachPolicy5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachPolicy5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachPolicy5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachPolicy5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachPolicy5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachPolicy5ValueMust(AttachPolicy5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t AttachPolicy5Type) ValueType(ctx context.Context) attr.Value {
	return AttachPolicy5Value{}
}

var _ basetypes.ObjectValuable = AttachPolicy5Value{}

type AttachPolicy5Value struct {
	Id         basetypes.StringValue `tfsdk:"id"`
	Statement5 basetypes.SetValue    `tfsdk:"statement"`
	Version    basetypes.StringValue `tfsdk:"version"`
	state      attr.ValueState
}

func (v AttachPolicy5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["statement"] = basetypes.SetType{
		ElemType: Statement5Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Statement5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statement"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachPolicy5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachPolicy5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachPolicy5Value) String() string {
	return "AttachPolicy5Value"
}

func (v AttachPolicy5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	statement5 := types.SetValueMust(
		Statement5Type{
			basetypes.ObjectType{
				AttrTypes: Statement5Value{}.AttributeTypes(ctx),
			},
		},
		v.Statement5.Elements(),
	)

	if v.Statement5.IsNull() {
		statement5 = types.SetNull(
			Statement5Type{
				basetypes.ObjectType{
					AttrTypes: Statement5Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Statement5.IsUnknown() {
		statement5 = types.SetUnknown(
			Statement5Type{
				basetypes.ObjectType{
					AttrTypes: Statement5Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: Statement5Value{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":        v.Id,
			"statement": statement5,
			"version":   v.Version,
		})

	return objVal, diags
}

func (v AttachPolicy5Value) Equal(o attr.Value) bool {
	other, ok := o.(AttachPolicy5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Statement5.Equal(other.Statement5) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v AttachPolicy5Value) Type(ctx context.Context) attr.Type {
	return AttachPolicy5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachPolicy5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: Statement5Value{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Statement5Type{}

type Statement5Type struct {
	basetypes.ObjectType
}

func (t Statement5Type) Equal(o attr.Type) bool {
	other, ok := o.(Statement5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Statement5Type) String() string {
	return "Statement5Type"
}

func (t Statement5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return nil, diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return nil, diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return nil, diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return nil, diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return nil, diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Statement5Value{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatement5ValueNull() Statement5Value {
	return Statement5Value{
		state: attr.ValueStateNull,
	}
}

func NewStatement5ValueUnknown() Statement5Value {
	return Statement5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewStatement5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Statement5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Statement5Value Attribute Value",
				"While creating a Statement5Value value, a missing attribute value was detected. "+
					"A Statement5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Statement5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Statement5Value Attribute Type",
				"While creating a Statement5Value value, an invalid attribute value was detected. "+
					"A Statement5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Statement5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Statement5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Statement5Value Attribute Value",
				"While creating a Statement5Value value, an extra attribute value was detected. "+
					"A Statement5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Statement5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatement5ValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return NewStatement5ValueUnknown(), diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return NewStatement5ValueUnknown(), diags
	}

	return Statement5Value{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatement5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Statement5Value {
	object, diags := NewStatement5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatement5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Statement5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatement5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatement5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatement5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatement5ValueMust(Statement5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Statement5Type) ValueType(ctx context.Context) attr.Value {
	return Statement5Value{}
}

var _ basetypes.ObjectValuable = Statement5Value{}

type Statement5Value struct {
	Action       basetypes.SetValue    `tfsdk:"action"`
	Condition    basetypes.StringValue `tfsdk:"condition"`
	Effect       basetypes.StringValue `tfsdk:"effect"`
	NotAction    basetypes.SetValue    `tfsdk:"not_action"`
	NotPrincipal basetypes.StringValue `tfsdk:"not_principal"`
	NotResource  basetypes.SetValue    `tfsdk:"not_resource"`
	Principal    basetypes.StringValue `tfsdk:"principal"`
	Resource     basetypes.StringValue `tfsdk:"resource"`
	Sid          basetypes.StringValue `tfsdk:"sid"`
	state        attr.ValueState
}

func (v Statement5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["not_principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_resource"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.NotAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_action"] = val

		val, err = v.NotPrincipal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_principal"] = val

		val, err = v.NotResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_resource"] = val

		val, err = v.Principal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["principal"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Sid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Statement5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Statement5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Statement5Value) String() string {
	return "Statement5Value"
}

func (v Statement5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var actionVal basetypes.SetValue
	switch {
	case v.Action.IsUnknown():
		actionVal = types.SetUnknown(types.StringType)
	case v.Action.IsNull():
		actionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		actionVal, d = types.SetValue(types.StringType, v.Action.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notActionVal basetypes.SetValue
	switch {
	case v.NotAction.IsUnknown():
		notActionVal = types.SetUnknown(types.StringType)
	case v.NotAction.IsNull():
		notActionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notActionVal, d = types.SetValue(types.StringType, v.NotAction.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notResourceVal basetypes.SetValue
	switch {
	case v.NotResource.IsUnknown():
		notResourceVal = types.SetUnknown(types.StringType)
	case v.NotResource.IsNull():
		notResourceVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notResourceVal, d = types.SetValue(types.StringType, v.NotResource.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":        actionVal,
			"condition":     v.Condition,
			"effect":        v.Effect,
			"not_action":    notActionVal,
			"not_principal": v.NotPrincipal,
			"not_resource":  notResourceVal,
			"principal":     v.Principal,
			"resource":      v.Resource,
			"sid":           v.Sid,
		})

	return objVal, diags
}

func (v Statement5Value) Equal(o attr.Value) bool {
	other, ok := o.(Statement5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.NotAction.Equal(other.NotAction) {
		return false
	}

	if !v.NotPrincipal.Equal(other.NotPrincipal) {
		return false
	}

	if !v.NotResource.Equal(other.NotResource) {
		return false
	}

	if !v.Principal.Equal(other.Principal) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Sid.Equal(other.Sid) {
		return false
	}

	return true
}

func (v Statement5Value) Type(ctx context.Context) attr.Type {
	return Statement5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Statement5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IamNodeGroupWithAddonPolicies5Type{}

type IamNodeGroupWithAddonPolicies5Type struct {
	basetypes.ObjectType
}

func (t IamNodeGroupWithAddonPolicies5Type) Equal(o attr.Type) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamNodeGroupWithAddonPolicies5Type) String() string {
	return "IamNodeGroupWithAddonPolicies5Type"
}

func (t IamNodeGroupWithAddonPolicies5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return nil, diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return nil, diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return nil, diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return nil, diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return nil, diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return nil, diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return nil, diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamNodeGroupWithAddonPolicies5Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies5ValueNull() IamNodeGroupWithAddonPolicies5Value {
	return IamNodeGroupWithAddonPolicies5Value{
		state: attr.ValueStateNull,
	}
}

func NewIamNodeGroupWithAddonPolicies5ValueUnknown() IamNodeGroupWithAddonPolicies5Value {
	return IamNodeGroupWithAddonPolicies5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIamNodeGroupWithAddonPolicies5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamNodeGroupWithAddonPolicies5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamNodeGroupWithAddonPolicies5Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies5Value value, a missing attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamNodeGroupWithAddonPolicies5Value Attribute Type",
				"While creating a IamNodeGroupWithAddonPolicies5Value value, an invalid attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamNodeGroupWithAddonPolicies5Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies5Value value, an extra attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamNodeGroupWithAddonPolicies5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), diags
	}

	return IamNodeGroupWithAddonPolicies5Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamNodeGroupWithAddonPolicies5Value {
	object, diags := NewIamNodeGroupWithAddonPolicies5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamNodeGroupWithAddonPolicies5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamNodeGroupWithAddonPolicies5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamNodeGroupWithAddonPolicies5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamNodeGroupWithAddonPolicies5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamNodeGroupWithAddonPolicies5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamNodeGroupWithAddonPolicies5ValueMust(IamNodeGroupWithAddonPolicies5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t IamNodeGroupWithAddonPolicies5Type) ValueType(ctx context.Context) attr.Value {
	return IamNodeGroupWithAddonPolicies5Value{}
}

var _ basetypes.ObjectValuable = IamNodeGroupWithAddonPolicies5Value{}

type IamNodeGroupWithAddonPolicies5Value struct {
	AlbIngress    basetypes.BoolValue `tfsdk:"alb_ingress"`
	AppMesh       basetypes.BoolValue `tfsdk:"app_mesh"`
	AppMeshReview basetypes.BoolValue `tfsdk:"app_mesh_review"`
	AutoScaler    basetypes.BoolValue `tfsdk:"auto_scaler"`
	CertManager   basetypes.BoolValue `tfsdk:"cert_manager"`
	CloudWatch    basetypes.BoolValue `tfsdk:"cloud_watch"`
	Ebs           basetypes.BoolValue `tfsdk:"ebs"`
	Efs           basetypes.BoolValue `tfsdk:"efs"`
	ExternalDns   basetypes.BoolValue `tfsdk:"external_dns"`
	Fsx           basetypes.BoolValue `tfsdk:"fsx"`
	ImageBuilder  basetypes.BoolValue `tfsdk:"image_builder"`
	Xray          basetypes.BoolValue `tfsdk:"xray"`
	state         attr.ValueState
}

func (v IamNodeGroupWithAddonPolicies5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alb_ingress"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh_review"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fsx"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xray"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AlbIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alb_ingress"] = val

		val, err = v.AppMesh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh"] = val

		val, err = v.AppMeshReview.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh_review"] = val

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.Ebs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs"] = val

		val, err = v.Efs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.Fsx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fsx"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		val, err = v.Xray.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xray"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamNodeGroupWithAddonPolicies5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamNodeGroupWithAddonPolicies5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamNodeGroupWithAddonPolicies5Value) String() string {
	return "IamNodeGroupWithAddonPolicies5Value"
}

func (v IamNodeGroupWithAddonPolicies5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alb_ingress":     v.AlbIngress,
			"app_mesh":        v.AppMesh,
			"app_mesh_review": v.AppMeshReview,
			"auto_scaler":     v.AutoScaler,
			"cert_manager":    v.CertManager,
			"cloud_watch":     v.CloudWatch,
			"ebs":             v.Ebs,
			"efs":             v.Efs,
			"external_dns":    v.ExternalDns,
			"fsx":             v.Fsx,
			"image_builder":   v.ImageBuilder,
			"xray":            v.Xray,
		})

	return objVal, diags
}

func (v IamNodeGroupWithAddonPolicies5Value) Equal(o attr.Value) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlbIngress.Equal(other.AlbIngress) {
		return false
	}

	if !v.AppMesh.Equal(other.AppMesh) {
		return false
	}

	if !v.AppMeshReview.Equal(other.AppMeshReview) {
		return false
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.Ebs.Equal(other.Ebs) {
		return false
	}

	if !v.Efs.Equal(other.Efs) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.Fsx.Equal(other.Fsx) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	if !v.Xray.Equal(other.Xray) {
		return false
	}

	return true
}

func (v IamNodeGroupWithAddonPolicies5Value) Type(ctx context.Context) attr.Type {
	return IamNodeGroupWithAddonPolicies5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamNodeGroupWithAddonPolicies5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InstanceSelector5Type{}

type InstanceSelector5Type struct {
	basetypes.ObjectType
}

func (t InstanceSelector5Type) Equal(o attr.Type) bool {
	other, ok := o.(InstanceSelector5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstanceSelector5Type) String() string {
	return "InstanceSelector5Type"
}

func (t InstanceSelector5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuArchitectureAttribute, ok := attributes["cpu_architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_architecture is missing from object`)

		return nil, diags
	}

	cpuArchitectureVal, ok := cpuArchitectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_architecture expected to be basetypes.StringValue, was: %T`, cpuArchitectureAttribute))
	}

	gpusAttribute, ok := attributes["gpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpus is missing from object`)

		return nil, diags
	}

	gpusVal, ok := gpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpus expected to be basetypes.Int64Value, was: %T`, gpusAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return nil, diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstanceSelector5Value{
		CpuArchitecture: cpuArchitectureVal,
		Gpus:            gpusVal,
		Memory:          memoryVal,
		Vcpus:           vcpusVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstanceSelector5ValueNull() InstanceSelector5Value {
	return InstanceSelector5Value{
		state: attr.ValueStateNull,
	}
}

func NewInstanceSelector5ValueUnknown() InstanceSelector5Value {
	return InstanceSelector5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewInstanceSelector5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstanceSelector5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstanceSelector5Value Attribute Value",
				"While creating a InstanceSelector5Value value, a missing attribute value was detected. "+
					"A InstanceSelector5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSelector5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstanceSelector5Value Attribute Type",
				"While creating a InstanceSelector5Value value, an invalid attribute value was detected. "+
					"A InstanceSelector5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSelector5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstanceSelector5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstanceSelector5Value Attribute Value",
				"While creating a InstanceSelector5Value value, an extra attribute value was detected. "+
					"A InstanceSelector5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstanceSelector5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstanceSelector5ValueUnknown(), diags
	}

	cpuArchitectureAttribute, ok := attributes["cpu_architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_architecture is missing from object`)

		return NewInstanceSelector5ValueUnknown(), diags
	}

	cpuArchitectureVal, ok := cpuArchitectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_architecture expected to be basetypes.StringValue, was: %T`, cpuArchitectureAttribute))
	}

	gpusAttribute, ok := attributes["gpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpus is missing from object`)

		return NewInstanceSelector5ValueUnknown(), diags
	}

	gpusVal, ok := gpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpus expected to be basetypes.Int64Value, was: %T`, gpusAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewInstanceSelector5ValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return NewInstanceSelector5ValueUnknown(), diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return NewInstanceSelector5ValueUnknown(), diags
	}

	return InstanceSelector5Value{
		CpuArchitecture: cpuArchitectureVal,
		Gpus:            gpusVal,
		Memory:          memoryVal,
		Vcpus:           vcpusVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstanceSelector5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstanceSelector5Value {
	object, diags := NewInstanceSelector5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstanceSelector5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstanceSelector5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstanceSelector5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstanceSelector5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstanceSelector5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstanceSelector5ValueMust(InstanceSelector5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t InstanceSelector5Type) ValueType(ctx context.Context) attr.Value {
	return InstanceSelector5Value{}
}

var _ basetypes.ObjectValuable = InstanceSelector5Value{}

type InstanceSelector5Value struct {
	CpuArchitecture basetypes.StringValue `tfsdk:"cpu_architecture"`
	Gpus            basetypes.Int64Value  `tfsdk:"gpus"`
	Memory          basetypes.StringValue `tfsdk:"memory"`
	Vcpus           basetypes.Int64Value  `tfsdk:"vcpus"`
	state           attr.ValueState
}

func (v InstanceSelector5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cpu_architecture"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpus"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpuArchitecture.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_architecture"] = val

		val, err = v.Gpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpus"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.Vcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpus"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstanceSelector5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstanceSelector5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstanceSelector5Value) String() string {
	return "InstanceSelector5Value"
}

func (v InstanceSelector5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_architecture": basetypes.StringType{},
		"gpus":             basetypes.Int64Type{},
		"memory":           basetypes.StringType{},
		"vcpus":            basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_architecture": v.CpuArchitecture,
			"gpus":             v.Gpus,
			"memory":           v.Memory,
			"vcpus":            v.Vcpus,
		})

	return objVal, diags
}

func (v InstanceSelector5Value) Equal(o attr.Value) bool {
	other, ok := o.(InstanceSelector5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuArchitecture.Equal(other.CpuArchitecture) {
		return false
	}

	if !v.Gpus.Equal(other.Gpus) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.Vcpus.Equal(other.Vcpus) {
		return false
	}

	return true
}

func (v InstanceSelector5Value) Type(ctx context.Context) attr.Type {
	return InstanceSelector5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstanceSelector5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_architecture": basetypes.StringType{},
		"gpus":             basetypes.Int64Type{},
		"memory":           basetypes.StringType{},
		"vcpus":            basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LaunchTemplate5Type{}

type LaunchTemplate5Type struct {
	basetypes.ObjectType
}

func (t LaunchTemplate5Type) Equal(o attr.Type) bool {
	other, ok := o.(LaunchTemplate5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LaunchTemplate5Type) String() string {
	return "LaunchTemplate5Type"
}

func (t LaunchTemplate5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LaunchTemplate5Value{
		Id:      idVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLaunchTemplate5ValueNull() LaunchTemplate5Value {
	return LaunchTemplate5Value{
		state: attr.ValueStateNull,
	}
}

func NewLaunchTemplate5ValueUnknown() LaunchTemplate5Value {
	return LaunchTemplate5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewLaunchTemplate5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LaunchTemplate5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LaunchTemplate5Value Attribute Value",
				"While creating a LaunchTemplate5Value value, a missing attribute value was detected. "+
					"A LaunchTemplate5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LaunchTemplate5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LaunchTemplate5Value Attribute Type",
				"While creating a LaunchTemplate5Value value, an invalid attribute value was detected. "+
					"A LaunchTemplate5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LaunchTemplate5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LaunchTemplate5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LaunchTemplate5Value Attribute Value",
				"While creating a LaunchTemplate5Value value, an extra attribute value was detected. "+
					"A LaunchTemplate5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LaunchTemplate5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLaunchTemplate5ValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewLaunchTemplate5ValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewLaunchTemplate5ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewLaunchTemplate5ValueUnknown(), diags
	}

	return LaunchTemplate5Value{
		Id:      idVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLaunchTemplate5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LaunchTemplate5Value {
	object, diags := NewLaunchTemplate5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLaunchTemplate5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LaunchTemplate5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLaunchTemplate5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLaunchTemplate5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLaunchTemplate5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLaunchTemplate5ValueMust(LaunchTemplate5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t LaunchTemplate5Type) ValueType(ctx context.Context) attr.Value {
	return LaunchTemplate5Value{}
}

var _ basetypes.ObjectValuable = LaunchTemplate5Value{}

type LaunchTemplate5Value struct {
	Id      basetypes.StringValue `tfsdk:"id"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v LaunchTemplate5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LaunchTemplate5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LaunchTemplate5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LaunchTemplate5Value) String() string {
	return "LaunchTemplate5Value"
}

func (v LaunchTemplate5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":      basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":      v.Id,
			"version": v.Version,
		})

	return objVal, diags
}

func (v LaunchTemplate5Value) Equal(o attr.Value) bool {
	other, ok := o.(LaunchTemplate5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v LaunchTemplate5Value) Type(ctx context.Context) attr.Type {
	return LaunchTemplate5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LaunchTemplate5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":      basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodeRepairConfig5Type{}

type NodeRepairConfig5Type struct {
	basetypes.ObjectType
}

func (t NodeRepairConfig5Type) Equal(o attr.Type) bool {
	other, ok := o.(NodeRepairConfig5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeRepairConfig5Type) String() string {
	return "NodeRepairConfig5Type"
}

func (t NodeRepairConfig5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeRepairConfig5Value{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNodeRepairConfig5ValueNull() NodeRepairConfig5Value {
	return NodeRepairConfig5Value{
		state: attr.ValueStateNull,
	}
}

func NewNodeRepairConfig5ValueUnknown() NodeRepairConfig5Value {
	return NodeRepairConfig5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeRepairConfig5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeRepairConfig5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeRepairConfig5Value Attribute Value",
				"While creating a NodeRepairConfig5Value value, a missing attribute value was detected. "+
					"A NodeRepairConfig5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeRepairConfig5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeRepairConfig5Value Attribute Type",
				"While creating a NodeRepairConfig5Value value, an invalid attribute value was detected. "+
					"A NodeRepairConfig5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeRepairConfig5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeRepairConfig5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeRepairConfig5Value Attribute Value",
				"While creating a NodeRepairConfig5Value value, an extra attribute value was detected. "+
					"A NodeRepairConfig5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeRepairConfig5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeRepairConfig5ValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewNodeRepairConfig5ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewNodeRepairConfig5ValueUnknown(), diags
	}

	return NodeRepairConfig5Value{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNodeRepairConfig5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeRepairConfig5Value {
	object, diags := NewNodeRepairConfig5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeRepairConfig5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeRepairConfig5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeRepairConfig5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeRepairConfig5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeRepairConfig5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeRepairConfig5ValueMust(NodeRepairConfig5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeRepairConfig5Type) ValueType(ctx context.Context) attr.Value {
	return NodeRepairConfig5Value{}
}

var _ basetypes.ObjectValuable = NodeRepairConfig5Value{}

type NodeRepairConfig5Value struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v NodeRepairConfig5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeRepairConfig5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeRepairConfig5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeRepairConfig5Value) String() string {
	return "NodeRepairConfig5Value"
}

func (v NodeRepairConfig5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v NodeRepairConfig5Value) Equal(o attr.Value) bool {
	other, ok := o.(NodeRepairConfig5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v NodeRepairConfig5Value) Type(ctx context.Context) attr.Type {
	return NodeRepairConfig5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeRepairConfig5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Placement5Type{}

type Placement5Type struct {
	basetypes.ObjectType
}

func (t Placement5Type) Equal(o attr.Type) bool {
	other, ok := o.(Placement5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Placement5Type) String() string {
	return "Placement5Type"
}

func (t Placement5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Placement5Value{
		Group: groupVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlacement5ValueNull() Placement5Value {
	return Placement5Value{
		state: attr.ValueStateNull,
	}
}

func NewPlacement5ValueUnknown() Placement5Value {
	return Placement5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPlacement5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Placement5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Placement5Value Attribute Value",
				"While creating a Placement5Value value, a missing attribute value was detected. "+
					"A Placement5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Placement5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Placement5Value Attribute Type",
				"While creating a Placement5Value value, an invalid attribute value was detected. "+
					"A Placement5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Placement5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Placement5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Placement5Value Attribute Value",
				"While creating a Placement5Value value, an extra attribute value was detected. "+
					"A Placement5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Placement5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlacement5ValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewPlacement5ValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	if diags.HasError() {
		return NewPlacement5ValueUnknown(), diags
	}

	return Placement5Value{
		Group: groupVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlacement5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Placement5Value {
	object, diags := NewPlacement5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlacement5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Placement5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlacement5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlacement5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlacement5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlacement5ValueMust(Placement5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Placement5Type) ValueType(ctx context.Context) attr.Value {
	return Placement5Value{}
}

var _ basetypes.ObjectValuable = Placement5Value{}

type Placement5Value struct {
	Group basetypes.StringValue `tfsdk:"group"`
	state attr.ValueState
}

func (v Placement5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Placement5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Placement5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Placement5Value) String() string {
	return "Placement5Value"
}

func (v Placement5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group": v.Group,
		})

	return objVal, diags
}

func (v Placement5Value) Equal(o attr.Value) bool {
	other, ok := o.(Placement5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	return true
}

func (v Placement5Value) Type(ctx context.Context) attr.Type {
	return Placement5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Placement5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroups5Type{}

type SecurityGroups5Type struct {
	basetypes.ObjectType
}

func (t SecurityGroups5Type) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroups5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroups5Type) String() string {
	return "SecurityGroups5Type"
}

func (t SecurityGroups5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachIdsAttribute, ok := attributes["attach_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_ids is missing from object`)

		return nil, diags
	}

	attachIdsVal, ok := attachIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_ids expected to be basetypes.ListValue, was: %T`, attachIdsAttribute))
	}

	withLocalAttribute, ok := attributes["with_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_local is missing from object`)

		return nil, diags
	}

	withLocalVal, ok := withLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_local expected to be basetypes.BoolValue, was: %T`, withLocalAttribute))
	}

	withSharedAttribute, ok := attributes["with_shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_shared is missing from object`)

		return nil, diags
	}

	withSharedVal, ok := withSharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_shared expected to be basetypes.BoolValue, was: %T`, withSharedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroups5Value{
		AttachIds:  attachIdsVal,
		WithLocal:  withLocalVal,
		WithShared: withSharedVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroups5ValueNull() SecurityGroups5Value {
	return SecurityGroups5Value{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroups5ValueUnknown() SecurityGroups5Value {
	return SecurityGroups5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroups5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroups5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroups5Value Attribute Value",
				"While creating a SecurityGroups5Value value, a missing attribute value was detected. "+
					"A SecurityGroups5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroups5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroups5Value Attribute Type",
				"While creating a SecurityGroups5Value value, an invalid attribute value was detected. "+
					"A SecurityGroups5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroups5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroups5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroups5Value Attribute Value",
				"While creating a SecurityGroups5Value value, an extra attribute value was detected. "+
					"A SecurityGroups5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroups5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroups5ValueUnknown(), diags
	}

	attachIdsAttribute, ok := attributes["attach_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_ids is missing from object`)

		return NewSecurityGroups5ValueUnknown(), diags
	}

	attachIdsVal, ok := attachIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_ids expected to be basetypes.ListValue, was: %T`, attachIdsAttribute))
	}

	withLocalAttribute, ok := attributes["with_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_local is missing from object`)

		return NewSecurityGroups5ValueUnknown(), diags
	}

	withLocalVal, ok := withLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_local expected to be basetypes.BoolValue, was: %T`, withLocalAttribute))
	}

	withSharedAttribute, ok := attributes["with_shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_shared is missing from object`)

		return NewSecurityGroups5ValueUnknown(), diags
	}

	withSharedVal, ok := withSharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_shared expected to be basetypes.BoolValue, was: %T`, withSharedAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroups5ValueUnknown(), diags
	}

	return SecurityGroups5Value{
		AttachIds:  attachIdsVal,
		WithLocal:  withLocalVal,
		WithShared: withSharedVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroups5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroups5Value {
	object, diags := NewSecurityGroups5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroups5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroups5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroups5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroups5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroups5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroups5ValueMust(SecurityGroups5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroups5Type) ValueType(ctx context.Context) attr.Value {
	return SecurityGroups5Value{}
}

var _ basetypes.ObjectValuable = SecurityGroups5Value{}

type SecurityGroups5Value struct {
	AttachIds  basetypes.ListValue `tfsdk:"attach_ids"`
	WithLocal  basetypes.BoolValue `tfsdk:"with_local"`
	WithShared basetypes.BoolValue `tfsdk:"with_shared"`
	state      attr.ValueState
}

func (v SecurityGroups5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["attach_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["with_local"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["with_shared"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AttachIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_ids"] = val

		val, err = v.WithLocal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_local"] = val

		val, err = v.WithShared.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_shared"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroups5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroups5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroups5Value) String() string {
	return "SecurityGroups5Value"
}

func (v SecurityGroups5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attachIdsVal basetypes.ListValue
	switch {
	case v.AttachIds.IsUnknown():
		attachIdsVal = types.ListUnknown(types.StringType)
	case v.AttachIds.IsNull():
		attachIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachIdsVal, d = types.ListValue(types.StringType, v.AttachIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"with_local":  basetypes.BoolType{},
			"with_shared": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"with_local":  basetypes.BoolType{},
		"with_shared": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_ids":  attachIdsVal,
			"with_local":  v.WithLocal,
			"with_shared": v.WithShared,
		})

	return objVal, diags
}

func (v SecurityGroups5Value) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroups5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachIds.Equal(other.AttachIds) {
		return false
	}

	if !v.WithLocal.Equal(other.WithLocal) {
		return false
	}

	if !v.WithShared.Equal(other.WithShared) {
		return false
	}

	return true
}

func (v SecurityGroups5Value) Type(ctx context.Context) attr.Type {
	return SecurityGroups5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroups5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"with_local":  basetypes.BoolType{},
		"with_shared": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ssh5Type{}

type Ssh5Type struct {
	basetypes.ObjectType
}

func (t Ssh5Type) Equal(o attr.Type) bool {
	other, ok := o.(Ssh5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ssh5Type) String() string {
	return "Ssh5Type"
}

func (t Ssh5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return nil, diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	enableSsmAttribute, ok := attributes["enable_ssm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ssm is missing from object`)

		return nil, diags
	}

	enableSsmVal, ok := enableSsmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ssm expected to be basetypes.BoolValue, was: %T`, enableSsmAttribute))
	}

	publicKeyAttribute, ok := attributes["public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key is missing from object`)

		return nil, diags
	}

	publicKeyVal, ok := publicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key expected to be basetypes.StringValue, was: %T`, publicKeyAttribute))
	}

	publicKeyNameAttribute, ok := attributes["public_key_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key_name is missing from object`)

		return nil, diags
	}

	publicKeyNameVal, ok := publicKeyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key_name expected to be basetypes.StringValue, was: %T`, publicKeyNameAttribute))
	}

	sourceSecurityGroupIdsAttribute, ok := attributes["source_security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_security_group_ids is missing from object`)

		return nil, diags
	}

	sourceSecurityGroupIdsVal, ok := sourceSecurityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_security_group_ids expected to be basetypes.ListValue, was: %T`, sourceSecurityGroupIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ssh5Value{
		Allow:                  allowVal,
		EnableSsm:              enableSsmVal,
		PublicKey:              publicKeyVal,
		PublicKeyName:          publicKeyNameVal,
		SourceSecurityGroupIds: sourceSecurityGroupIdsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSsh5ValueNull() Ssh5Value {
	return Ssh5Value{
		state: attr.ValueStateNull,
	}
}

func NewSsh5ValueUnknown() Ssh5Value {
	return Ssh5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSsh5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ssh5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ssh5Value Attribute Value",
				"While creating a Ssh5Value value, a missing attribute value was detected. "+
					"A Ssh5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ssh5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ssh5Value Attribute Type",
				"While creating a Ssh5Value value, an invalid attribute value was detected. "+
					"A Ssh5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ssh5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ssh5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ssh5Value Attribute Value",
				"While creating a Ssh5Value value, an extra attribute value was detected. "+
					"A Ssh5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ssh5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSsh5ValueUnknown(), diags
	}

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return NewSsh5ValueUnknown(), diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	enableSsmAttribute, ok := attributes["enable_ssm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ssm is missing from object`)

		return NewSsh5ValueUnknown(), diags
	}

	enableSsmVal, ok := enableSsmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ssm expected to be basetypes.BoolValue, was: %T`, enableSsmAttribute))
	}

	publicKeyAttribute, ok := attributes["public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key is missing from object`)

		return NewSsh5ValueUnknown(), diags
	}

	publicKeyVal, ok := publicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key expected to be basetypes.StringValue, was: %T`, publicKeyAttribute))
	}

	publicKeyNameAttribute, ok := attributes["public_key_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key_name is missing from object`)

		return NewSsh5ValueUnknown(), diags
	}

	publicKeyNameVal, ok := publicKeyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key_name expected to be basetypes.StringValue, was: %T`, publicKeyNameAttribute))
	}

	sourceSecurityGroupIdsAttribute, ok := attributes["source_security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_security_group_ids is missing from object`)

		return NewSsh5ValueUnknown(), diags
	}

	sourceSecurityGroupIdsVal, ok := sourceSecurityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_security_group_ids expected to be basetypes.ListValue, was: %T`, sourceSecurityGroupIdsAttribute))
	}

	if diags.HasError() {
		return NewSsh5ValueUnknown(), diags
	}

	return Ssh5Value{
		Allow:                  allowVal,
		EnableSsm:              enableSsmVal,
		PublicKey:              publicKeyVal,
		PublicKeyName:          publicKeyNameVal,
		SourceSecurityGroupIds: sourceSecurityGroupIdsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSsh5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ssh5Value {
	object, diags := NewSsh5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSsh5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ssh5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSsh5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSsh5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSsh5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSsh5ValueMust(Ssh5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ssh5Type) ValueType(ctx context.Context) attr.Value {
	return Ssh5Value{}
}

var _ basetypes.ObjectValuable = Ssh5Value{}

type Ssh5Value struct {
	Allow                  basetypes.BoolValue   `tfsdk:"allow"`
	EnableSsm              basetypes.BoolValue   `tfsdk:"enable_ssm"`
	PublicKey              basetypes.StringValue `tfsdk:"public_key"`
	PublicKeyName          basetypes.StringValue `tfsdk:"public_key_name"`
	SourceSecurityGroupIds basetypes.ListValue   `tfsdk:"source_security_group_ids"`
	state                  attr.ValueState
}

func (v Ssh5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["allow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_ssm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["public_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["public_key_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_security_group_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Allow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow"] = val

		val, err = v.EnableSsm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ssm"] = val

		val, err = v.PublicKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_key"] = val

		val, err = v.PublicKeyName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_key_name"] = val

		val, err = v.SourceSecurityGroupIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_security_group_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ssh5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ssh5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ssh5Value) String() string {
	return "Ssh5Value"
}

func (v Ssh5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceSecurityGroupIdsVal basetypes.ListValue
	switch {
	case v.SourceSecurityGroupIds.IsUnknown():
		sourceSecurityGroupIdsVal = types.ListUnknown(types.StringType)
	case v.SourceSecurityGroupIds.IsNull():
		sourceSecurityGroupIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		sourceSecurityGroupIdsVal, d = types.ListValue(types.StringType, v.SourceSecurityGroupIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow":           basetypes.BoolType{},
			"enable_ssm":      basetypes.BoolType{},
			"public_key":      basetypes.StringType{},
			"public_key_name": basetypes.StringType{},
			"source_security_group_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow":           basetypes.BoolType{},
		"enable_ssm":      basetypes.BoolType{},
		"public_key":      basetypes.StringType{},
		"public_key_name": basetypes.StringType{},
		"source_security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow":                     v.Allow,
			"enable_ssm":                v.EnableSsm,
			"public_key":                v.PublicKey,
			"public_key_name":           v.PublicKeyName,
			"source_security_group_ids": sourceSecurityGroupIdsVal,
		})

	return objVal, diags
}

func (v Ssh5Value) Equal(o attr.Value) bool {
	other, ok := o.(Ssh5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Allow.Equal(other.Allow) {
		return false
	}

	if !v.EnableSsm.Equal(other.EnableSsm) {
		return false
	}

	if !v.PublicKey.Equal(other.PublicKey) {
		return false
	}

	if !v.PublicKeyName.Equal(other.PublicKeyName) {
		return false
	}

	if !v.SourceSecurityGroupIds.Equal(other.SourceSecurityGroupIds) {
		return false
	}

	return true
}

func (v Ssh5Value) Type(ctx context.Context) attr.Type {
	return Ssh5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ssh5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow":           basetypes.BoolType{},
		"enable_ssm":      basetypes.BoolType{},
		"public_key":      basetypes.StringType{},
		"public_key_name": basetypes.StringType{},
		"source_security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Taints5Type{}

type Taints5Type struct {
	basetypes.ObjectType
}

func (t Taints5Type) Equal(o attr.Type) bool {
	other, ok := o.(Taints5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Taints5Type) String() string {
	return "Taints5Type"
}

func (t Taints5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Taints5Value{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaints5ValueNull() Taints5Value {
	return Taints5Value{
		state: attr.ValueStateNull,
	}
}

func NewTaints5ValueUnknown() Taints5Value {
	return Taints5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTaints5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Taints5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Taints5Value Attribute Value",
				"While creating a Taints5Value value, a missing attribute value was detected. "+
					"A Taints5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Taints5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Taints5Value Attribute Type",
				"While creating a Taints5Value value, an invalid attribute value was detected. "+
					"A Taints5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Taints5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Taints5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Taints5Value Attribute Value",
				"While creating a Taints5Value value, an extra attribute value was detected. "+
					"A Taints5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Taints5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaints5ValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTaints5ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTaints5ValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTaints5ValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTaints5ValueUnknown(), diags
	}

	return Taints5Value{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaints5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Taints5Value {
	object, diags := NewTaints5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaints5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Taints5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaints5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaints5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaints5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaints5ValueMust(Taints5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Taints5Type) ValueType(ctx context.Context) attr.Value {
	return Taints5Value{}
}

var _ basetypes.ObjectValuable = Taints5Value{}

type Taints5Value struct {
	Effect basetypes.StringValue `tfsdk:"effect"`
	Key    basetypes.StringValue `tfsdk:"key"`
	Value  basetypes.StringValue `tfsdk:"value"`
	state  attr.ValueState
}

func (v Taints5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Taints5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Taints5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Taints5Value) String() string {
	return "Taints5Value"
}

func (v Taints5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect": v.Effect,
			"key":    v.Key,
			"value":  v.Value,
		})

	return objVal, diags
}

func (v Taints5Value) Equal(o attr.Value) bool {
	other, ok := o.(Taints5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v Taints5Value) Type(ctx context.Context) attr.Type {
	return Taints5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Taints5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = UpdateConfig5Type{}

type UpdateConfig5Type struct {
	basetypes.ObjectType
}

func (t UpdateConfig5Type) Equal(o attr.Type) bool {
	other, ok := o.(UpdateConfig5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UpdateConfig5Type) String() string {
	return "UpdateConfig5Type"
}

func (t UpdateConfig5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxUnavailableAttribute, ok := attributes["max_unavailable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable is missing from object`)

		return nil, diags
	}

	maxUnavailableVal, ok := maxUnavailableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable expected to be basetypes.Int64Value, was: %T`, maxUnavailableAttribute))
	}

	maxUnavailablePercentageAttribute, ok := attributes["max_unavailable_percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable_percentage is missing from object`)

		return nil, diags
	}

	maxUnavailablePercentageVal, ok := maxUnavailablePercentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable_percentage expected to be basetypes.Int64Value, was: %T`, maxUnavailablePercentageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UpdateConfig5Value{
		MaxUnavailable:           maxUnavailableVal,
		MaxUnavailablePercentage: maxUnavailablePercentageVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewUpdateConfig5ValueNull() UpdateConfig5Value {
	return UpdateConfig5Value{
		state: attr.ValueStateNull,
	}
}

func NewUpdateConfig5ValueUnknown() UpdateConfig5Value {
	return UpdateConfig5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewUpdateConfig5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UpdateConfig5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UpdateConfig5Value Attribute Value",
				"While creating a UpdateConfig5Value value, a missing attribute value was detected. "+
					"A UpdateConfig5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UpdateConfig5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UpdateConfig5Value Attribute Type",
				"While creating a UpdateConfig5Value value, an invalid attribute value was detected. "+
					"A UpdateConfig5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UpdateConfig5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UpdateConfig5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UpdateConfig5Value Attribute Value",
				"While creating a UpdateConfig5Value value, an extra attribute value was detected. "+
					"A UpdateConfig5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UpdateConfig5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUpdateConfig5ValueUnknown(), diags
	}

	maxUnavailableAttribute, ok := attributes["max_unavailable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable is missing from object`)

		return NewUpdateConfig5ValueUnknown(), diags
	}

	maxUnavailableVal, ok := maxUnavailableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable expected to be basetypes.Int64Value, was: %T`, maxUnavailableAttribute))
	}

	maxUnavailablePercentageAttribute, ok := attributes["max_unavailable_percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable_percentage is missing from object`)

		return NewUpdateConfig5ValueUnknown(), diags
	}

	maxUnavailablePercentageVal, ok := maxUnavailablePercentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable_percentage expected to be basetypes.Int64Value, was: %T`, maxUnavailablePercentageAttribute))
	}

	if diags.HasError() {
		return NewUpdateConfig5ValueUnknown(), diags
	}

	return UpdateConfig5Value{
		MaxUnavailable:           maxUnavailableVal,
		MaxUnavailablePercentage: maxUnavailablePercentageVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewUpdateConfig5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UpdateConfig5Value {
	object, diags := NewUpdateConfig5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUpdateConfig5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UpdateConfig5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUpdateConfig5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUpdateConfig5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUpdateConfig5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUpdateConfig5ValueMust(UpdateConfig5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t UpdateConfig5Type) ValueType(ctx context.Context) attr.Value {
	return UpdateConfig5Value{}
}

var _ basetypes.ObjectValuable = UpdateConfig5Value{}

type UpdateConfig5Value struct {
	MaxUnavailable           basetypes.Int64Value `tfsdk:"max_unavailable"`
	MaxUnavailablePercentage basetypes.Int64Value `tfsdk:"max_unavailable_percentage"`
	state                    attr.ValueState
}

func (v UpdateConfig5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["max_unavailable"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_unavailable_percentage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MaxUnavailable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavailable"] = val

		val, err = v.MaxUnavailablePercentage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavailable_percentage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UpdateConfig5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UpdateConfig5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UpdateConfig5Value) String() string {
	return "UpdateConfig5Value"
}

func (v UpdateConfig5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_unavailable":            basetypes.Int64Type{},
		"max_unavailable_percentage": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_unavailable":            v.MaxUnavailable,
			"max_unavailable_percentage": v.MaxUnavailablePercentage,
		})

	return objVal, diags
}

func (v UpdateConfig5Value) Equal(o attr.Value) bool {
	other, ok := o.(UpdateConfig5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxUnavailable.Equal(other.MaxUnavailable) {
		return false
	}

	if !v.MaxUnavailablePercentage.Equal(other.MaxUnavailablePercentage) {
		return false
	}

	return true
}

func (v UpdateConfig5Value) Type(ctx context.Context) attr.Type {
	return UpdateConfig5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UpdateConfig5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_unavailable":            basetypes.Int64Type{},
		"max_unavailable_percentage": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = NodeGroupsMapType{}

type NodeGroupsMapType struct {
	basetypes.ObjectType
}

func (t NodeGroupsMapType) Equal(o attr.Type) bool {
	other, ok := o.(NodeGroupsMapType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeGroupsMapType) String() string {
	return "NodeGroupsMapType"
}

func (t NodeGroupsMapType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return nil, diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return nil, diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	asgMetricsCollection6Attribute, ok := attributes["asg_metrics_collection6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_metrics_collection6 is missing from object`)

		return nil, diags
	}

	asgMetricsCollection6Val, ok := asgMetricsCollection6Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_metrics_collection6 expected to be basetypes.SetValue, was: %T`, asgMetricsCollection6Attribute))
	}

	asgSuspendProcessesAttribute, ok := attributes["asg_suspend_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_suspend_processes is missing from object`)

		return nil, diags
	}

	asgSuspendProcessesVal, ok := asgSuspendProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_suspend_processes expected to be basetypes.ListValue, was: %T`, asgSuspendProcessesAttribute))
	}

	availabilityZones2Attribute, ok := attributes["availability_zones2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones2 is missing from object`)

		return nil, diags
	}

	availabilityZones2Val, ok := availabilityZones2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones2 expected to be basetypes.ListValue, was: %T`, availabilityZones2Attribute))
	}

	bottleRocket6Attribute, ok := attributes["bottle_rocket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bottle_rocket6 is missing from object`)

		return nil, diags
	}

	bottleRocket6Val, ok := bottleRocket6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bottle_rocket6 expected to be basetypes.ObjectValue, was: %T`, bottleRocket6Attribute))
	}

	classicLoadBalancerNamesAttribute, ok := attributes["classic_load_balancer_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`classic_load_balancer_names is missing from object`)

		return nil, diags
	}

	classicLoadBalancerNamesVal, ok := classicLoadBalancerNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`classic_load_balancer_names expected to be basetypes.ListValue, was: %T`, classicLoadBalancerNamesAttribute))
	}

	clusterDnsAttribute, ok := attributes["cluster_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_dns is missing from object`)

		return nil, diags
	}

	clusterDnsVal, ok := clusterDnsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_dns expected to be basetypes.StringValue, was: %T`, clusterDnsAttribute))
	}

	cpuCreditsAttribute, ok := attributes["cpu_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_credits is missing from object`)

		return nil, diags
	}

	cpuCreditsVal, ok := cpuCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_credits expected to be basetypes.StringValue, was: %T`, cpuCreditsAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return nil, diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return nil, diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return nil, diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	ebsOptimizedAttribute, ok := attributes["ebs_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_optimized is missing from object`)

		return nil, diags
	}

	ebsOptimizedVal, ok := ebsOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_optimized expected to be basetypes.BoolValue, was: %T`, ebsOptimizedAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return nil, diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	enableDetailedMonitoringAttribute, ok := attributes["enable_detailed_monitoring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_detailed_monitoring is missing from object`)

		return nil, diags
	}

	enableDetailedMonitoringVal, ok := enableDetailedMonitoringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_detailed_monitoring expected to be basetypes.BoolValue, was: %T`, enableDetailedMonitoringAttribute))
	}

	iam6Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam6 is missing from object`)

		return nil, diags
	}

	iam6Val, ok := iam6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam6 expected to be basetypes.ObjectValue, was: %T`, iam6Attribute))
	}

	instanceNameAttribute, ok := attributes["instance_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_name is missing from object`)

		return nil, diags
	}

	instanceNameVal, ok := instanceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_name expected to be basetypes.StringValue, was: %T`, instanceNameAttribute))
	}

	instancePrefixAttribute, ok := attributes["instance_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_prefix is missing from object`)

		return nil, diags
	}

	instancePrefixVal, ok := instancePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_prefix expected to be basetypes.StringValue, was: %T`, instancePrefixAttribute))
	}

	instanceSelector6Attribute, ok := attributes["instance_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_selector6 is missing from object`)

		return nil, diags
	}

	instanceSelector6Val, ok := instanceSelector6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_selector6 expected to be basetypes.ObjectValue, was: %T`, instanceSelector6Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return nil, diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	instancesDistribution6Attribute, ok := attributes["instances_distribution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instances_distribution6 is missing from object`)

		return nil, diags
	}

	instancesDistribution6Val, ok := instancesDistribution6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instances_distribution6 expected to be basetypes.ObjectValue, was: %T`, instancesDistribution6Attribute))
	}

	kubeletExtraConfig6Attribute, ok := attributes["kubelet_extra_config6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubelet_extra_config6 is missing from object`)

		return nil, diags
	}

	kubeletExtraConfig6Val, ok := kubeletExtraConfig6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubelet_extra_config6 expected to be basetypes.ObjectValue, was: %T`, kubeletExtraConfig6Attribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return nil, diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	overrideBootstrapCommandAttribute, ok := attributes["override_bootstrap_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_bootstrap_command is missing from object`)

		return nil, diags
	}

	overrideBootstrapCommandVal, ok := overrideBootstrapCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_bootstrap_command expected to be basetypes.StringValue, was: %T`, overrideBootstrapCommandAttribute))
	}

	placement6Attribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement6 is missing from object`)

		return nil, diags
	}

	placement6Val, ok := placement6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement6 expected to be basetypes.ObjectValue, was: %T`, placement6Attribute))
	}

	preBootstrapCommandsAttribute, ok := attributes["pre_bootstrap_commands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_bootstrap_commands is missing from object`)

		return nil, diags
	}

	preBootstrapCommandsVal, ok := preBootstrapCommandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_bootstrap_commands expected to be basetypes.ListValue, was: %T`, preBootstrapCommandsAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return nil, diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	securityGroups6Attribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups6 is missing from object`)

		return nil, diags
	}

	securityGroups6Val, ok := securityGroups6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups6 expected to be basetypes.ObjectValue, was: %T`, securityGroups6Attribute))
	}

	ssh6Attribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh6 is missing from object`)

		return nil, diags
	}

	ssh6Val, ok := ssh6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh6 expected to be basetypes.ObjectValue, was: %T`, ssh6Attribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.SetValue, was: %T`, subnetsAttribute))
	}

	tags2Attribute, ok := attributes["tags2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags2 is missing from object`)

		return nil, diags
	}

	tags2Val, ok := tags2Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags2 expected to be basetypes.MapValue, was: %T`, tags2Attribute))
	}

	taints6Attribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints6 is missing from object`)

		return nil, diags
	}

	taints6Val, ok := taints6Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints6 expected to be basetypes.SetValue, was: %T`, taints6Attribute))
	}

	targetGroupArnsAttribute, ok := attributes["target_group_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_group_arns is missing from object`)

		return nil, diags
	}

	targetGroupArnsVal, ok := targetGroupArnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_group_arns expected to be basetypes.ListValue, was: %T`, targetGroupArnsAttribute))
	}

	updateConfig6Attribute, ok := attributes["update_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update_config6 is missing from object`)

		return nil, diags
	}

	updateConfig6Val, ok := updateConfig6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update_config6 expected to be basetypes.ObjectValue, was: %T`, updateConfig6Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return nil, diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return nil, diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeKmsKeyIdAttribute, ok := attributes["volume_kms_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_kms_key_id is missing from object`)

		return nil, diags
	}

	volumeKmsKeyIdVal, ok := volumeKmsKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_kms_key_id expected to be basetypes.StringValue, was: %T`, volumeKmsKeyIdAttribute))
	}

	volumeNameAttribute, ok := attributes["volume_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_name is missing from object`)

		return nil, diags
	}

	volumeNameVal, ok := volumeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_name expected to be basetypes.StringValue, was: %T`, volumeNameAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return nil, diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeGroupsMapValue{
		Ami:                      amiVal,
		AmiFamily:                amiFamilyVal,
		AsgMetricsCollection6:    asgMetricsCollection6Val,
		AsgSuspendProcesses:      asgSuspendProcessesVal,
		AvailabilityZones2:       availabilityZones2Val,
		BottleRocket6:            bottleRocket6Val,
		ClassicLoadBalancerNames: classicLoadBalancerNamesVal,
		ClusterDns:               clusterDnsVal,
		CpuCredits:               cpuCreditsVal,
		DesiredCapacity:          desiredCapacityVal,
		DisableImdsv1:            disableImdsv1Val,
		DisablePodsImds:          disablePodsImdsVal,
		EbsOptimized:             ebsOptimizedVal,
		EfaEnabled:               efaEnabledVal,
		EnableDetailedMonitoring: enableDetailedMonitoringVal,
		Iam6:                     iam6Val,
		InstanceName:             instanceNameVal,
		InstancePrefix:           instancePrefixVal,
		InstanceSelector6:        instanceSelector6Val,
		InstanceType:             instanceTypeVal,
		InstancesDistribution6:   instancesDistribution6Val,
		KubeletExtraConfig6:      kubeletExtraConfig6Val,
		Labels:                   labelsVal,
		MaxPodsPerNode:           maxPodsPerNodeVal,
		MaxSize:                  maxSizeVal,
		MinSize:                  minSizeVal,
		OverrideBootstrapCommand: overrideBootstrapCommandVal,
		Placement6:               placement6Val,
		PreBootstrapCommands:     preBootstrapCommandsVal,
		PrivateNetworking:        privateNetworkingVal,
		SecurityGroups6:          securityGroups6Val,
		Ssh6:                     ssh6Val,
		SubnetCidr:               subnetCidrVal,
		Subnets:                  subnetsVal,
		Tags2:                    tags2Val,
		Taints6:                  taints6Val,
		TargetGroupArns:          targetGroupArnsVal,
		UpdateConfig6:            updateConfig6Val,
		Version:                  versionVal,
		VolumeEncrypted:          volumeEncryptedVal,
		VolumeIops:               volumeIopsVal,
		VolumeKmsKeyId:           volumeKmsKeyIdVal,
		VolumeName:               volumeNameVal,
		VolumeSize:               volumeSizeVal,
		VolumeThroughput:         volumeThroughputVal,
		VolumeType:               volumeTypeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsMapValueNull() NodeGroupsMapValue {
	return NodeGroupsMapValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeGroupsMapValueUnknown() NodeGroupsMapValue {
	return NodeGroupsMapValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeGroupsMapValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeGroupsMapValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeGroupsMapValue Attribute Value",
				"While creating a NodeGroupsMapValue value, a missing attribute value was detected. "+
					"A NodeGroupsMapValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeGroupsMapValue Attribute Type",
				"While creating a NodeGroupsMapValue value, an invalid attribute value was detected. "+
					"A NodeGroupsMapValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeGroupsMapValue Attribute Value",
				"While creating a NodeGroupsMapValue value, an extra attribute value was detected. "+
					"A NodeGroupsMapValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeGroupsMapValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeGroupsMapValueUnknown(), diags
	}

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	asgMetricsCollection6Attribute, ok := attributes["asg_metrics_collection6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_metrics_collection6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	asgMetricsCollection6Val, ok := asgMetricsCollection6Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_metrics_collection6 expected to be basetypes.SetValue, was: %T`, asgMetricsCollection6Attribute))
	}

	asgSuspendProcessesAttribute, ok := attributes["asg_suspend_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_suspend_processes is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	asgSuspendProcessesVal, ok := asgSuspendProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_suspend_processes expected to be basetypes.ListValue, was: %T`, asgSuspendProcessesAttribute))
	}

	availabilityZones2Attribute, ok := attributes["availability_zones2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones2 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	availabilityZones2Val, ok := availabilityZones2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones2 expected to be basetypes.ListValue, was: %T`, availabilityZones2Attribute))
	}

	bottleRocket6Attribute, ok := attributes["bottle_rocket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bottle_rocket6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	bottleRocket6Val, ok := bottleRocket6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bottle_rocket6 expected to be basetypes.ObjectValue, was: %T`, bottleRocket6Attribute))
	}

	classicLoadBalancerNamesAttribute, ok := attributes["classic_load_balancer_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`classic_load_balancer_names is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	classicLoadBalancerNamesVal, ok := classicLoadBalancerNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`classic_load_balancer_names expected to be basetypes.ListValue, was: %T`, classicLoadBalancerNamesAttribute))
	}

	clusterDnsAttribute, ok := attributes["cluster_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_dns is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	clusterDnsVal, ok := clusterDnsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_dns expected to be basetypes.StringValue, was: %T`, clusterDnsAttribute))
	}

	cpuCreditsAttribute, ok := attributes["cpu_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_credits is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	cpuCreditsVal, ok := cpuCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_credits expected to be basetypes.StringValue, was: %T`, cpuCreditsAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	ebsOptimizedAttribute, ok := attributes["ebs_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_optimized is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	ebsOptimizedVal, ok := ebsOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_optimized expected to be basetypes.BoolValue, was: %T`, ebsOptimizedAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	enableDetailedMonitoringAttribute, ok := attributes["enable_detailed_monitoring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_detailed_monitoring is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	enableDetailedMonitoringVal, ok := enableDetailedMonitoringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_detailed_monitoring expected to be basetypes.BoolValue, was: %T`, enableDetailedMonitoringAttribute))
	}

	iam6Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	iam6Val, ok := iam6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam6 expected to be basetypes.ObjectValue, was: %T`, iam6Attribute))
	}

	instanceNameAttribute, ok := attributes["instance_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_name is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	instanceNameVal, ok := instanceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_name expected to be basetypes.StringValue, was: %T`, instanceNameAttribute))
	}

	instancePrefixAttribute, ok := attributes["instance_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_prefix is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	instancePrefixVal, ok := instancePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_prefix expected to be basetypes.StringValue, was: %T`, instancePrefixAttribute))
	}

	instanceSelector6Attribute, ok := attributes["instance_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_selector6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	instanceSelector6Val, ok := instanceSelector6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_selector6 expected to be basetypes.ObjectValue, was: %T`, instanceSelector6Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	instancesDistribution6Attribute, ok := attributes["instances_distribution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instances_distribution6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	instancesDistribution6Val, ok := instancesDistribution6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instances_distribution6 expected to be basetypes.ObjectValue, was: %T`, instancesDistribution6Attribute))
	}

	kubeletExtraConfig6Attribute, ok := attributes["kubelet_extra_config6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubelet_extra_config6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	kubeletExtraConfig6Val, ok := kubeletExtraConfig6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubelet_extra_config6 expected to be basetypes.ObjectValue, was: %T`, kubeletExtraConfig6Attribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	overrideBootstrapCommandAttribute, ok := attributes["override_bootstrap_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_bootstrap_command is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	overrideBootstrapCommandVal, ok := overrideBootstrapCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_bootstrap_command expected to be basetypes.StringValue, was: %T`, overrideBootstrapCommandAttribute))
	}

	placement6Attribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	placement6Val, ok := placement6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement6 expected to be basetypes.ObjectValue, was: %T`, placement6Attribute))
	}

	preBootstrapCommandsAttribute, ok := attributes["pre_bootstrap_commands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_bootstrap_commands is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	preBootstrapCommandsVal, ok := preBootstrapCommandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_bootstrap_commands expected to be basetypes.ListValue, was: %T`, preBootstrapCommandsAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	securityGroups6Attribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	securityGroups6Val, ok := securityGroups6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups6 expected to be basetypes.ObjectValue, was: %T`, securityGroups6Attribute))
	}

	ssh6Attribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	ssh6Val, ok := ssh6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh6 expected to be basetypes.ObjectValue, was: %T`, ssh6Attribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.SetValue, was: %T`, subnetsAttribute))
	}

	tags2Attribute, ok := attributes["tags2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags2 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	tags2Val, ok := tags2Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags2 expected to be basetypes.MapValue, was: %T`, tags2Attribute))
	}

	taints6Attribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	taints6Val, ok := taints6Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints6 expected to be basetypes.SetValue, was: %T`, taints6Attribute))
	}

	targetGroupArnsAttribute, ok := attributes["target_group_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_group_arns is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	targetGroupArnsVal, ok := targetGroupArnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_group_arns expected to be basetypes.ListValue, was: %T`, targetGroupArnsAttribute))
	}

	updateConfig6Attribute, ok := attributes["update_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update_config6 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	updateConfig6Val, ok := updateConfig6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update_config6 expected to be basetypes.ObjectValue, was: %T`, updateConfig6Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeKmsKeyIdAttribute, ok := attributes["volume_kms_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_kms_key_id is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeKmsKeyIdVal, ok := volumeKmsKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_kms_key_id expected to be basetypes.StringValue, was: %T`, volumeKmsKeyIdAttribute))
	}

	volumeNameAttribute, ok := attributes["volume_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_name is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeNameVal, ok := volumeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_name expected to be basetypes.StringValue, was: %T`, volumeNameAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewNodeGroupsMapValueUnknown(), diags
	}

	return NodeGroupsMapValue{
		Ami:                      amiVal,
		AmiFamily:                amiFamilyVal,
		AsgMetricsCollection6:    asgMetricsCollection6Val,
		AsgSuspendProcesses:      asgSuspendProcessesVal,
		AvailabilityZones2:       availabilityZones2Val,
		BottleRocket6:            bottleRocket6Val,
		ClassicLoadBalancerNames: classicLoadBalancerNamesVal,
		ClusterDns:               clusterDnsVal,
		CpuCredits:               cpuCreditsVal,
		DesiredCapacity:          desiredCapacityVal,
		DisableImdsv1:            disableImdsv1Val,
		DisablePodsImds:          disablePodsImdsVal,
		EbsOptimized:             ebsOptimizedVal,
		EfaEnabled:               efaEnabledVal,
		EnableDetailedMonitoring: enableDetailedMonitoringVal,
		Iam6:                     iam6Val,
		InstanceName:             instanceNameVal,
		InstancePrefix:           instancePrefixVal,
		InstanceSelector6:        instanceSelector6Val,
		InstanceType:             instanceTypeVal,
		InstancesDistribution6:   instancesDistribution6Val,
		KubeletExtraConfig6:      kubeletExtraConfig6Val,
		Labels:                   labelsVal,
		MaxPodsPerNode:           maxPodsPerNodeVal,
		MaxSize:                  maxSizeVal,
		MinSize:                  minSizeVal,
		OverrideBootstrapCommand: overrideBootstrapCommandVal,
		Placement6:               placement6Val,
		PreBootstrapCommands:     preBootstrapCommandsVal,
		PrivateNetworking:        privateNetworkingVal,
		SecurityGroups6:          securityGroups6Val,
		Ssh6:                     ssh6Val,
		SubnetCidr:               subnetCidrVal,
		Subnets:                  subnetsVal,
		Tags2:                    tags2Val,
		Taints6:                  taints6Val,
		TargetGroupArns:          targetGroupArnsVal,
		UpdateConfig6:            updateConfig6Val,
		Version:                  versionVal,
		VolumeEncrypted:          volumeEncryptedVal,
		VolumeIops:               volumeIopsVal,
		VolumeKmsKeyId:           volumeKmsKeyIdVal,
		VolumeName:               volumeNameVal,
		VolumeSize:               volumeSizeVal,
		VolumeThroughput:         volumeThroughputVal,
		VolumeType:               volumeTypeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsMapValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeGroupsMapValue {
	object, diags := NewNodeGroupsMapValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeGroupsMapValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeGroupsMapType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeGroupsMapValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeGroupsMapValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeGroupsMapValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeGroupsMapValueMust(NodeGroupsMapValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeGroupsMapType) ValueType(ctx context.Context) attr.Value {
	return NodeGroupsMapValue{}
}

var _ basetypes.ObjectValuable = NodeGroupsMapValue{}

type NodeGroupsMapValue struct {
	Ami                      basetypes.StringValue `tfsdk:"ami"`
	AmiFamily                basetypes.StringValue `tfsdk:"ami_family"`
	AsgMetricsCollection6    basetypes.SetValue    `tfsdk:"asg_metrics_collection6"`
	AsgSuspendProcesses      basetypes.ListValue   `tfsdk:"asg_suspend_processes"`
	AvailabilityZones2       basetypes.ListValue   `tfsdk:"availability_zones2"`
	BottleRocket6            basetypes.ObjectValue `tfsdk:"bottle_rocket"`
	ClassicLoadBalancerNames basetypes.ListValue   `tfsdk:"classic_load_balancer_names"`
	ClusterDns               basetypes.StringValue `tfsdk:"cluster_dns"`
	CpuCredits               basetypes.StringValue `tfsdk:"cpu_credits"`
	DesiredCapacity          basetypes.Int64Value  `tfsdk:"desired_capacity"`
	DisableImdsv1            basetypes.BoolValue   `tfsdk:"disable_imdsv1"`
	DisablePodsImds          basetypes.BoolValue   `tfsdk:"disable_pods_imds"`
	EbsOptimized             basetypes.BoolValue   `tfsdk:"ebs_optimized"`
	EfaEnabled               basetypes.BoolValue   `tfsdk:"efa_enabled"`
	EnableDetailedMonitoring basetypes.BoolValue   `tfsdk:"enable_detailed_monitoring"`
	Iam6                     basetypes.ObjectValue `tfsdk:"iam"`
	InstanceName             basetypes.StringValue `tfsdk:"instance_name"`
	InstancePrefix           basetypes.StringValue `tfsdk:"instance_prefix"`
	InstanceSelector6        basetypes.ObjectValue `tfsdk:"instance_selector"`
	InstanceType             basetypes.StringValue `tfsdk:"instance_type"`
	InstancesDistribution6   basetypes.ObjectValue `tfsdk:"instances_distribution"`
	KubeletExtraConfig6      basetypes.ObjectValue `tfsdk:"kubelet_extra_config6"`
	Labels                   basetypes.MapValue    `tfsdk:"labels"`
	MaxPodsPerNode           basetypes.Int64Value  `tfsdk:"max_pods_per_node"`
	MaxSize                  basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize                  basetypes.Int64Value  `tfsdk:"min_size"`
	OverrideBootstrapCommand basetypes.StringValue `tfsdk:"override_bootstrap_command"`
	Placement6               basetypes.ObjectValue `tfsdk:"placement"`
	PreBootstrapCommands     basetypes.ListValue   `tfsdk:"pre_bootstrap_commands"`
	PrivateNetworking        basetypes.BoolValue   `tfsdk:"private_networking"`
	SecurityGroups6          basetypes.ObjectValue `tfsdk:"security_groups"`
	Ssh6                     basetypes.ObjectValue `tfsdk:"ssh"`
	SubnetCidr               basetypes.StringValue `tfsdk:"subnet_cidr"`
	Subnets                  basetypes.SetValue    `tfsdk:"subnets"`
	Tags2                    basetypes.MapValue    `tfsdk:"tags2"`
	Taints6                  basetypes.SetValue    `tfsdk:"taints"`
	TargetGroupArns          basetypes.ListValue   `tfsdk:"target_group_arns"`
	UpdateConfig6            basetypes.ObjectValue `tfsdk:"update_config"`
	Version                  basetypes.StringValue `tfsdk:"version"`
	VolumeEncrypted          basetypes.BoolValue   `tfsdk:"volume_encrypted"`
	VolumeIops               basetypes.Int64Value  `tfsdk:"volume_iops"`
	VolumeKmsKeyId           basetypes.StringValue `tfsdk:"volume_kms_key_id"`
	VolumeName               basetypes.StringValue `tfsdk:"volume_name"`
	VolumeSize               basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeThroughput         basetypes.Int64Value  `tfsdk:"volume_throughput"`
	VolumeType               basetypes.StringValue `tfsdk:"volume_type"`
	state                    attr.ValueState
}

func (v NodeGroupsMapValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 46)

	var val tftypes.Value
	var err error

	attrTypes["ami"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ami_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["asg_metrics_collection6"] = basetypes.SetType{
		ElemType: AsgMetricsCollection6Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["asg_suspend_processes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["availability_zones2"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["bottle_rocket"] = basetypes.ObjectType{
		AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["classic_load_balancer_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["cluster_dns"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpu_credits"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["desired_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_imdsv1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_pods_imds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs_optimized"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_detailed_monitoring"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ObjectType{
		AttrTypes: Iam6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_selector"] = basetypes.ObjectType{
		AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instances_distribution"] = basetypes.ObjectType{
		AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["kubelet_extra_config6"] = basetypes.ObjectType{
		AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["max_pods_per_node"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["override_bootstrap_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["placement"] = basetypes.ObjectType{
		AttrTypes: Placement6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["pre_bootstrap_commands"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["private_networking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ObjectType{
		AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ssh"] = basetypes.ObjectType{
		AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tags2"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["taints"] = basetypes.SetType{
		ElemType: Taints6Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["target_group_arns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["update_config"] = basetypes.ObjectType{
		AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_encrypted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["volume_iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_kms_key_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_throughput"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 46)

		val, err = v.Ami.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami"] = val

		val, err = v.AmiFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami_family"] = val

		val, err = v.AsgMetricsCollection6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asg_metrics_collection6"] = val

		val, err = v.AsgSuspendProcesses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asg_suspend_processes"] = val

		val, err = v.AvailabilityZones2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["availability_zones2"] = val

		val, err = v.BottleRocket6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bottle_rocket"] = val

		val, err = v.ClassicLoadBalancerNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["classic_load_balancer_names"] = val

		val, err = v.ClusterDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_dns"] = val

		val, err = v.CpuCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_credits"] = val

		val, err = v.DesiredCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_capacity"] = val

		val, err = v.DisableImdsv1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_imdsv1"] = val

		val, err = v.DisablePodsImds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_pods_imds"] = val

		val, err = v.EbsOptimized.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs_optimized"] = val

		val, err = v.EfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efa_enabled"] = val

		val, err = v.EnableDetailedMonitoring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_detailed_monitoring"] = val

		val, err = v.Iam6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.InstanceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_name"] = val

		val, err = v.InstancePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_prefix"] = val

		val, err = v.InstanceSelector6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_selector"] = val

		val, err = v.InstanceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_type"] = val

		val, err = v.InstancesDistribution6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instances_distribution"] = val

		val, err = v.KubeletExtraConfig6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubelet_extra_config6"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.MaxPodsPerNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pods_per_node"] = val

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.OverrideBootstrapCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["override_bootstrap_command"] = val

		val, err = v.Placement6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["placement"] = val

		val, err = v.PreBootstrapCommands.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pre_bootstrap_commands"] = val

		val, err = v.PrivateNetworking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_networking"] = val

		val, err = v.SecurityGroups6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Ssh6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.Tags2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags2"] = val

		val, err = v.Taints6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taints"] = val

		val, err = v.TargetGroupArns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_group_arns"] = val

		val, err = v.UpdateConfig6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["update_config"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VolumeEncrypted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_encrypted"] = val

		val, err = v.VolumeIops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_iops"] = val

		val, err = v.VolumeKmsKeyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_kms_key_id"] = val

		val, err = v.VolumeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_name"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeThroughput.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_throughput"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeGroupsMapValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeGroupsMapValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeGroupsMapValue) String() string {
	return "NodeGroupsMapValue"
}

func (v NodeGroupsMapValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	asgMetricsCollection6 := types.SetValueMust(
		AsgMetricsCollection6Type{
			basetypes.ObjectType{
				AttrTypes: AsgMetricsCollection6Value{}.AttributeTypes(ctx),
			},
		},
		v.AsgMetricsCollection6.Elements(),
	)

	if v.AsgMetricsCollection6.IsNull() {
		asgMetricsCollection6 = types.SetNull(
			AsgMetricsCollection6Type{
				basetypes.ObjectType{
					AttrTypes: AsgMetricsCollection6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AsgMetricsCollection6.IsUnknown() {
		asgMetricsCollection6 = types.SetUnknown(
			AsgMetricsCollection6Type{
				basetypes.ObjectType{
					AttrTypes: AsgMetricsCollection6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var bottleRocket6 basetypes.ObjectValue

	if v.BottleRocket6.IsNull() {
		bottleRocket6 = types.ObjectNull(
			BottleRocket6Value{}.AttributeTypes(ctx),
		)
	}

	if v.BottleRocket6.IsUnknown() {
		bottleRocket6 = types.ObjectUnknown(
			BottleRocket6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.BottleRocket6.IsNull() && !v.BottleRocket6.IsUnknown() {
		bottleRocket6 = types.ObjectValueMust(
			BottleRocket6Value{}.AttributeTypes(ctx),
			v.BottleRocket6.Attributes(),
		)
	}

	var iam6 basetypes.ObjectValue

	if v.Iam6.IsNull() {
		iam6 = types.ObjectNull(
			Iam6Value{}.AttributeTypes(ctx),
		)
	}

	if v.Iam6.IsUnknown() {
		iam6 = types.ObjectUnknown(
			Iam6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Iam6.IsNull() && !v.Iam6.IsUnknown() {
		iam6 = types.ObjectValueMust(
			Iam6Value{}.AttributeTypes(ctx),
			v.Iam6.Attributes(),
		)
	}

	var instanceSelector6 basetypes.ObjectValue

	if v.InstanceSelector6.IsNull() {
		instanceSelector6 = types.ObjectNull(
			InstanceSelector6Value{}.AttributeTypes(ctx),
		)
	}

	if v.InstanceSelector6.IsUnknown() {
		instanceSelector6 = types.ObjectUnknown(
			InstanceSelector6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.InstanceSelector6.IsNull() && !v.InstanceSelector6.IsUnknown() {
		instanceSelector6 = types.ObjectValueMust(
			InstanceSelector6Value{}.AttributeTypes(ctx),
			v.InstanceSelector6.Attributes(),
		)
	}

	var instancesDistribution6 basetypes.ObjectValue

	if v.InstancesDistribution6.IsNull() {
		instancesDistribution6 = types.ObjectNull(
			InstancesDistribution6Value{}.AttributeTypes(ctx),
		)
	}

	if v.InstancesDistribution6.IsUnknown() {
		instancesDistribution6 = types.ObjectUnknown(
			InstancesDistribution6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.InstancesDistribution6.IsNull() && !v.InstancesDistribution6.IsUnknown() {
		instancesDistribution6 = types.ObjectValueMust(
			InstancesDistribution6Value{}.AttributeTypes(ctx),
			v.InstancesDistribution6.Attributes(),
		)
	}

	var kubeletExtraConfig6 basetypes.ObjectValue

	if v.KubeletExtraConfig6.IsNull() {
		kubeletExtraConfig6 = types.ObjectNull(
			KubeletExtraConfig6Value{}.AttributeTypes(ctx),
		)
	}

	if v.KubeletExtraConfig6.IsUnknown() {
		kubeletExtraConfig6 = types.ObjectUnknown(
			KubeletExtraConfig6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.KubeletExtraConfig6.IsNull() && !v.KubeletExtraConfig6.IsUnknown() {
		kubeletExtraConfig6 = types.ObjectValueMust(
			KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			v.KubeletExtraConfig6.Attributes(),
		)
	}

	var placement6 basetypes.ObjectValue

	if v.Placement6.IsNull() {
		placement6 = types.ObjectNull(
			Placement6Value{}.AttributeTypes(ctx),
		)
	}

	if v.Placement6.IsUnknown() {
		placement6 = types.ObjectUnknown(
			Placement6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Placement6.IsNull() && !v.Placement6.IsUnknown() {
		placement6 = types.ObjectValueMust(
			Placement6Value{}.AttributeTypes(ctx),
			v.Placement6.Attributes(),
		)
	}

	var securityGroups6 basetypes.ObjectValue

	if v.SecurityGroups6.IsNull() {
		securityGroups6 = types.ObjectNull(
			SecurityGroups6Value{}.AttributeTypes(ctx),
		)
	}

	if v.SecurityGroups6.IsUnknown() {
		securityGroups6 = types.ObjectUnknown(
			SecurityGroups6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.SecurityGroups6.IsNull() && !v.SecurityGroups6.IsUnknown() {
		securityGroups6 = types.ObjectValueMust(
			SecurityGroups6Value{}.AttributeTypes(ctx),
			v.SecurityGroups6.Attributes(),
		)
	}

	var ssh6 basetypes.ObjectValue

	if v.Ssh6.IsNull() {
		ssh6 = types.ObjectNull(
			Ssh6Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ssh6.IsUnknown() {
		ssh6 = types.ObjectUnknown(
			Ssh6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ssh6.IsNull() && !v.Ssh6.IsUnknown() {
		ssh6 = types.ObjectValueMust(
			Ssh6Value{}.AttributeTypes(ctx),
			v.Ssh6.Attributes(),
		)
	}

	taints6 := types.SetValueMust(
		Taints6Type{
			basetypes.ObjectType{
				AttrTypes: Taints6Value{}.AttributeTypes(ctx),
			},
		},
		v.Taints6.Elements(),
	)

	if v.Taints6.IsNull() {
		taints6 = types.SetNull(
			Taints6Type{
				basetypes.ObjectType{
					AttrTypes: Taints6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taints6.IsUnknown() {
		taints6 = types.SetUnknown(
			Taints6Type{
				basetypes.ObjectType{
					AttrTypes: Taints6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var updateConfig6 basetypes.ObjectValue

	if v.UpdateConfig6.IsNull() {
		updateConfig6 = types.ObjectNull(
			UpdateConfig6Value{}.AttributeTypes(ctx),
		)
	}

	if v.UpdateConfig6.IsUnknown() {
		updateConfig6 = types.ObjectUnknown(
			UpdateConfig6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.UpdateConfig6.IsNull() && !v.UpdateConfig6.IsUnknown() {
		updateConfig6 = types.ObjectValueMust(
			UpdateConfig6Value{}.AttributeTypes(ctx),
			v.UpdateConfig6.Attributes(),
		)
	}

	var asgSuspendProcessesVal basetypes.ListValue
	switch {
	case v.AsgSuspendProcesses.IsUnknown():
		asgSuspendProcessesVal = types.ListUnknown(types.StringType)
	case v.AsgSuspendProcesses.IsNull():
		asgSuspendProcessesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		asgSuspendProcessesVal, d = types.ListValue(types.StringType, v.AsgSuspendProcesses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection6": basetypes.SetType{
				ElemType: AsgMetricsCollection6Value{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones2": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam6Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ObjectType{
				AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
			},
			"kubelet_extra_config6": basetypes.ObjectType{
				AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement6Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags2": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints6Value{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var availabilityZones2Val basetypes.ListValue
	switch {
	case v.AvailabilityZones2.IsUnknown():
		availabilityZones2Val = types.ListUnknown(types.StringType)
	case v.AvailabilityZones2.IsNull():
		availabilityZones2Val = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		availabilityZones2Val, d = types.ListValue(types.StringType, v.AvailabilityZones2.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection6": basetypes.SetType{
				ElemType: AsgMetricsCollection6Value{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones2": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam6Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ObjectType{
				AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
			},
			"kubelet_extra_config6": basetypes.ObjectType{
				AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement6Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags2": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints6Value{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var classicLoadBalancerNamesVal basetypes.ListValue
	switch {
	case v.ClassicLoadBalancerNames.IsUnknown():
		classicLoadBalancerNamesVal = types.ListUnknown(types.StringType)
	case v.ClassicLoadBalancerNames.IsNull():
		classicLoadBalancerNamesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		classicLoadBalancerNamesVal, d = types.ListValue(types.StringType, v.ClassicLoadBalancerNames.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection6": basetypes.SetType{
				ElemType: AsgMetricsCollection6Value{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones2": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam6Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ObjectType{
				AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
			},
			"kubelet_extra_config6": basetypes.ObjectType{
				AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement6Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags2": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints6Value{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection6": basetypes.SetType{
				ElemType: AsgMetricsCollection6Value{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones2": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam6Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ObjectType{
				AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
			},
			"kubelet_extra_config6": basetypes.ObjectType{
				AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement6Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags2": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints6Value{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var preBootstrapCommandsVal basetypes.ListValue
	switch {
	case v.PreBootstrapCommands.IsUnknown():
		preBootstrapCommandsVal = types.ListUnknown(types.StringType)
	case v.PreBootstrapCommands.IsNull():
		preBootstrapCommandsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		preBootstrapCommandsVal, d = types.ListValue(types.StringType, v.PreBootstrapCommands.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection6": basetypes.SetType{
				ElemType: AsgMetricsCollection6Value{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones2": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam6Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ObjectType{
				AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
			},
			"kubelet_extra_config6": basetypes.ObjectType{
				AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement6Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags2": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints6Value{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var subnetsVal basetypes.SetValue
	switch {
	case v.Subnets.IsUnknown():
		subnetsVal = types.SetUnknown(types.StringType)
	case v.Subnets.IsNull():
		subnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		subnetsVal, d = types.SetValue(types.StringType, v.Subnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection6": basetypes.SetType{
				ElemType: AsgMetricsCollection6Value{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones2": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam6Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ObjectType{
				AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
			},
			"kubelet_extra_config6": basetypes.ObjectType{
				AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement6Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags2": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints6Value{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var tags2Val basetypes.MapValue
	switch {
	case v.Tags2.IsUnknown():
		tags2Val = types.MapUnknown(types.StringType)
	case v.Tags2.IsNull():
		tags2Val = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tags2Val, d = types.MapValue(types.StringType, v.Tags2.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection6": basetypes.SetType{
				ElemType: AsgMetricsCollection6Value{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones2": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam6Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ObjectType{
				AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
			},
			"kubelet_extra_config6": basetypes.ObjectType{
				AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement6Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags2": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints6Value{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var targetGroupArnsVal basetypes.ListValue
	switch {
	case v.TargetGroupArns.IsUnknown():
		targetGroupArnsVal = types.ListUnknown(types.StringType)
	case v.TargetGroupArns.IsNull():
		targetGroupArnsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		targetGroupArnsVal, d = types.ListValue(types.StringType, v.TargetGroupArns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection6": basetypes.SetType{
				ElemType: AsgMetricsCollection6Value{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones2": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ObjectType{
				AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ObjectType{
				AttrTypes: Iam6Value{}.AttributeTypes(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ObjectType{
				AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ObjectType{
				AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
			},
			"kubelet_extra_config6": basetypes.ObjectType{
				AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ObjectType{
				AttrTypes: Placement6Value{}.AttributeTypes(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ObjectType{
				AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags2": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints6Value{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ObjectType{
				AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ami":        basetypes.StringType{},
		"ami_family": basetypes.StringType{},
		"asg_metrics_collection6": basetypes.SetType{
			ElemType: AsgMetricsCollection6Value{}.Type(ctx),
		},
		"asg_suspend_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"availability_zones2": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bottle_rocket": basetypes.ObjectType{
			AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
		},
		"classic_load_balancer_names": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cluster_dns":                basetypes.StringType{},
		"cpu_credits":                basetypes.StringType{},
		"desired_capacity":           basetypes.Int64Type{},
		"disable_imdsv1":             basetypes.BoolType{},
		"disable_pods_imds":          basetypes.BoolType{},
		"ebs_optimized":              basetypes.BoolType{},
		"efa_enabled":                basetypes.BoolType{},
		"enable_detailed_monitoring": basetypes.BoolType{},
		"iam": basetypes.ObjectType{
			AttrTypes: Iam6Value{}.AttributeTypes(ctx),
		},
		"instance_name":   basetypes.StringType{},
		"instance_prefix": basetypes.StringType{},
		"instance_selector": basetypes.ObjectType{
			AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
		},
		"instance_type": basetypes.StringType{},
		"instances_distribution": basetypes.ObjectType{
			AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
		},
		"kubelet_extra_config6": basetypes.ObjectType{
			AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"max_pods_per_node":          basetypes.Int64Type{},
		"max_size":                   basetypes.Int64Type{},
		"min_size":                   basetypes.Int64Type{},
		"override_bootstrap_command": basetypes.StringType{},
		"placement": basetypes.ObjectType{
			AttrTypes: Placement6Value{}.AttributeTypes(ctx),
		},
		"pre_bootstrap_commands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_networking": basetypes.BoolType{},
		"security_groups": basetypes.ObjectType{
			AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
		},
		"ssh": basetypes.ObjectType{
			AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
		},
		"subnet_cidr": basetypes.StringType{},
		"subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tags2": basetypes.MapType{
			ElemType: types.StringType,
		},
		"taints": basetypes.SetType{
			ElemType: Taints6Value{}.Type(ctx),
		},
		"target_group_arns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"update_config": basetypes.ObjectType{
			AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
		},
		"version":           basetypes.StringType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_iops":       basetypes.Int64Type{},
		"volume_kms_key_id": basetypes.StringType{},
		"volume_name":       basetypes.StringType{},
		"volume_size":       basetypes.Int64Type{},
		"volume_throughput": basetypes.Int64Type{},
		"volume_type":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ami":                         v.Ami,
			"ami_family":                  v.AmiFamily,
			"asg_metrics_collection6":     asgMetricsCollection6,
			"asg_suspend_processes":       asgSuspendProcessesVal,
			"availability_zones2":         availabilityZones2Val,
			"bottle_rocket":               bottleRocket6,
			"classic_load_balancer_names": classicLoadBalancerNamesVal,
			"cluster_dns":                 v.ClusterDns,
			"cpu_credits":                 v.CpuCredits,
			"desired_capacity":            v.DesiredCapacity,
			"disable_imdsv1":              v.DisableImdsv1,
			"disable_pods_imds":           v.DisablePodsImds,
			"ebs_optimized":               v.EbsOptimized,
			"efa_enabled":                 v.EfaEnabled,
			"enable_detailed_monitoring":  v.EnableDetailedMonitoring,
			"iam":                         iam6,
			"instance_name":               v.InstanceName,
			"instance_prefix":             v.InstancePrefix,
			"instance_selector":           instanceSelector6,
			"instance_type":               v.InstanceType,
			"instances_distribution":      instancesDistribution6,
			"kubelet_extra_config6":       kubeletExtraConfig6,
			"labels":                      labelsVal,
			"max_pods_per_node":           v.MaxPodsPerNode,
			"max_size":                    v.MaxSize,
			"min_size":                    v.MinSize,
			"override_bootstrap_command":  v.OverrideBootstrapCommand,
			"placement":                   placement6,
			"pre_bootstrap_commands":      preBootstrapCommandsVal,
			"private_networking":          v.PrivateNetworking,
			"security_groups":             securityGroups6,
			"ssh":                         ssh6,
			"subnet_cidr":                 v.SubnetCidr,
			"subnets":                     subnetsVal,
			"tags2":                       tags2Val,
			"taints":                      taints6,
			"target_group_arns":           targetGroupArnsVal,
			"update_config":               updateConfig6,
			"version":                     v.Version,
			"volume_encrypted":            v.VolumeEncrypted,
			"volume_iops":                 v.VolumeIops,
			"volume_kms_key_id":           v.VolumeKmsKeyId,
			"volume_name":                 v.VolumeName,
			"volume_size":                 v.VolumeSize,
			"volume_throughput":           v.VolumeThroughput,
			"volume_type":                 v.VolumeType,
		})

	return objVal, diags
}

func (v NodeGroupsMapValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeGroupsMapValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ami.Equal(other.Ami) {
		return false
	}

	if !v.AmiFamily.Equal(other.AmiFamily) {
		return false
	}

	if !v.AsgMetricsCollection6.Equal(other.AsgMetricsCollection6) {
		return false
	}

	if !v.AsgSuspendProcesses.Equal(other.AsgSuspendProcesses) {
		return false
	}

	if !v.AvailabilityZones2.Equal(other.AvailabilityZones2) {
		return false
	}

	if !v.BottleRocket6.Equal(other.BottleRocket6) {
		return false
	}

	if !v.ClassicLoadBalancerNames.Equal(other.ClassicLoadBalancerNames) {
		return false
	}

	if !v.ClusterDns.Equal(other.ClusterDns) {
		return false
	}

	if !v.CpuCredits.Equal(other.CpuCredits) {
		return false
	}

	if !v.DesiredCapacity.Equal(other.DesiredCapacity) {
		return false
	}

	if !v.DisableImdsv1.Equal(other.DisableImdsv1) {
		return false
	}

	if !v.DisablePodsImds.Equal(other.DisablePodsImds) {
		return false
	}

	if !v.EbsOptimized.Equal(other.EbsOptimized) {
		return false
	}

	if !v.EfaEnabled.Equal(other.EfaEnabled) {
		return false
	}

	if !v.EnableDetailedMonitoring.Equal(other.EnableDetailedMonitoring) {
		return false
	}

	if !v.Iam6.Equal(other.Iam6) {
		return false
	}

	if !v.InstanceName.Equal(other.InstanceName) {
		return false
	}

	if !v.InstancePrefix.Equal(other.InstancePrefix) {
		return false
	}

	if !v.InstanceSelector6.Equal(other.InstanceSelector6) {
		return false
	}

	if !v.InstanceType.Equal(other.InstanceType) {
		return false
	}

	if !v.InstancesDistribution6.Equal(other.InstancesDistribution6) {
		return false
	}

	if !v.KubeletExtraConfig6.Equal(other.KubeletExtraConfig6) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.MaxPodsPerNode.Equal(other.MaxPodsPerNode) {
		return false
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.OverrideBootstrapCommand.Equal(other.OverrideBootstrapCommand) {
		return false
	}

	if !v.Placement6.Equal(other.Placement6) {
		return false
	}

	if !v.PreBootstrapCommands.Equal(other.PreBootstrapCommands) {
		return false
	}

	if !v.PrivateNetworking.Equal(other.PrivateNetworking) {
		return false
	}

	if !v.SecurityGroups6.Equal(other.SecurityGroups6) {
		return false
	}

	if !v.Ssh6.Equal(other.Ssh6) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.Tags2.Equal(other.Tags2) {
		return false
	}

	if !v.Taints6.Equal(other.Taints6) {
		return false
	}

	if !v.TargetGroupArns.Equal(other.TargetGroupArns) {
		return false
	}

	if !v.UpdateConfig6.Equal(other.UpdateConfig6) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VolumeEncrypted.Equal(other.VolumeEncrypted) {
		return false
	}

	if !v.VolumeIops.Equal(other.VolumeIops) {
		return false
	}

	if !v.VolumeKmsKeyId.Equal(other.VolumeKmsKeyId) {
		return false
	}

	if !v.VolumeName.Equal(other.VolumeName) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeThroughput.Equal(other.VolumeThroughput) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v NodeGroupsMapValue) Type(ctx context.Context) attr.Type {
	return NodeGroupsMapType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeGroupsMapValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami":        basetypes.StringType{},
		"ami_family": basetypes.StringType{},
		"asg_metrics_collection6": basetypes.SetType{
			ElemType: AsgMetricsCollection6Value{}.Type(ctx),
		},
		"asg_suspend_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"availability_zones2": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bottle_rocket": basetypes.ObjectType{
			AttrTypes: BottleRocket6Value{}.AttributeTypes(ctx),
		},
		"classic_load_balancer_names": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cluster_dns":                basetypes.StringType{},
		"cpu_credits":                basetypes.StringType{},
		"desired_capacity":           basetypes.Int64Type{},
		"disable_imdsv1":             basetypes.BoolType{},
		"disable_pods_imds":          basetypes.BoolType{},
		"ebs_optimized":              basetypes.BoolType{},
		"efa_enabled":                basetypes.BoolType{},
		"enable_detailed_monitoring": basetypes.BoolType{},
		"iam": basetypes.ObjectType{
			AttrTypes: Iam6Value{}.AttributeTypes(ctx),
		},
		"instance_name":   basetypes.StringType{},
		"instance_prefix": basetypes.StringType{},
		"instance_selector": basetypes.ObjectType{
			AttrTypes: InstanceSelector6Value{}.AttributeTypes(ctx),
		},
		"instance_type": basetypes.StringType{},
		"instances_distribution": basetypes.ObjectType{
			AttrTypes: InstancesDistribution6Value{}.AttributeTypes(ctx),
		},
		"kubelet_extra_config6": basetypes.ObjectType{
			AttrTypes: KubeletExtraConfig6Value{}.AttributeTypes(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"max_pods_per_node":          basetypes.Int64Type{},
		"max_size":                   basetypes.Int64Type{},
		"min_size":                   basetypes.Int64Type{},
		"override_bootstrap_command": basetypes.StringType{},
		"placement": basetypes.ObjectType{
			AttrTypes: Placement6Value{}.AttributeTypes(ctx),
		},
		"pre_bootstrap_commands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_networking": basetypes.BoolType{},
		"security_groups": basetypes.ObjectType{
			AttrTypes: SecurityGroups6Value{}.AttributeTypes(ctx),
		},
		"ssh": basetypes.ObjectType{
			AttrTypes: Ssh6Value{}.AttributeTypes(ctx),
		},
		"subnet_cidr": basetypes.StringType{},
		"subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tags2": basetypes.MapType{
			ElemType: types.StringType,
		},
		"taints": basetypes.SetType{
			ElemType: Taints6Value{}.Type(ctx),
		},
		"target_group_arns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"update_config": basetypes.ObjectType{
			AttrTypes: UpdateConfig6Value{}.AttributeTypes(ctx),
		},
		"version":           basetypes.StringType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_iops":       basetypes.Int64Type{},
		"volume_kms_key_id": basetypes.StringType{},
		"volume_name":       basetypes.StringType{},
		"volume_size":       basetypes.Int64Type{},
		"volume_throughput": basetypes.Int64Type{},
		"volume_type":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AsgMetricsCollection6Type{}

type AsgMetricsCollection6Type struct {
	basetypes.ObjectType
}

func (t AsgMetricsCollection6Type) Equal(o attr.Type) bool {
	other, ok := o.(AsgMetricsCollection6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AsgMetricsCollection6Type) String() string {
	return "AsgMetricsCollection6Type"
}

func (t AsgMetricsCollection6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	granularityAttribute, ok := attributes["granularity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`granularity is missing from object`)

		return nil, diags
	}

	granularityVal, ok := granularityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`granularity expected to be basetypes.StringValue, was: %T`, granularityAttribute))
	}

	metricsAttribute, ok := attributes["metrics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metrics is missing from object`)

		return nil, diags
	}

	metricsVal, ok := metricsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metrics expected to be basetypes.ListValue, was: %T`, metricsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AsgMetricsCollection6Value{
		Granularity: granularityVal,
		Metrics:     metricsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAsgMetricsCollection6ValueNull() AsgMetricsCollection6Value {
	return AsgMetricsCollection6Value{
		state: attr.ValueStateNull,
	}
}

func NewAsgMetricsCollection6ValueUnknown() AsgMetricsCollection6Value {
	return AsgMetricsCollection6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewAsgMetricsCollection6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AsgMetricsCollection6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AsgMetricsCollection6Value Attribute Value",
				"While creating a AsgMetricsCollection6Value value, a missing attribute value was detected. "+
					"A AsgMetricsCollection6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsgMetricsCollection6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AsgMetricsCollection6Value Attribute Type",
				"While creating a AsgMetricsCollection6Value value, an invalid attribute value was detected. "+
					"A AsgMetricsCollection6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsgMetricsCollection6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AsgMetricsCollection6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AsgMetricsCollection6Value Attribute Value",
				"While creating a AsgMetricsCollection6Value value, an extra attribute value was detected. "+
					"A AsgMetricsCollection6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AsgMetricsCollection6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAsgMetricsCollection6ValueUnknown(), diags
	}

	granularityAttribute, ok := attributes["granularity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`granularity is missing from object`)

		return NewAsgMetricsCollection6ValueUnknown(), diags
	}

	granularityVal, ok := granularityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`granularity expected to be basetypes.StringValue, was: %T`, granularityAttribute))
	}

	metricsAttribute, ok := attributes["metrics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metrics is missing from object`)

		return NewAsgMetricsCollection6ValueUnknown(), diags
	}

	metricsVal, ok := metricsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metrics expected to be basetypes.ListValue, was: %T`, metricsAttribute))
	}

	if diags.HasError() {
		return NewAsgMetricsCollection6ValueUnknown(), diags
	}

	return AsgMetricsCollection6Value{
		Granularity: granularityVal,
		Metrics:     metricsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAsgMetricsCollection6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AsgMetricsCollection6Value {
	object, diags := NewAsgMetricsCollection6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAsgMetricsCollection6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AsgMetricsCollection6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAsgMetricsCollection6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAsgMetricsCollection6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAsgMetricsCollection6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAsgMetricsCollection6ValueMust(AsgMetricsCollection6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t AsgMetricsCollection6Type) ValueType(ctx context.Context) attr.Value {
	return AsgMetricsCollection6Value{}
}

var _ basetypes.ObjectValuable = AsgMetricsCollection6Value{}

type AsgMetricsCollection6Value struct {
	Granularity basetypes.StringValue `tfsdk:"granularity"`
	Metrics     basetypes.ListValue   `tfsdk:"metrics"`
	state       attr.ValueState
}

func (v AsgMetricsCollection6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["granularity"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metrics"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Granularity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["granularity"] = val

		val, err = v.Metrics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metrics"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AsgMetricsCollection6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AsgMetricsCollection6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AsgMetricsCollection6Value) String() string {
	return "AsgMetricsCollection6Value"
}

func (v AsgMetricsCollection6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metricsVal basetypes.ListValue
	switch {
	case v.Metrics.IsUnknown():
		metricsVal = types.ListUnknown(types.StringType)
	case v.Metrics.IsNull():
		metricsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		metricsVal, d = types.ListValue(types.StringType, v.Metrics.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"granularity": basetypes.StringType{},
			"metrics": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"granularity": basetypes.StringType{},
		"metrics": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"granularity": v.Granularity,
			"metrics":     metricsVal,
		})

	return objVal, diags
}

func (v AsgMetricsCollection6Value) Equal(o attr.Value) bool {
	other, ok := o.(AsgMetricsCollection6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Granularity.Equal(other.Granularity) {
		return false
	}

	if !v.Metrics.Equal(other.Metrics) {
		return false
	}

	return true
}

func (v AsgMetricsCollection6Value) Type(ctx context.Context) attr.Type {
	return AsgMetricsCollection6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AsgMetricsCollection6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"granularity": basetypes.StringType{},
		"metrics": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = BottleRocket6Type{}

type BottleRocket6Type struct {
	basetypes.ObjectType
}

func (t BottleRocket6Type) Equal(o attr.Type) bool {
	other, ok := o.(BottleRocket6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BottleRocket6Type) String() string {
	return "BottleRocket6Type"
}

func (t BottleRocket6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableAdminContainerAttribute, ok := attributes["enable_admin_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_admin_container is missing from object`)

		return nil, diags
	}

	enableAdminContainerVal, ok := enableAdminContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_admin_container expected to be basetypes.BoolValue, was: %T`, enableAdminContainerAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.StringValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BottleRocket6Value{
		EnableAdminContainer: enableAdminContainerVal,
		Settings:             settingsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBottleRocket6ValueNull() BottleRocket6Value {
	return BottleRocket6Value{
		state: attr.ValueStateNull,
	}
}

func NewBottleRocket6ValueUnknown() BottleRocket6Value {
	return BottleRocket6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBottleRocket6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BottleRocket6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BottleRocket6Value Attribute Value",
				"While creating a BottleRocket6Value value, a missing attribute value was detected. "+
					"A BottleRocket6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BottleRocket6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BottleRocket6Value Attribute Type",
				"While creating a BottleRocket6Value value, an invalid attribute value was detected. "+
					"A BottleRocket6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BottleRocket6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BottleRocket6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BottleRocket6Value Attribute Value",
				"While creating a BottleRocket6Value value, an extra attribute value was detected. "+
					"A BottleRocket6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BottleRocket6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBottleRocket6ValueUnknown(), diags
	}

	enableAdminContainerAttribute, ok := attributes["enable_admin_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_admin_container is missing from object`)

		return NewBottleRocket6ValueUnknown(), diags
	}

	enableAdminContainerVal, ok := enableAdminContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_admin_container expected to be basetypes.BoolValue, was: %T`, enableAdminContainerAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewBottleRocket6ValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.StringValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return NewBottleRocket6ValueUnknown(), diags
	}

	return BottleRocket6Value{
		EnableAdminContainer: enableAdminContainerVal,
		Settings:             settingsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBottleRocket6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BottleRocket6Value {
	object, diags := NewBottleRocket6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBottleRocket6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BottleRocket6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBottleRocket6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBottleRocket6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBottleRocket6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBottleRocket6ValueMust(BottleRocket6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t BottleRocket6Type) ValueType(ctx context.Context) attr.Value {
	return BottleRocket6Value{}
}

var _ basetypes.ObjectValuable = BottleRocket6Value{}

type BottleRocket6Value struct {
	EnableAdminContainer basetypes.BoolValue   `tfsdk:"enable_admin_container"`
	Settings             basetypes.StringValue `tfsdk:"settings"`
	state                attr.ValueState
}

func (v BottleRocket6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enable_admin_container"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EnableAdminContainer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_admin_container"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BottleRocket6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BottleRocket6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BottleRocket6Value) String() string {
	return "BottleRocket6Value"
}

func (v BottleRocket6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enable_admin_container": basetypes.BoolType{},
		"settings":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable_admin_container": v.EnableAdminContainer,
			"settings":               v.Settings,
		})

	return objVal, diags
}

func (v BottleRocket6Value) Equal(o attr.Value) bool {
	other, ok := o.(BottleRocket6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnableAdminContainer.Equal(other.EnableAdminContainer) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	return true
}

func (v BottleRocket6Value) Type(ctx context.Context) attr.Type {
	return BottleRocket6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BottleRocket6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable_admin_container": basetypes.BoolType{},
		"settings":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Iam6Type{}

type Iam6Type struct {
	basetypes.ObjectType
}

func (t Iam6Type) Equal(o attr.Type) bool {
	other, ok := o.(Iam6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Iam6Type) String() string {
	return "Iam6Type"
}

func (t Iam6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachPolicy6Attribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy6 is missing from object`)

		return nil, diags
	}

	attachPolicy6Val, ok := attachPolicy6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy6 expected to be basetypes.ObjectValue, was: %T`, attachPolicy6Attribute))
	}

	attachPolicyArnsAttribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns is missing from object`)

		return nil, diags
	}

	attachPolicyArnsVal, ok := attachPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns expected to be basetypes.SetValue, was: %T`, attachPolicyArnsAttribute))
	}

	attachPolicyV2Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2 is missing from object`)

		return nil, diags
	}

	attachPolicyV2Val, ok := attachPolicyV2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2 expected to be basetypes.StringValue, was: %T`, attachPolicyV2Attribute))
	}

	iamNodeGroupWithAddonPolicies6Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies6 is missing from object`)

		return nil, diags
	}

	iamNodeGroupWithAddonPolicies6Val, ok := iamNodeGroupWithAddonPolicies6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies6 expected to be basetypes.ObjectValue, was: %T`, iamNodeGroupWithAddonPolicies6Attribute))
	}

	instanceProfileArnAttribute, ok := attributes["instance_profile_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_profile_arn is missing from object`)

		return nil, diags
	}

	instanceProfileArnVal, ok := instanceProfileArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_profile_arn expected to be basetypes.StringValue, was: %T`, instanceProfileArnAttribute))
	}

	instanceRoleArnAttribute, ok := attributes["instance_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_arn is missing from object`)

		return nil, diags
	}

	instanceRoleArnVal, ok := instanceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_arn expected to be basetypes.StringValue, was: %T`, instanceRoleArnAttribute))
	}

	instanceRoleNameAttribute, ok := attributes["instance_role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_name is missing from object`)

		return nil, diags
	}

	instanceRoleNameVal, ok := instanceRoleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_name expected to be basetypes.StringValue, was: %T`, instanceRoleNameAttribute))
	}

	instanceRolePermissionBoundaryAttribute, ok := attributes["instance_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_permission_boundary is missing from object`)

		return nil, diags
	}

	instanceRolePermissionBoundaryVal, ok := instanceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_permission_boundary expected to be basetypes.StringValue, was: %T`, instanceRolePermissionBoundaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Iam6Value{
		AttachPolicy6:                  attachPolicy6Val,
		AttachPolicyArns:               attachPolicyArnsVal,
		AttachPolicyV2:                 attachPolicyV2Val,
		IamNodeGroupWithAddonPolicies6: iamNodeGroupWithAddonPolicies6Val,
		InstanceProfileArn:             instanceProfileArnVal,
		InstanceRoleArn:                instanceRoleArnVal,
		InstanceRoleName:               instanceRoleNameVal,
		InstanceRolePermissionBoundary: instanceRolePermissionBoundaryVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam6ValueNull() Iam6Value {
	return Iam6Value{
		state: attr.ValueStateNull,
	}
}

func NewIam6ValueUnknown() Iam6Value {
	return Iam6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIam6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Iam6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Iam6Value Attribute Value",
				"While creating a Iam6Value value, a missing attribute value was detected. "+
					"A Iam6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Iam6Value Attribute Type",
				"While creating a Iam6Value value, an invalid attribute value was detected. "+
					"A Iam6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Iam6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Iam6Value Attribute Value",
				"While creating a Iam6Value value, an extra attribute value was detected. "+
					"A Iam6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Iam6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIam6ValueUnknown(), diags
	}

	attachPolicy6Attribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy6 is missing from object`)

		return NewIam6ValueUnknown(), diags
	}

	attachPolicy6Val, ok := attachPolicy6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy6 expected to be basetypes.ObjectValue, was: %T`, attachPolicy6Attribute))
	}

	attachPolicyArnsAttribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns is missing from object`)

		return NewIam6ValueUnknown(), diags
	}

	attachPolicyArnsVal, ok := attachPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns expected to be basetypes.SetValue, was: %T`, attachPolicyArnsAttribute))
	}

	attachPolicyV2Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2 is missing from object`)

		return NewIam6ValueUnknown(), diags
	}

	attachPolicyV2Val, ok := attachPolicyV2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2 expected to be basetypes.StringValue, was: %T`, attachPolicyV2Attribute))
	}

	iamNodeGroupWithAddonPolicies6Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies6 is missing from object`)

		return NewIam6ValueUnknown(), diags
	}

	iamNodeGroupWithAddonPolicies6Val, ok := iamNodeGroupWithAddonPolicies6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies6 expected to be basetypes.ObjectValue, was: %T`, iamNodeGroupWithAddonPolicies6Attribute))
	}

	instanceProfileArnAttribute, ok := attributes["instance_profile_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_profile_arn is missing from object`)

		return NewIam6ValueUnknown(), diags
	}

	instanceProfileArnVal, ok := instanceProfileArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_profile_arn expected to be basetypes.StringValue, was: %T`, instanceProfileArnAttribute))
	}

	instanceRoleArnAttribute, ok := attributes["instance_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_arn is missing from object`)

		return NewIam6ValueUnknown(), diags
	}

	instanceRoleArnVal, ok := instanceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_arn expected to be basetypes.StringValue, was: %T`, instanceRoleArnAttribute))
	}

	instanceRoleNameAttribute, ok := attributes["instance_role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_name is missing from object`)

		return NewIam6ValueUnknown(), diags
	}

	instanceRoleNameVal, ok := instanceRoleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_name expected to be basetypes.StringValue, was: %T`, instanceRoleNameAttribute))
	}

	instanceRolePermissionBoundaryAttribute, ok := attributes["instance_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_permission_boundary is missing from object`)

		return NewIam6ValueUnknown(), diags
	}

	instanceRolePermissionBoundaryVal, ok := instanceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_permission_boundary expected to be basetypes.StringValue, was: %T`, instanceRolePermissionBoundaryAttribute))
	}

	if diags.HasError() {
		return NewIam6ValueUnknown(), diags
	}

	return Iam6Value{
		AttachPolicy6:                  attachPolicy6Val,
		AttachPolicyArns:               attachPolicyArnsVal,
		AttachPolicyV2:                 attachPolicyV2Val,
		IamNodeGroupWithAddonPolicies6: iamNodeGroupWithAddonPolicies6Val,
		InstanceProfileArn:             instanceProfileArnVal,
		InstanceRoleArn:                instanceRoleArnVal,
		InstanceRoleName:               instanceRoleNameVal,
		InstanceRolePermissionBoundary: instanceRolePermissionBoundaryVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Iam6Value {
	object, diags := NewIam6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIam6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Iam6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIam6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIam6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIam6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIam6ValueMust(Iam6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Iam6Type) ValueType(ctx context.Context) attr.Value {
	return Iam6Value{}
}

var _ basetypes.ObjectValuable = Iam6Value{}

type Iam6Value struct {
	AttachPolicy6                  basetypes.ObjectValue `tfsdk:"attach_policy"`
	AttachPolicyArns               basetypes.SetValue    `tfsdk:"attach_policy_arns"`
	AttachPolicyV2                 basetypes.StringValue `tfsdk:"attach_policy_v2"`
	IamNodeGroupWithAddonPolicies6 basetypes.ObjectValue `tfsdk:"iam_node_group_with_addon_policies"`
	InstanceProfileArn             basetypes.StringValue `tfsdk:"instance_profile_arn"`
	InstanceRoleArn                basetypes.StringValue `tfsdk:"instance_role_arn"`
	InstanceRoleName               basetypes.StringValue `tfsdk:"instance_role_name"`
	InstanceRolePermissionBoundary basetypes.StringValue `tfsdk:"instance_role_permission_boundary"`
	state                          attr.ValueState
}

func (v Iam6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["attach_policy"] = basetypes.ObjectType{
		AttrTypes: AttachPolicy6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["attach_policy_arns"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["attach_policy_v2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["iam_node_group_with_addon_policies"] = basetypes.ObjectType{
		AttrTypes: IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_profile_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_permission_boundary"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AttachPolicy6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy"] = val

		val, err = v.AttachPolicyArns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_arns"] = val

		val, err = v.AttachPolicyV2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_v2"] = val

		val, err = v.IamNodeGroupWithAddonPolicies6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_node_group_with_addon_policies"] = val

		val, err = v.InstanceProfileArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_profile_arn"] = val

		val, err = v.InstanceRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_arn"] = val

		val, err = v.InstanceRoleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_name"] = val

		val, err = v.InstanceRolePermissionBoundary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_permission_boundary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Iam6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Iam6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Iam6Value) String() string {
	return "Iam6Value"
}

func (v Iam6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attachPolicy6 basetypes.ObjectValue

	if v.AttachPolicy6.IsNull() {
		attachPolicy6 = types.ObjectNull(
			AttachPolicy6Value{}.AttributeTypes(ctx),
		)
	}

	if v.AttachPolicy6.IsUnknown() {
		attachPolicy6 = types.ObjectUnknown(
			AttachPolicy6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.AttachPolicy6.IsNull() && !v.AttachPolicy6.IsUnknown() {
		attachPolicy6 = types.ObjectValueMust(
			AttachPolicy6Value{}.AttributeTypes(ctx),
			v.AttachPolicy6.Attributes(),
		)
	}

	var iamNodeGroupWithAddonPolicies6 basetypes.ObjectValue

	if v.IamNodeGroupWithAddonPolicies6.IsNull() {
		iamNodeGroupWithAddonPolicies6 = types.ObjectNull(
			IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx),
		)
	}

	if v.IamNodeGroupWithAddonPolicies6.IsUnknown() {
		iamNodeGroupWithAddonPolicies6 = types.ObjectUnknown(
			IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.IamNodeGroupWithAddonPolicies6.IsNull() && !v.IamNodeGroupWithAddonPolicies6.IsUnknown() {
		iamNodeGroupWithAddonPolicies6 = types.ObjectValueMust(
			IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx),
			v.IamNodeGroupWithAddonPolicies6.Attributes(),
		)
	}

	var attachPolicyArnsVal basetypes.SetValue
	switch {
	case v.AttachPolicyArns.IsUnknown():
		attachPolicyArnsVal = types.SetUnknown(types.StringType)
	case v.AttachPolicyArns.IsNull():
		attachPolicyArnsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachPolicyArnsVal, d = types.SetValue(types.StringType, v.AttachPolicyArns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_policy": basetypes.ObjectType{
				AttrTypes: AttachPolicy6Value{}.AttributeTypes(ctx),
			},
			"attach_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"attach_policy_v2": basetypes.StringType{},
			"iam_node_group_with_addon_policies": basetypes.ObjectType{
				AttrTypes: IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx),
			},
			"instance_profile_arn":              basetypes.StringType{},
			"instance_role_arn":                 basetypes.StringType{},
			"instance_role_name":                basetypes.StringType{},
			"instance_role_permission_boundary": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_policy": basetypes.ObjectType{
			AttrTypes: AttachPolicy6Value{}.AttributeTypes(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2": basetypes.StringType{},
		"iam_node_group_with_addon_policies": basetypes.ObjectType{
			AttrTypes: IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx),
		},
		"instance_profile_arn":              basetypes.StringType{},
		"instance_role_arn":                 basetypes.StringType{},
		"instance_role_name":                basetypes.StringType{},
		"instance_role_permission_boundary": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_policy":                      attachPolicy6,
			"attach_policy_arns":                 attachPolicyArnsVal,
			"attach_policy_v2":                   v.AttachPolicyV2,
			"iam_node_group_with_addon_policies": iamNodeGroupWithAddonPolicies6,
			"instance_profile_arn":               v.InstanceProfileArn,
			"instance_role_arn":                  v.InstanceRoleArn,
			"instance_role_name":                 v.InstanceRoleName,
			"instance_role_permission_boundary":  v.InstanceRolePermissionBoundary,
		})

	return objVal, diags
}

func (v Iam6Value) Equal(o attr.Value) bool {
	other, ok := o.(Iam6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachPolicy6.Equal(other.AttachPolicy6) {
		return false
	}

	if !v.AttachPolicyArns.Equal(other.AttachPolicyArns) {
		return false
	}

	if !v.AttachPolicyV2.Equal(other.AttachPolicyV2) {
		return false
	}

	if !v.IamNodeGroupWithAddonPolicies6.Equal(other.IamNodeGroupWithAddonPolicies6) {
		return false
	}

	if !v.InstanceProfileArn.Equal(other.InstanceProfileArn) {
		return false
	}

	if !v.InstanceRoleArn.Equal(other.InstanceRoleArn) {
		return false
	}

	if !v.InstanceRoleName.Equal(other.InstanceRoleName) {
		return false
	}

	if !v.InstanceRolePermissionBoundary.Equal(other.InstanceRolePermissionBoundary) {
		return false
	}

	return true
}

func (v Iam6Value) Type(ctx context.Context) attr.Type {
	return Iam6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Iam6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_policy": basetypes.ObjectType{
			AttrTypes: AttachPolicy6Value{}.AttributeTypes(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2": basetypes.StringType{},
		"iam_node_group_with_addon_policies": basetypes.ObjectType{
			AttrTypes: IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx),
		},
		"instance_profile_arn":              basetypes.StringType{},
		"instance_role_arn":                 basetypes.StringType{},
		"instance_role_name":                basetypes.StringType{},
		"instance_role_permission_boundary": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttachPolicy6Type{}

type AttachPolicy6Type struct {
	basetypes.ObjectType
}

func (t AttachPolicy6Type) Equal(o attr.Type) bool {
	other, ok := o.(AttachPolicy6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachPolicy6Type) String() string {
	return "AttachPolicy6Type"
}

func (t AttachPolicy6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statement6Attribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement6 is missing from object`)

		return nil, diags
	}

	statement6Val, ok := statement6Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement6 expected to be basetypes.SetValue, was: %T`, statement6Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachPolicy6Value{
		Id:         idVal,
		Statement6: statement6Val,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicy6ValueNull() AttachPolicy6Value {
	return AttachPolicy6Value{
		state: attr.ValueStateNull,
	}
}

func NewAttachPolicy6ValueUnknown() AttachPolicy6Value {
	return AttachPolicy6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachPolicy6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachPolicy6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachPolicy6Value Attribute Value",
				"While creating a AttachPolicy6Value value, a missing attribute value was detected. "+
					"A AttachPolicy6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicy6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachPolicy6Value Attribute Type",
				"While creating a AttachPolicy6Value value, an invalid attribute value was detected. "+
					"A AttachPolicy6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicy6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachPolicy6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachPolicy6Value Attribute Value",
				"While creating a AttachPolicy6Value value, an extra attribute value was detected. "+
					"A AttachPolicy6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachPolicy6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachPolicy6ValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewAttachPolicy6ValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statement6Attribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement6 is missing from object`)

		return NewAttachPolicy6ValueUnknown(), diags
	}

	statement6Val, ok := statement6Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement6 expected to be basetypes.SetValue, was: %T`, statement6Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewAttachPolicy6ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewAttachPolicy6ValueUnknown(), diags
	}

	return AttachPolicy6Value{
		Id:         idVal,
		Statement6: statement6Val,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicy6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachPolicy6Value {
	object, diags := NewAttachPolicy6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachPolicy6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachPolicy6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachPolicy6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachPolicy6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachPolicy6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachPolicy6ValueMust(AttachPolicy6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t AttachPolicy6Type) ValueType(ctx context.Context) attr.Value {
	return AttachPolicy6Value{}
}

var _ basetypes.ObjectValuable = AttachPolicy6Value{}

type AttachPolicy6Value struct {
	Id         basetypes.StringValue `tfsdk:"id"`
	Statement6 basetypes.SetValue    `tfsdk:"statement"`
	Version    basetypes.StringValue `tfsdk:"version"`
	state      attr.ValueState
}

func (v AttachPolicy6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["statement"] = basetypes.SetType{
		ElemType: Statement6Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Statement6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statement"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachPolicy6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachPolicy6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachPolicy6Value) String() string {
	return "AttachPolicy6Value"
}

func (v AttachPolicy6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	statement6 := types.SetValueMust(
		Statement6Type{
			basetypes.ObjectType{
				AttrTypes: Statement6Value{}.AttributeTypes(ctx),
			},
		},
		v.Statement6.Elements(),
	)

	if v.Statement6.IsNull() {
		statement6 = types.SetNull(
			Statement6Type{
				basetypes.ObjectType{
					AttrTypes: Statement6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Statement6.IsUnknown() {
		statement6 = types.SetUnknown(
			Statement6Type{
				basetypes.ObjectType{
					AttrTypes: Statement6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: Statement6Value{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":        v.Id,
			"statement": statement6,
			"version":   v.Version,
		})

	return objVal, diags
}

func (v AttachPolicy6Value) Equal(o attr.Value) bool {
	other, ok := o.(AttachPolicy6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Statement6.Equal(other.Statement6) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v AttachPolicy6Value) Type(ctx context.Context) attr.Type {
	return AttachPolicy6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachPolicy6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: Statement6Value{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Statement6Type{}

type Statement6Type struct {
	basetypes.ObjectType
}

func (t Statement6Type) Equal(o attr.Type) bool {
	other, ok := o.(Statement6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Statement6Type) String() string {
	return "Statement6Type"
}

func (t Statement6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return nil, diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return nil, diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return nil, diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return nil, diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return nil, diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Statement6Value{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatement6ValueNull() Statement6Value {
	return Statement6Value{
		state: attr.ValueStateNull,
	}
}

func NewStatement6ValueUnknown() Statement6Value {
	return Statement6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewStatement6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Statement6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Statement6Value Attribute Value",
				"While creating a Statement6Value value, a missing attribute value was detected. "+
					"A Statement6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Statement6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Statement6Value Attribute Type",
				"While creating a Statement6Value value, an invalid attribute value was detected. "+
					"A Statement6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Statement6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Statement6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Statement6Value Attribute Value",
				"While creating a Statement6Value value, an extra attribute value was detected. "+
					"A Statement6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Statement6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatement6ValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return NewStatement6ValueUnknown(), diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return NewStatement6ValueUnknown(), diags
	}

	return Statement6Value{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatement6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Statement6Value {
	object, diags := NewStatement6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatement6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Statement6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatement6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatement6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatement6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatement6ValueMust(Statement6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Statement6Type) ValueType(ctx context.Context) attr.Value {
	return Statement6Value{}
}

var _ basetypes.ObjectValuable = Statement6Value{}

type Statement6Value struct {
	Action       basetypes.SetValue    `tfsdk:"action"`
	Condition    basetypes.StringValue `tfsdk:"condition"`
	Effect       basetypes.StringValue `tfsdk:"effect"`
	NotAction    basetypes.SetValue    `tfsdk:"not_action"`
	NotPrincipal basetypes.StringValue `tfsdk:"not_principal"`
	NotResource  basetypes.SetValue    `tfsdk:"not_resource"`
	Principal    basetypes.StringValue `tfsdk:"principal"`
	Resource     basetypes.StringValue `tfsdk:"resource"`
	Sid          basetypes.StringValue `tfsdk:"sid"`
	state        attr.ValueState
}

func (v Statement6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["not_principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_resource"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.NotAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_action"] = val

		val, err = v.NotPrincipal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_principal"] = val

		val, err = v.NotResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_resource"] = val

		val, err = v.Principal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["principal"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Sid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Statement6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Statement6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Statement6Value) String() string {
	return "Statement6Value"
}

func (v Statement6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var actionVal basetypes.SetValue
	switch {
	case v.Action.IsUnknown():
		actionVal = types.SetUnknown(types.StringType)
	case v.Action.IsNull():
		actionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		actionVal, d = types.SetValue(types.StringType, v.Action.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notActionVal basetypes.SetValue
	switch {
	case v.NotAction.IsUnknown():
		notActionVal = types.SetUnknown(types.StringType)
	case v.NotAction.IsNull():
		notActionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notActionVal, d = types.SetValue(types.StringType, v.NotAction.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notResourceVal basetypes.SetValue
	switch {
	case v.NotResource.IsUnknown():
		notResourceVal = types.SetUnknown(types.StringType)
	case v.NotResource.IsNull():
		notResourceVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notResourceVal, d = types.SetValue(types.StringType, v.NotResource.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":        actionVal,
			"condition":     v.Condition,
			"effect":        v.Effect,
			"not_action":    notActionVal,
			"not_principal": v.NotPrincipal,
			"not_resource":  notResourceVal,
			"principal":     v.Principal,
			"resource":      v.Resource,
			"sid":           v.Sid,
		})

	return objVal, diags
}

func (v Statement6Value) Equal(o attr.Value) bool {
	other, ok := o.(Statement6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.NotAction.Equal(other.NotAction) {
		return false
	}

	if !v.NotPrincipal.Equal(other.NotPrincipal) {
		return false
	}

	if !v.NotResource.Equal(other.NotResource) {
		return false
	}

	if !v.Principal.Equal(other.Principal) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Sid.Equal(other.Sid) {
		return false
	}

	return true
}

func (v Statement6Value) Type(ctx context.Context) attr.Type {
	return Statement6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Statement6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IamNodeGroupWithAddonPolicies6Type{}

type IamNodeGroupWithAddonPolicies6Type struct {
	basetypes.ObjectType
}

func (t IamNodeGroupWithAddonPolicies6Type) Equal(o attr.Type) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamNodeGroupWithAddonPolicies6Type) String() string {
	return "IamNodeGroupWithAddonPolicies6Type"
}

func (t IamNodeGroupWithAddonPolicies6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return nil, diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return nil, diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return nil, diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return nil, diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return nil, diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return nil, diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return nil, diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamNodeGroupWithAddonPolicies6Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies6ValueNull() IamNodeGroupWithAddonPolicies6Value {
	return IamNodeGroupWithAddonPolicies6Value{
		state: attr.ValueStateNull,
	}
}

func NewIamNodeGroupWithAddonPolicies6ValueUnknown() IamNodeGroupWithAddonPolicies6Value {
	return IamNodeGroupWithAddonPolicies6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIamNodeGroupWithAddonPolicies6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamNodeGroupWithAddonPolicies6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamNodeGroupWithAddonPolicies6Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies6Value value, a missing attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamNodeGroupWithAddonPolicies6Value Attribute Type",
				"While creating a IamNodeGroupWithAddonPolicies6Value value, an invalid attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamNodeGroupWithAddonPolicies6Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies6Value value, an extra attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamNodeGroupWithAddonPolicies6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), diags
	}

	return IamNodeGroupWithAddonPolicies6Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamNodeGroupWithAddonPolicies6Value {
	object, diags := NewIamNodeGroupWithAddonPolicies6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamNodeGroupWithAddonPolicies6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamNodeGroupWithAddonPolicies6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamNodeGroupWithAddonPolicies6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamNodeGroupWithAddonPolicies6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamNodeGroupWithAddonPolicies6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamNodeGroupWithAddonPolicies6ValueMust(IamNodeGroupWithAddonPolicies6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t IamNodeGroupWithAddonPolicies6Type) ValueType(ctx context.Context) attr.Value {
	return IamNodeGroupWithAddonPolicies6Value{}
}

var _ basetypes.ObjectValuable = IamNodeGroupWithAddonPolicies6Value{}

type IamNodeGroupWithAddonPolicies6Value struct {
	AlbIngress    basetypes.BoolValue `tfsdk:"alb_ingress"`
	AppMesh       basetypes.BoolValue `tfsdk:"app_mesh"`
	AppMeshReview basetypes.BoolValue `tfsdk:"app_mesh_review"`
	AutoScaler    basetypes.BoolValue `tfsdk:"auto_scaler"`
	CertManager   basetypes.BoolValue `tfsdk:"cert_manager"`
	CloudWatch    basetypes.BoolValue `tfsdk:"cloud_watch"`
	Ebs           basetypes.BoolValue `tfsdk:"ebs"`
	Efs           basetypes.BoolValue `tfsdk:"efs"`
	ExternalDns   basetypes.BoolValue `tfsdk:"external_dns"`
	Fsx           basetypes.BoolValue `tfsdk:"fsx"`
	ImageBuilder  basetypes.BoolValue `tfsdk:"image_builder"`
	Xray          basetypes.BoolValue `tfsdk:"xray"`
	state         attr.ValueState
}

func (v IamNodeGroupWithAddonPolicies6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alb_ingress"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh_review"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fsx"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xray"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AlbIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alb_ingress"] = val

		val, err = v.AppMesh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh"] = val

		val, err = v.AppMeshReview.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh_review"] = val

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.Ebs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs"] = val

		val, err = v.Efs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.Fsx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fsx"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		val, err = v.Xray.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xray"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamNodeGroupWithAddonPolicies6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamNodeGroupWithAddonPolicies6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamNodeGroupWithAddonPolicies6Value) String() string {
	return "IamNodeGroupWithAddonPolicies6Value"
}

func (v IamNodeGroupWithAddonPolicies6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alb_ingress":     v.AlbIngress,
			"app_mesh":        v.AppMesh,
			"app_mesh_review": v.AppMeshReview,
			"auto_scaler":     v.AutoScaler,
			"cert_manager":    v.CertManager,
			"cloud_watch":     v.CloudWatch,
			"ebs":             v.Ebs,
			"efs":             v.Efs,
			"external_dns":    v.ExternalDns,
			"fsx":             v.Fsx,
			"image_builder":   v.ImageBuilder,
			"xray":            v.Xray,
		})

	return objVal, diags
}

func (v IamNodeGroupWithAddonPolicies6Value) Equal(o attr.Value) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlbIngress.Equal(other.AlbIngress) {
		return false
	}

	if !v.AppMesh.Equal(other.AppMesh) {
		return false
	}

	if !v.AppMeshReview.Equal(other.AppMeshReview) {
		return false
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.Ebs.Equal(other.Ebs) {
		return false
	}

	if !v.Efs.Equal(other.Efs) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.Fsx.Equal(other.Fsx) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	if !v.Xray.Equal(other.Xray) {
		return false
	}

	return true
}

func (v IamNodeGroupWithAddonPolicies6Value) Type(ctx context.Context) attr.Type {
	return IamNodeGroupWithAddonPolicies6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamNodeGroupWithAddonPolicies6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InstanceSelector6Type{}

type InstanceSelector6Type struct {
	basetypes.ObjectType
}

func (t InstanceSelector6Type) Equal(o attr.Type) bool {
	other, ok := o.(InstanceSelector6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstanceSelector6Type) String() string {
	return "InstanceSelector6Type"
}

func (t InstanceSelector6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuArchitectureAttribute, ok := attributes["cpu_architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_architecture is missing from object`)

		return nil, diags
	}

	cpuArchitectureVal, ok := cpuArchitectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_architecture expected to be basetypes.StringValue, was: %T`, cpuArchitectureAttribute))
	}

	gpusAttribute, ok := attributes["gpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpus is missing from object`)

		return nil, diags
	}

	gpusVal, ok := gpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpus expected to be basetypes.Int64Value, was: %T`, gpusAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return nil, diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstanceSelector6Value{
		CpuArchitecture: cpuArchitectureVal,
		Gpus:            gpusVal,
		Memory:          memoryVal,
		Vcpus:           vcpusVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstanceSelector6ValueNull() InstanceSelector6Value {
	return InstanceSelector6Value{
		state: attr.ValueStateNull,
	}
}

func NewInstanceSelector6ValueUnknown() InstanceSelector6Value {
	return InstanceSelector6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewInstanceSelector6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstanceSelector6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstanceSelector6Value Attribute Value",
				"While creating a InstanceSelector6Value value, a missing attribute value was detected. "+
					"A InstanceSelector6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSelector6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstanceSelector6Value Attribute Type",
				"While creating a InstanceSelector6Value value, an invalid attribute value was detected. "+
					"A InstanceSelector6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSelector6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstanceSelector6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstanceSelector6Value Attribute Value",
				"While creating a InstanceSelector6Value value, an extra attribute value was detected. "+
					"A InstanceSelector6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstanceSelector6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstanceSelector6ValueUnknown(), diags
	}

	cpuArchitectureAttribute, ok := attributes["cpu_architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_architecture is missing from object`)

		return NewInstanceSelector6ValueUnknown(), diags
	}

	cpuArchitectureVal, ok := cpuArchitectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_architecture expected to be basetypes.StringValue, was: %T`, cpuArchitectureAttribute))
	}

	gpusAttribute, ok := attributes["gpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpus is missing from object`)

		return NewInstanceSelector6ValueUnknown(), diags
	}

	gpusVal, ok := gpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpus expected to be basetypes.Int64Value, was: %T`, gpusAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewInstanceSelector6ValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return NewInstanceSelector6ValueUnknown(), diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return NewInstanceSelector6ValueUnknown(), diags
	}

	return InstanceSelector6Value{
		CpuArchitecture: cpuArchitectureVal,
		Gpus:            gpusVal,
		Memory:          memoryVal,
		Vcpus:           vcpusVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstanceSelector6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstanceSelector6Value {
	object, diags := NewInstanceSelector6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstanceSelector6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstanceSelector6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstanceSelector6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstanceSelector6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstanceSelector6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstanceSelector6ValueMust(InstanceSelector6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t InstanceSelector6Type) ValueType(ctx context.Context) attr.Value {
	return InstanceSelector6Value{}
}

var _ basetypes.ObjectValuable = InstanceSelector6Value{}

type InstanceSelector6Value struct {
	CpuArchitecture basetypes.StringValue `tfsdk:"cpu_architecture"`
	Gpus            basetypes.Int64Value  `tfsdk:"gpus"`
	Memory          basetypes.StringValue `tfsdk:"memory"`
	Vcpus           basetypes.Int64Value  `tfsdk:"vcpus"`
	state           attr.ValueState
}

func (v InstanceSelector6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cpu_architecture"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpus"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpuArchitecture.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_architecture"] = val

		val, err = v.Gpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpus"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.Vcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpus"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstanceSelector6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstanceSelector6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstanceSelector6Value) String() string {
	return "InstanceSelector6Value"
}

func (v InstanceSelector6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_architecture": basetypes.StringType{},
		"gpus":             basetypes.Int64Type{},
		"memory":           basetypes.StringType{},
		"vcpus":            basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_architecture": v.CpuArchitecture,
			"gpus":             v.Gpus,
			"memory":           v.Memory,
			"vcpus":            v.Vcpus,
		})

	return objVal, diags
}

func (v InstanceSelector6Value) Equal(o attr.Value) bool {
	other, ok := o.(InstanceSelector6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuArchitecture.Equal(other.CpuArchitecture) {
		return false
	}

	if !v.Gpus.Equal(other.Gpus) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.Vcpus.Equal(other.Vcpus) {
		return false
	}

	return true
}

func (v InstanceSelector6Value) Type(ctx context.Context) attr.Type {
	return InstanceSelector6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstanceSelector6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_architecture": basetypes.StringType{},
		"gpus":             basetypes.Int64Type{},
		"memory":           basetypes.StringType{},
		"vcpus":            basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = InstancesDistribution6Type{}

type InstancesDistribution6Type struct {
	basetypes.ObjectType
}

func (t InstancesDistribution6Type) Equal(o attr.Type) bool {
	other, ok := o.(InstancesDistribution6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstancesDistribution6Type) String() string {
	return "InstancesDistribution6Type"
}

func (t InstancesDistribution6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	capacityRebalanceAttribute, ok := attributes["capacity_rebalance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`capacity_rebalance is missing from object`)

		return nil, diags
	}

	capacityRebalanceVal, ok := capacityRebalanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`capacity_rebalance expected to be basetypes.BoolValue, was: %T`, capacityRebalanceAttribute))
	}

	instanceTypesAttribute, ok := attributes["instance_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_types is missing from object`)

		return nil, diags
	}

	instanceTypesVal, ok := instanceTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_types expected to be basetypes.ListValue, was: %T`, instanceTypesAttribute))
	}

	maxPriceAttribute, ok := attributes["max_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_price is missing from object`)

		return nil, diags
	}

	maxPriceVal, ok := maxPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_price expected to be basetypes.Float64Value, was: %T`, maxPriceAttribute))
	}

	onDemandBaseCapacityAttribute, ok := attributes["on_demand_base_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_demand_base_capacity is missing from object`)

		return nil, diags
	}

	onDemandBaseCapacityVal, ok := onDemandBaseCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_demand_base_capacity expected to be basetypes.Int64Value, was: %T`, onDemandBaseCapacityAttribute))
	}

	onDemandPercentageAboveBaseCapacityAttribute, ok := attributes["on_demand_percentage_above_base_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_demand_percentage_above_base_capacity is missing from object`)

		return nil, diags
	}

	onDemandPercentageAboveBaseCapacityVal, ok := onDemandPercentageAboveBaseCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_demand_percentage_above_base_capacity expected to be basetypes.Int64Value, was: %T`, onDemandPercentageAboveBaseCapacityAttribute))
	}

	spotAllocationStrategyAttribute, ok := attributes["spot_allocation_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_allocation_strategy is missing from object`)

		return nil, diags
	}

	spotAllocationStrategyVal, ok := spotAllocationStrategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_allocation_strategy expected to be basetypes.StringValue, was: %T`, spotAllocationStrategyAttribute))
	}

	spotInstancePoolsAttribute, ok := attributes["spot_instance_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_instance_pools is missing from object`)

		return nil, diags
	}

	spotInstancePoolsVal, ok := spotInstancePoolsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_instance_pools expected to be basetypes.Int64Value, was: %T`, spotInstancePoolsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstancesDistribution6Value{
		CapacityRebalance:                   capacityRebalanceVal,
		InstanceTypes:                       instanceTypesVal,
		MaxPrice:                            maxPriceVal,
		OnDemandBaseCapacity:                onDemandBaseCapacityVal,
		OnDemandPercentageAboveBaseCapacity: onDemandPercentageAboveBaseCapacityVal,
		SpotAllocationStrategy:              spotAllocationStrategyVal,
		SpotInstancePools:                   spotInstancePoolsVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewInstancesDistribution6ValueNull() InstancesDistribution6Value {
	return InstancesDistribution6Value{
		state: attr.ValueStateNull,
	}
}

func NewInstancesDistribution6ValueUnknown() InstancesDistribution6Value {
	return InstancesDistribution6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewInstancesDistribution6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstancesDistribution6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstancesDistribution6Value Attribute Value",
				"While creating a InstancesDistribution6Value value, a missing attribute value was detected. "+
					"A InstancesDistribution6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancesDistribution6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstancesDistribution6Value Attribute Type",
				"While creating a InstancesDistribution6Value value, an invalid attribute value was detected. "+
					"A InstancesDistribution6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancesDistribution6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstancesDistribution6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstancesDistribution6Value Attribute Value",
				"While creating a InstancesDistribution6Value value, an extra attribute value was detected. "+
					"A InstancesDistribution6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstancesDistribution6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstancesDistribution6ValueUnknown(), diags
	}

	capacityRebalanceAttribute, ok := attributes["capacity_rebalance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`capacity_rebalance is missing from object`)

		return NewInstancesDistribution6ValueUnknown(), diags
	}

	capacityRebalanceVal, ok := capacityRebalanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`capacity_rebalance expected to be basetypes.BoolValue, was: %T`, capacityRebalanceAttribute))
	}

	instanceTypesAttribute, ok := attributes["instance_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_types is missing from object`)

		return NewInstancesDistribution6ValueUnknown(), diags
	}

	instanceTypesVal, ok := instanceTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_types expected to be basetypes.ListValue, was: %T`, instanceTypesAttribute))
	}

	maxPriceAttribute, ok := attributes["max_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_price is missing from object`)

		return NewInstancesDistribution6ValueUnknown(), diags
	}

	maxPriceVal, ok := maxPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_price expected to be basetypes.Float64Value, was: %T`, maxPriceAttribute))
	}

	onDemandBaseCapacityAttribute, ok := attributes["on_demand_base_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_demand_base_capacity is missing from object`)

		return NewInstancesDistribution6ValueUnknown(), diags
	}

	onDemandBaseCapacityVal, ok := onDemandBaseCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_demand_base_capacity expected to be basetypes.Int64Value, was: %T`, onDemandBaseCapacityAttribute))
	}

	onDemandPercentageAboveBaseCapacityAttribute, ok := attributes["on_demand_percentage_above_base_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_demand_percentage_above_base_capacity is missing from object`)

		return NewInstancesDistribution6ValueUnknown(), diags
	}

	onDemandPercentageAboveBaseCapacityVal, ok := onDemandPercentageAboveBaseCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_demand_percentage_above_base_capacity expected to be basetypes.Int64Value, was: %T`, onDemandPercentageAboveBaseCapacityAttribute))
	}

	spotAllocationStrategyAttribute, ok := attributes["spot_allocation_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_allocation_strategy is missing from object`)

		return NewInstancesDistribution6ValueUnknown(), diags
	}

	spotAllocationStrategyVal, ok := spotAllocationStrategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_allocation_strategy expected to be basetypes.StringValue, was: %T`, spotAllocationStrategyAttribute))
	}

	spotInstancePoolsAttribute, ok := attributes["spot_instance_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_instance_pools is missing from object`)

		return NewInstancesDistribution6ValueUnknown(), diags
	}

	spotInstancePoolsVal, ok := spotInstancePoolsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_instance_pools expected to be basetypes.Int64Value, was: %T`, spotInstancePoolsAttribute))
	}

	if diags.HasError() {
		return NewInstancesDistribution6ValueUnknown(), diags
	}

	return InstancesDistribution6Value{
		CapacityRebalance:                   capacityRebalanceVal,
		InstanceTypes:                       instanceTypesVal,
		MaxPrice:                            maxPriceVal,
		OnDemandBaseCapacity:                onDemandBaseCapacityVal,
		OnDemandPercentageAboveBaseCapacity: onDemandPercentageAboveBaseCapacityVal,
		SpotAllocationStrategy:              spotAllocationStrategyVal,
		SpotInstancePools:                   spotInstancePoolsVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewInstancesDistribution6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstancesDistribution6Value {
	object, diags := NewInstancesDistribution6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstancesDistribution6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstancesDistribution6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstancesDistribution6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstancesDistribution6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstancesDistribution6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstancesDistribution6ValueMust(InstancesDistribution6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t InstancesDistribution6Type) ValueType(ctx context.Context) attr.Value {
	return InstancesDistribution6Value{}
}

var _ basetypes.ObjectValuable = InstancesDistribution6Value{}

type InstancesDistribution6Value struct {
	CapacityRebalance                   basetypes.BoolValue    `tfsdk:"capacity_rebalance"`
	InstanceTypes                       basetypes.ListValue    `tfsdk:"instance_types"`
	MaxPrice                            basetypes.Float64Value `tfsdk:"max_price"`
	OnDemandBaseCapacity                basetypes.Int64Value   `tfsdk:"on_demand_base_capacity"`
	OnDemandPercentageAboveBaseCapacity basetypes.Int64Value   `tfsdk:"on_demand_percentage_above_base_capacity"`
	SpotAllocationStrategy              basetypes.StringValue  `tfsdk:"spot_allocation_strategy"`
	SpotInstancePools                   basetypes.Int64Value   `tfsdk:"spot_instance_pools"`
	state                               attr.ValueState
}

func (v InstancesDistribution6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["capacity_rebalance"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["instance_types"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["max_price"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["on_demand_base_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["on_demand_percentage_above_base_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spot_allocation_strategy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spot_instance_pools"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CapacityRebalance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["capacity_rebalance"] = val

		val, err = v.InstanceTypes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_types"] = val

		val, err = v.MaxPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_price"] = val

		val, err = v.OnDemandBaseCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_demand_base_capacity"] = val

		val, err = v.OnDemandPercentageAboveBaseCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_demand_percentage_above_base_capacity"] = val

		val, err = v.SpotAllocationStrategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spot_allocation_strategy"] = val

		val, err = v.SpotInstancePools.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spot_instance_pools"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstancesDistribution6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstancesDistribution6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstancesDistribution6Value) String() string {
	return "InstancesDistribution6Value"
}

func (v InstancesDistribution6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var instanceTypesVal basetypes.ListValue
	switch {
	case v.InstanceTypes.IsUnknown():
		instanceTypesVal = types.ListUnknown(types.StringType)
	case v.InstanceTypes.IsNull():
		instanceTypesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		instanceTypesVal, d = types.ListValue(types.StringType, v.InstanceTypes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"capacity_rebalance": basetypes.BoolType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"max_price":               basetypes.Float64Type{},
			"on_demand_base_capacity": basetypes.Int64Type{},
			"on_demand_percentage_above_base_capacity": basetypes.Int64Type{},
			"spot_allocation_strategy":                 basetypes.StringType{},
			"spot_instance_pools":                      basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"capacity_rebalance": basetypes.BoolType{},
		"instance_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"max_price":               basetypes.Float64Type{},
		"on_demand_base_capacity": basetypes.Int64Type{},
		"on_demand_percentage_above_base_capacity": basetypes.Int64Type{},
		"spot_allocation_strategy":                 basetypes.StringType{},
		"spot_instance_pools":                      basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"capacity_rebalance":                       v.CapacityRebalance,
			"instance_types":                           instanceTypesVal,
			"max_price":                                v.MaxPrice,
			"on_demand_base_capacity":                  v.OnDemandBaseCapacity,
			"on_demand_percentage_above_base_capacity": v.OnDemandPercentageAboveBaseCapacity,
			"spot_allocation_strategy":                 v.SpotAllocationStrategy,
			"spot_instance_pools":                      v.SpotInstancePools,
		})

	return objVal, diags
}

func (v InstancesDistribution6Value) Equal(o attr.Value) bool {
	other, ok := o.(InstancesDistribution6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CapacityRebalance.Equal(other.CapacityRebalance) {
		return false
	}

	if !v.InstanceTypes.Equal(other.InstanceTypes) {
		return false
	}

	if !v.MaxPrice.Equal(other.MaxPrice) {
		return false
	}

	if !v.OnDemandBaseCapacity.Equal(other.OnDemandBaseCapacity) {
		return false
	}

	if !v.OnDemandPercentageAboveBaseCapacity.Equal(other.OnDemandPercentageAboveBaseCapacity) {
		return false
	}

	if !v.SpotAllocationStrategy.Equal(other.SpotAllocationStrategy) {
		return false
	}

	if !v.SpotInstancePools.Equal(other.SpotInstancePools) {
		return false
	}

	return true
}

func (v InstancesDistribution6Value) Type(ctx context.Context) attr.Type {
	return InstancesDistribution6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstancesDistribution6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"capacity_rebalance": basetypes.BoolType{},
		"instance_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"max_price":               basetypes.Float64Type{},
		"on_demand_base_capacity": basetypes.Int64Type{},
		"on_demand_percentage_above_base_capacity": basetypes.Int64Type{},
		"spot_allocation_strategy":                 basetypes.StringType{},
		"spot_instance_pools":                      basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = KubeletExtraConfig6Type{}

type KubeletExtraConfig6Type struct {
	basetypes.ObjectType
}

func (t KubeletExtraConfig6Type) Equal(o attr.Type) bool {
	other, ok := o.(KubeletExtraConfig6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KubeletExtraConfig6Type) String() string {
	return "KubeletExtraConfig6Type"
}

func (t KubeletExtraConfig6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	evictionHardAttribute, ok := attributes["eviction_hard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eviction_hard is missing from object`)

		return nil, diags
	}

	evictionHardVal, ok := evictionHardAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eviction_hard expected to be basetypes.MapValue, was: %T`, evictionHardAttribute))
	}

	featureGatesAttribute, ok := attributes["feature_gates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`feature_gates is missing from object`)

		return nil, diags
	}

	featureGatesVal, ok := featureGatesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`feature_gates expected to be basetypes.MapValue, was: %T`, featureGatesAttribute))
	}

	kubeReservedAttribute, ok := attributes["kube_reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kube_reserved is missing from object`)

		return nil, diags
	}

	kubeReservedVal, ok := kubeReservedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kube_reserved expected to be basetypes.MapValue, was: %T`, kubeReservedAttribute))
	}

	kubeReservedCgroupAttribute, ok := attributes["kube_reserved_cgroup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kube_reserved_cgroup is missing from object`)

		return nil, diags
	}

	kubeReservedCgroupVal, ok := kubeReservedCgroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kube_reserved_cgroup expected to be basetypes.StringValue, was: %T`, kubeReservedCgroupAttribute))
	}

	systemReservedAttribute, ok := attributes["system_reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_reserved is missing from object`)

		return nil, diags
	}

	systemReservedVal, ok := systemReservedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_reserved expected to be basetypes.MapValue, was: %T`, systemReservedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KubeletExtraConfig6Value{
		EvictionHard:       evictionHardVal,
		FeatureGates:       featureGatesVal,
		KubeReserved:       kubeReservedVal,
		KubeReservedCgroup: kubeReservedCgroupVal,
		SystemReserved:     systemReservedVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewKubeletExtraConfig6ValueNull() KubeletExtraConfig6Value {
	return KubeletExtraConfig6Value{
		state: attr.ValueStateNull,
	}
}

func NewKubeletExtraConfig6ValueUnknown() KubeletExtraConfig6Value {
	return KubeletExtraConfig6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewKubeletExtraConfig6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KubeletExtraConfig6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KubeletExtraConfig6Value Attribute Value",
				"While creating a KubeletExtraConfig6Value value, a missing attribute value was detected. "+
					"A KubeletExtraConfig6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KubeletExtraConfig6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KubeletExtraConfig6Value Attribute Type",
				"While creating a KubeletExtraConfig6Value value, an invalid attribute value was detected. "+
					"A KubeletExtraConfig6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KubeletExtraConfig6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KubeletExtraConfig6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KubeletExtraConfig6Value Attribute Value",
				"While creating a KubeletExtraConfig6Value value, an extra attribute value was detected. "+
					"A KubeletExtraConfig6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KubeletExtraConfig6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKubeletExtraConfig6ValueUnknown(), diags
	}

	evictionHardAttribute, ok := attributes["eviction_hard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eviction_hard is missing from object`)

		return NewKubeletExtraConfig6ValueUnknown(), diags
	}

	evictionHardVal, ok := evictionHardAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eviction_hard expected to be basetypes.MapValue, was: %T`, evictionHardAttribute))
	}

	featureGatesAttribute, ok := attributes["feature_gates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`feature_gates is missing from object`)

		return NewKubeletExtraConfig6ValueUnknown(), diags
	}

	featureGatesVal, ok := featureGatesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`feature_gates expected to be basetypes.MapValue, was: %T`, featureGatesAttribute))
	}

	kubeReservedAttribute, ok := attributes["kube_reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kube_reserved is missing from object`)

		return NewKubeletExtraConfig6ValueUnknown(), diags
	}

	kubeReservedVal, ok := kubeReservedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kube_reserved expected to be basetypes.MapValue, was: %T`, kubeReservedAttribute))
	}

	kubeReservedCgroupAttribute, ok := attributes["kube_reserved_cgroup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kube_reserved_cgroup is missing from object`)

		return NewKubeletExtraConfig6ValueUnknown(), diags
	}

	kubeReservedCgroupVal, ok := kubeReservedCgroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kube_reserved_cgroup expected to be basetypes.StringValue, was: %T`, kubeReservedCgroupAttribute))
	}

	systemReservedAttribute, ok := attributes["system_reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_reserved is missing from object`)

		return NewKubeletExtraConfig6ValueUnknown(), diags
	}

	systemReservedVal, ok := systemReservedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_reserved expected to be basetypes.MapValue, was: %T`, systemReservedAttribute))
	}

	if diags.HasError() {
		return NewKubeletExtraConfig6ValueUnknown(), diags
	}

	return KubeletExtraConfig6Value{
		EvictionHard:       evictionHardVal,
		FeatureGates:       featureGatesVal,
		KubeReserved:       kubeReservedVal,
		KubeReservedCgroup: kubeReservedCgroupVal,
		SystemReserved:     systemReservedVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewKubeletExtraConfig6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KubeletExtraConfig6Value {
	object, diags := NewKubeletExtraConfig6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKubeletExtraConfig6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KubeletExtraConfig6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKubeletExtraConfig6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKubeletExtraConfig6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKubeletExtraConfig6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKubeletExtraConfig6ValueMust(KubeletExtraConfig6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t KubeletExtraConfig6Type) ValueType(ctx context.Context) attr.Value {
	return KubeletExtraConfig6Value{}
}

var _ basetypes.ObjectValuable = KubeletExtraConfig6Value{}

type KubeletExtraConfig6Value struct {
	EvictionHard       basetypes.MapValue    `tfsdk:"eviction_hard"`
	FeatureGates       basetypes.MapValue    `tfsdk:"feature_gates"`
	KubeReserved       basetypes.MapValue    `tfsdk:"kube_reserved"`
	KubeReservedCgroup basetypes.StringValue `tfsdk:"kube_reserved_cgroup"`
	SystemReserved     basetypes.MapValue    `tfsdk:"system_reserved"`
	state              attr.ValueState
}

func (v KubeletExtraConfig6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["eviction_hard"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["feature_gates"] = basetypes.MapType{
		ElemType: types.BoolType,
	}.TerraformType(ctx)
	attrTypes["kube_reserved"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kube_reserved_cgroup"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_reserved"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.EvictionHard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eviction_hard"] = val

		val, err = v.FeatureGates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["feature_gates"] = val

		val, err = v.KubeReserved.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kube_reserved"] = val

		val, err = v.KubeReservedCgroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kube_reserved_cgroup"] = val

		val, err = v.SystemReserved.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_reserved"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KubeletExtraConfig6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KubeletExtraConfig6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KubeletExtraConfig6Value) String() string {
	return "KubeletExtraConfig6Value"
}

func (v KubeletExtraConfig6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var evictionHardVal basetypes.MapValue
	switch {
	case v.EvictionHard.IsUnknown():
		evictionHardVal = types.MapUnknown(types.StringType)
	case v.EvictionHard.IsNull():
		evictionHardVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		evictionHardVal, d = types.MapValue(types.StringType, v.EvictionHard.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"eviction_hard": basetypes.MapType{
				ElemType: types.StringType,
			},
			"feature_gates": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"kube_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kube_reserved_cgroup": basetypes.StringType{},
			"system_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var featureGatesVal basetypes.MapValue
	switch {
	case v.FeatureGates.IsUnknown():
		featureGatesVal = types.MapUnknown(types.BoolType)
	case v.FeatureGates.IsNull():
		featureGatesVal = types.MapNull(types.BoolType)
	default:
		var d diag.Diagnostics
		featureGatesVal, d = types.MapValue(types.BoolType, v.FeatureGates.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"eviction_hard": basetypes.MapType{
				ElemType: types.StringType,
			},
			"feature_gates": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"kube_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kube_reserved_cgroup": basetypes.StringType{},
			"system_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var kubeReservedVal basetypes.MapValue
	switch {
	case v.KubeReserved.IsUnknown():
		kubeReservedVal = types.MapUnknown(types.StringType)
	case v.KubeReserved.IsNull():
		kubeReservedVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		kubeReservedVal, d = types.MapValue(types.StringType, v.KubeReserved.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"eviction_hard": basetypes.MapType{
				ElemType: types.StringType,
			},
			"feature_gates": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"kube_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kube_reserved_cgroup": basetypes.StringType{},
			"system_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var systemReservedVal basetypes.MapValue
	switch {
	case v.SystemReserved.IsUnknown():
		systemReservedVal = types.MapUnknown(types.StringType)
	case v.SystemReserved.IsNull():
		systemReservedVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		systemReservedVal, d = types.MapValue(types.StringType, v.SystemReserved.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"eviction_hard": basetypes.MapType{
				ElemType: types.StringType,
			},
			"feature_gates": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"kube_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kube_reserved_cgroup": basetypes.StringType{},
			"system_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"eviction_hard": basetypes.MapType{
			ElemType: types.StringType,
		},
		"feature_gates": basetypes.MapType{
			ElemType: types.BoolType,
		},
		"kube_reserved": basetypes.MapType{
			ElemType: types.StringType,
		},
		"kube_reserved_cgroup": basetypes.StringType{},
		"system_reserved": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"eviction_hard":        evictionHardVal,
			"feature_gates":        featureGatesVal,
			"kube_reserved":        kubeReservedVal,
			"kube_reserved_cgroup": v.KubeReservedCgroup,
			"system_reserved":      systemReservedVal,
		})

	return objVal, diags
}

func (v KubeletExtraConfig6Value) Equal(o attr.Value) bool {
	other, ok := o.(KubeletExtraConfig6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EvictionHard.Equal(other.EvictionHard) {
		return false
	}

	if !v.FeatureGates.Equal(other.FeatureGates) {
		return false
	}

	if !v.KubeReserved.Equal(other.KubeReserved) {
		return false
	}

	if !v.KubeReservedCgroup.Equal(other.KubeReservedCgroup) {
		return false
	}

	if !v.SystemReserved.Equal(other.SystemReserved) {
		return false
	}

	return true
}

func (v KubeletExtraConfig6Value) Type(ctx context.Context) attr.Type {
	return KubeletExtraConfig6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KubeletExtraConfig6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"eviction_hard": basetypes.MapType{
			ElemType: types.StringType,
		},
		"feature_gates": basetypes.MapType{
			ElemType: types.BoolType,
		},
		"kube_reserved": basetypes.MapType{
			ElemType: types.StringType,
		},
		"kube_reserved_cgroup": basetypes.StringType{},
		"system_reserved": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Placement6Type{}

type Placement6Type struct {
	basetypes.ObjectType
}

func (t Placement6Type) Equal(o attr.Type) bool {
	other, ok := o.(Placement6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Placement6Type) String() string {
	return "Placement6Type"
}

func (t Placement6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Placement6Value{
		Group: groupVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlacement6ValueNull() Placement6Value {
	return Placement6Value{
		state: attr.ValueStateNull,
	}
}

func NewPlacement6ValueUnknown() Placement6Value {
	return Placement6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPlacement6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Placement6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Placement6Value Attribute Value",
				"While creating a Placement6Value value, a missing attribute value was detected. "+
					"A Placement6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Placement6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Placement6Value Attribute Type",
				"While creating a Placement6Value value, an invalid attribute value was detected. "+
					"A Placement6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Placement6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Placement6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Placement6Value Attribute Value",
				"While creating a Placement6Value value, an extra attribute value was detected. "+
					"A Placement6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Placement6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlacement6ValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewPlacement6ValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	if diags.HasError() {
		return NewPlacement6ValueUnknown(), diags
	}

	return Placement6Value{
		Group: groupVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlacement6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Placement6Value {
	object, diags := NewPlacement6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlacement6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Placement6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlacement6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlacement6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlacement6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlacement6ValueMust(Placement6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Placement6Type) ValueType(ctx context.Context) attr.Value {
	return Placement6Value{}
}

var _ basetypes.ObjectValuable = Placement6Value{}

type Placement6Value struct {
	Group basetypes.StringValue `tfsdk:"group"`
	state attr.ValueState
}

func (v Placement6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Placement6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Placement6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Placement6Value) String() string {
	return "Placement6Value"
}

func (v Placement6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group": v.Group,
		})

	return objVal, diags
}

func (v Placement6Value) Equal(o attr.Value) bool {
	other, ok := o.(Placement6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	return true
}

func (v Placement6Value) Type(ctx context.Context) attr.Type {
	return Placement6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Placement6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroups6Type{}

type SecurityGroups6Type struct {
	basetypes.ObjectType
}

func (t SecurityGroups6Type) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroups6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroups6Type) String() string {
	return "SecurityGroups6Type"
}

func (t SecurityGroups6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachIdsAttribute, ok := attributes["attach_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_ids is missing from object`)

		return nil, diags
	}

	attachIdsVal, ok := attachIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_ids expected to be basetypes.ListValue, was: %T`, attachIdsAttribute))
	}

	withLocalAttribute, ok := attributes["with_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_local is missing from object`)

		return nil, diags
	}

	withLocalVal, ok := withLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_local expected to be basetypes.BoolValue, was: %T`, withLocalAttribute))
	}

	withSharedAttribute, ok := attributes["with_shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_shared is missing from object`)

		return nil, diags
	}

	withSharedVal, ok := withSharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_shared expected to be basetypes.BoolValue, was: %T`, withSharedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroups6Value{
		AttachIds:  attachIdsVal,
		WithLocal:  withLocalVal,
		WithShared: withSharedVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroups6ValueNull() SecurityGroups6Value {
	return SecurityGroups6Value{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroups6ValueUnknown() SecurityGroups6Value {
	return SecurityGroups6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroups6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroups6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroups6Value Attribute Value",
				"While creating a SecurityGroups6Value value, a missing attribute value was detected. "+
					"A SecurityGroups6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroups6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroups6Value Attribute Type",
				"While creating a SecurityGroups6Value value, an invalid attribute value was detected. "+
					"A SecurityGroups6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroups6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroups6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroups6Value Attribute Value",
				"While creating a SecurityGroups6Value value, an extra attribute value was detected. "+
					"A SecurityGroups6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroups6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroups6ValueUnknown(), diags
	}

	attachIdsAttribute, ok := attributes["attach_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_ids is missing from object`)

		return NewSecurityGroups6ValueUnknown(), diags
	}

	attachIdsVal, ok := attachIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_ids expected to be basetypes.ListValue, was: %T`, attachIdsAttribute))
	}

	withLocalAttribute, ok := attributes["with_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_local is missing from object`)

		return NewSecurityGroups6ValueUnknown(), diags
	}

	withLocalVal, ok := withLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_local expected to be basetypes.BoolValue, was: %T`, withLocalAttribute))
	}

	withSharedAttribute, ok := attributes["with_shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_shared is missing from object`)

		return NewSecurityGroups6ValueUnknown(), diags
	}

	withSharedVal, ok := withSharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_shared expected to be basetypes.BoolValue, was: %T`, withSharedAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroups6ValueUnknown(), diags
	}

	return SecurityGroups6Value{
		AttachIds:  attachIdsVal,
		WithLocal:  withLocalVal,
		WithShared: withSharedVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroups6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroups6Value {
	object, diags := NewSecurityGroups6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroups6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroups6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroups6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroups6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroups6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroups6ValueMust(SecurityGroups6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroups6Type) ValueType(ctx context.Context) attr.Value {
	return SecurityGroups6Value{}
}

var _ basetypes.ObjectValuable = SecurityGroups6Value{}

type SecurityGroups6Value struct {
	AttachIds  basetypes.ListValue `tfsdk:"attach_ids"`
	WithLocal  basetypes.BoolValue `tfsdk:"with_local"`
	WithShared basetypes.BoolValue `tfsdk:"with_shared"`
	state      attr.ValueState
}

func (v SecurityGroups6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["attach_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["with_local"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["with_shared"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AttachIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_ids"] = val

		val, err = v.WithLocal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_local"] = val

		val, err = v.WithShared.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_shared"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroups6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroups6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroups6Value) String() string {
	return "SecurityGroups6Value"
}

func (v SecurityGroups6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attachIdsVal basetypes.ListValue
	switch {
	case v.AttachIds.IsUnknown():
		attachIdsVal = types.ListUnknown(types.StringType)
	case v.AttachIds.IsNull():
		attachIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachIdsVal, d = types.ListValue(types.StringType, v.AttachIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"with_local":  basetypes.BoolType{},
			"with_shared": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"with_local":  basetypes.BoolType{},
		"with_shared": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_ids":  attachIdsVal,
			"with_local":  v.WithLocal,
			"with_shared": v.WithShared,
		})

	return objVal, diags
}

func (v SecurityGroups6Value) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroups6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachIds.Equal(other.AttachIds) {
		return false
	}

	if !v.WithLocal.Equal(other.WithLocal) {
		return false
	}

	if !v.WithShared.Equal(other.WithShared) {
		return false
	}

	return true
}

func (v SecurityGroups6Value) Type(ctx context.Context) attr.Type {
	return SecurityGroups6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroups6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"with_local":  basetypes.BoolType{},
		"with_shared": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ssh6Type{}

type Ssh6Type struct {
	basetypes.ObjectType
}

func (t Ssh6Type) Equal(o attr.Type) bool {
	other, ok := o.(Ssh6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ssh6Type) String() string {
	return "Ssh6Type"
}

func (t Ssh6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return nil, diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	enableSsmAttribute, ok := attributes["enable_ssm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ssm is missing from object`)

		return nil, diags
	}

	enableSsmVal, ok := enableSsmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ssm expected to be basetypes.BoolValue, was: %T`, enableSsmAttribute))
	}

	publicKeyAttribute, ok := attributes["public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key is missing from object`)

		return nil, diags
	}

	publicKeyVal, ok := publicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key expected to be basetypes.StringValue, was: %T`, publicKeyAttribute))
	}

	publicKeyNameAttribute, ok := attributes["public_key_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key_name is missing from object`)

		return nil, diags
	}

	publicKeyNameVal, ok := publicKeyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key_name expected to be basetypes.StringValue, was: %T`, publicKeyNameAttribute))
	}

	sourceSecurityGroupIdsAttribute, ok := attributes["source_security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_security_group_ids is missing from object`)

		return nil, diags
	}

	sourceSecurityGroupIdsVal, ok := sourceSecurityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_security_group_ids expected to be basetypes.ListValue, was: %T`, sourceSecurityGroupIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ssh6Value{
		Allow:                  allowVal,
		EnableSsm:              enableSsmVal,
		PublicKey:              publicKeyVal,
		PublicKeyName:          publicKeyNameVal,
		SourceSecurityGroupIds: sourceSecurityGroupIdsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSsh6ValueNull() Ssh6Value {
	return Ssh6Value{
		state: attr.ValueStateNull,
	}
}

func NewSsh6ValueUnknown() Ssh6Value {
	return Ssh6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSsh6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ssh6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ssh6Value Attribute Value",
				"While creating a Ssh6Value value, a missing attribute value was detected. "+
					"A Ssh6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ssh6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ssh6Value Attribute Type",
				"While creating a Ssh6Value value, an invalid attribute value was detected. "+
					"A Ssh6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ssh6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ssh6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ssh6Value Attribute Value",
				"While creating a Ssh6Value value, an extra attribute value was detected. "+
					"A Ssh6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ssh6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSsh6ValueUnknown(), diags
	}

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return NewSsh6ValueUnknown(), diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	enableSsmAttribute, ok := attributes["enable_ssm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ssm is missing from object`)

		return NewSsh6ValueUnknown(), diags
	}

	enableSsmVal, ok := enableSsmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ssm expected to be basetypes.BoolValue, was: %T`, enableSsmAttribute))
	}

	publicKeyAttribute, ok := attributes["public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key is missing from object`)

		return NewSsh6ValueUnknown(), diags
	}

	publicKeyVal, ok := publicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key expected to be basetypes.StringValue, was: %T`, publicKeyAttribute))
	}

	publicKeyNameAttribute, ok := attributes["public_key_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key_name is missing from object`)

		return NewSsh6ValueUnknown(), diags
	}

	publicKeyNameVal, ok := publicKeyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key_name expected to be basetypes.StringValue, was: %T`, publicKeyNameAttribute))
	}

	sourceSecurityGroupIdsAttribute, ok := attributes["source_security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_security_group_ids is missing from object`)

		return NewSsh6ValueUnknown(), diags
	}

	sourceSecurityGroupIdsVal, ok := sourceSecurityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_security_group_ids expected to be basetypes.ListValue, was: %T`, sourceSecurityGroupIdsAttribute))
	}

	if diags.HasError() {
		return NewSsh6ValueUnknown(), diags
	}

	return Ssh6Value{
		Allow:                  allowVal,
		EnableSsm:              enableSsmVal,
		PublicKey:              publicKeyVal,
		PublicKeyName:          publicKeyNameVal,
		SourceSecurityGroupIds: sourceSecurityGroupIdsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSsh6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ssh6Value {
	object, diags := NewSsh6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSsh6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ssh6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSsh6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSsh6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSsh6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSsh6ValueMust(Ssh6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ssh6Type) ValueType(ctx context.Context) attr.Value {
	return Ssh6Value{}
}

var _ basetypes.ObjectValuable = Ssh6Value{}

type Ssh6Value struct {
	Allow                  basetypes.BoolValue   `tfsdk:"allow"`
	EnableSsm              basetypes.BoolValue   `tfsdk:"enable_ssm"`
	PublicKey              basetypes.StringValue `tfsdk:"public_key"`
	PublicKeyName          basetypes.StringValue `tfsdk:"public_key_name"`
	SourceSecurityGroupIds basetypes.ListValue   `tfsdk:"source_security_group_ids"`
	state                  attr.ValueState
}

func (v Ssh6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["allow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_ssm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["public_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["public_key_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_security_group_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Allow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow"] = val

		val, err = v.EnableSsm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ssm"] = val

		val, err = v.PublicKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_key"] = val

		val, err = v.PublicKeyName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_key_name"] = val

		val, err = v.SourceSecurityGroupIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_security_group_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ssh6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ssh6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ssh6Value) String() string {
	return "Ssh6Value"
}

func (v Ssh6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceSecurityGroupIdsVal basetypes.ListValue
	switch {
	case v.SourceSecurityGroupIds.IsUnknown():
		sourceSecurityGroupIdsVal = types.ListUnknown(types.StringType)
	case v.SourceSecurityGroupIds.IsNull():
		sourceSecurityGroupIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		sourceSecurityGroupIdsVal, d = types.ListValue(types.StringType, v.SourceSecurityGroupIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow":           basetypes.BoolType{},
			"enable_ssm":      basetypes.BoolType{},
			"public_key":      basetypes.StringType{},
			"public_key_name": basetypes.StringType{},
			"source_security_group_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow":           basetypes.BoolType{},
		"enable_ssm":      basetypes.BoolType{},
		"public_key":      basetypes.StringType{},
		"public_key_name": basetypes.StringType{},
		"source_security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow":                     v.Allow,
			"enable_ssm":                v.EnableSsm,
			"public_key":                v.PublicKey,
			"public_key_name":           v.PublicKeyName,
			"source_security_group_ids": sourceSecurityGroupIdsVal,
		})

	return objVal, diags
}

func (v Ssh6Value) Equal(o attr.Value) bool {
	other, ok := o.(Ssh6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Allow.Equal(other.Allow) {
		return false
	}

	if !v.EnableSsm.Equal(other.EnableSsm) {
		return false
	}

	if !v.PublicKey.Equal(other.PublicKey) {
		return false
	}

	if !v.PublicKeyName.Equal(other.PublicKeyName) {
		return false
	}

	if !v.SourceSecurityGroupIds.Equal(other.SourceSecurityGroupIds) {
		return false
	}

	return true
}

func (v Ssh6Value) Type(ctx context.Context) attr.Type {
	return Ssh6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ssh6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow":           basetypes.BoolType{},
		"enable_ssm":      basetypes.BoolType{},
		"public_key":      basetypes.StringType{},
		"public_key_name": basetypes.StringType{},
		"source_security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Taints6Type{}

type Taints6Type struct {
	basetypes.ObjectType
}

func (t Taints6Type) Equal(o attr.Type) bool {
	other, ok := o.(Taints6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Taints6Type) String() string {
	return "Taints6Type"
}

func (t Taints6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Taints6Value{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaints6ValueNull() Taints6Value {
	return Taints6Value{
		state: attr.ValueStateNull,
	}
}

func NewTaints6ValueUnknown() Taints6Value {
	return Taints6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTaints6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Taints6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Taints6Value Attribute Value",
				"While creating a Taints6Value value, a missing attribute value was detected. "+
					"A Taints6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Taints6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Taints6Value Attribute Type",
				"While creating a Taints6Value value, an invalid attribute value was detected. "+
					"A Taints6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Taints6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Taints6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Taints6Value Attribute Value",
				"While creating a Taints6Value value, an extra attribute value was detected. "+
					"A Taints6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Taints6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaints6ValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTaints6ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTaints6ValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTaints6ValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTaints6ValueUnknown(), diags
	}

	return Taints6Value{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaints6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Taints6Value {
	object, diags := NewTaints6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaints6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Taints6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaints6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaints6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaints6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaints6ValueMust(Taints6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Taints6Type) ValueType(ctx context.Context) attr.Value {
	return Taints6Value{}
}

var _ basetypes.ObjectValuable = Taints6Value{}

type Taints6Value struct {
	Effect basetypes.StringValue `tfsdk:"effect"`
	Key    basetypes.StringValue `tfsdk:"key"`
	Value  basetypes.StringValue `tfsdk:"value"`
	state  attr.ValueState
}

func (v Taints6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Taints6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Taints6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Taints6Value) String() string {
	return "Taints6Value"
}

func (v Taints6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect": v.Effect,
			"key":    v.Key,
			"value":  v.Value,
		})

	return objVal, diags
}

func (v Taints6Value) Equal(o attr.Value) bool {
	other, ok := o.(Taints6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v Taints6Value) Type(ctx context.Context) attr.Type {
	return Taints6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Taints6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = UpdateConfig6Type{}

type UpdateConfig6Type struct {
	basetypes.ObjectType
}

func (t UpdateConfig6Type) Equal(o attr.Type) bool {
	other, ok := o.(UpdateConfig6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UpdateConfig6Type) String() string {
	return "UpdateConfig6Type"
}

func (t UpdateConfig6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxUnavaliableAttribute, ok := attributes["max_unavaliable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavaliable is missing from object`)

		return nil, diags
	}

	maxUnavaliableVal, ok := maxUnavaliableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavaliable expected to be basetypes.Int64Value, was: %T`, maxUnavaliableAttribute))
	}

	maxUnavaliablePercetageAttribute, ok := attributes["max_unavaliable_percetage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavaliable_percetage is missing from object`)

		return nil, diags
	}

	maxUnavaliablePercetageVal, ok := maxUnavaliablePercetageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavaliable_percetage expected to be basetypes.Int64Value, was: %T`, maxUnavaliablePercetageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UpdateConfig6Value{
		MaxUnavaliable:          maxUnavaliableVal,
		MaxUnavaliablePercetage: maxUnavaliablePercetageVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewUpdateConfig6ValueNull() UpdateConfig6Value {
	return UpdateConfig6Value{
		state: attr.ValueStateNull,
	}
}

func NewUpdateConfig6ValueUnknown() UpdateConfig6Value {
	return UpdateConfig6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewUpdateConfig6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UpdateConfig6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UpdateConfig6Value Attribute Value",
				"While creating a UpdateConfig6Value value, a missing attribute value was detected. "+
					"A UpdateConfig6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UpdateConfig6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UpdateConfig6Value Attribute Type",
				"While creating a UpdateConfig6Value value, an invalid attribute value was detected. "+
					"A UpdateConfig6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UpdateConfig6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UpdateConfig6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UpdateConfig6Value Attribute Value",
				"While creating a UpdateConfig6Value value, an extra attribute value was detected. "+
					"A UpdateConfig6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UpdateConfig6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUpdateConfig6ValueUnknown(), diags
	}

	maxUnavaliableAttribute, ok := attributes["max_unavaliable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavaliable is missing from object`)

		return NewUpdateConfig6ValueUnknown(), diags
	}

	maxUnavaliableVal, ok := maxUnavaliableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavaliable expected to be basetypes.Int64Value, was: %T`, maxUnavaliableAttribute))
	}

	maxUnavaliablePercetageAttribute, ok := attributes["max_unavaliable_percetage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavaliable_percetage is missing from object`)

		return NewUpdateConfig6ValueUnknown(), diags
	}

	maxUnavaliablePercetageVal, ok := maxUnavaliablePercetageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavaliable_percetage expected to be basetypes.Int64Value, was: %T`, maxUnavaliablePercetageAttribute))
	}

	if diags.HasError() {
		return NewUpdateConfig6ValueUnknown(), diags
	}

	return UpdateConfig6Value{
		MaxUnavaliable:          maxUnavaliableVal,
		MaxUnavaliablePercetage: maxUnavaliablePercetageVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewUpdateConfig6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UpdateConfig6Value {
	object, diags := NewUpdateConfig6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUpdateConfig6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UpdateConfig6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUpdateConfig6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUpdateConfig6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUpdateConfig6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUpdateConfig6ValueMust(UpdateConfig6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t UpdateConfig6Type) ValueType(ctx context.Context) attr.Value {
	return UpdateConfig6Value{}
}

var _ basetypes.ObjectValuable = UpdateConfig6Value{}

type UpdateConfig6Value struct {
	MaxUnavaliable          basetypes.Int64Value `tfsdk:"max_unavaliable"`
	MaxUnavaliablePercetage basetypes.Int64Value `tfsdk:"max_unavaliable_percetage"`
	state                   attr.ValueState
}

func (v UpdateConfig6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["max_unavaliable"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_unavaliable_percetage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MaxUnavaliable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavaliable"] = val

		val, err = v.MaxUnavaliablePercetage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavaliable_percetage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UpdateConfig6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UpdateConfig6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UpdateConfig6Value) String() string {
	return "UpdateConfig6Value"
}

func (v UpdateConfig6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_unavaliable":           basetypes.Int64Type{},
		"max_unavaliable_percetage": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_unavaliable":           v.MaxUnavaliable,
			"max_unavaliable_percetage": v.MaxUnavaliablePercetage,
		})

	return objVal, diags
}

func (v UpdateConfig6Value) Equal(o attr.Value) bool {
	other, ok := o.(UpdateConfig6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxUnavaliable.Equal(other.MaxUnavaliable) {
		return false
	}

	if !v.MaxUnavaliablePercetage.Equal(other.MaxUnavaliablePercetage) {
		return false
	}

	return true
}

func (v UpdateConfig6Value) Type(ctx context.Context) attr.Type {
	return UpdateConfig6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UpdateConfig6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_unavaliable":           basetypes.Int64Type{},
		"max_unavaliable_percetage": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = AccessConfigType{}

type AccessConfigType struct {
	basetypes.ObjectType
}

func (t AccessConfigType) Equal(o attr.Type) bool {
	other, ok := o.(AccessConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccessConfigType) String() string {
	return "AccessConfigType"
}

func (t AccessConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessEntriesAttribute, ok := attributes["access_entries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_entries is missing from object`)

		return nil, diags
	}

	accessEntriesVal, ok := accessEntriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_entries expected to be basetypes.SetValue, was: %T`, accessEntriesAttribute))
	}

	authenticationModeAttribute, ok := attributes["authentication_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_mode is missing from object`)

		return nil, diags
	}

	authenticationModeVal, ok := authenticationModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_mode expected to be basetypes.StringValue, was: %T`, authenticationModeAttribute))
	}

	bootstrapClusterCreatorAdminPermissionsAttribute, ok := attributes["bootstrap_cluster_creator_admin_permissions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_cluster_creator_admin_permissions is missing from object`)

		return nil, diags
	}

	bootstrapClusterCreatorAdminPermissionsVal, ok := bootstrapClusterCreatorAdminPermissionsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_cluster_creator_admin_permissions expected to be basetypes.BoolValue, was: %T`, bootstrapClusterCreatorAdminPermissionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccessConfigValue{
		AccessEntries:                           accessEntriesVal,
		AuthenticationMode:                      authenticationModeVal,
		BootstrapClusterCreatorAdminPermissions: bootstrapClusterCreatorAdminPermissionsVal,
		state:                                   attr.ValueStateKnown,
	}, diags
}

func NewAccessConfigValueNull() AccessConfigValue {
	return AccessConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewAccessConfigValueUnknown() AccessConfigValue {
	return AccessConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccessConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccessConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccessConfigValue Attribute Value",
				"While creating a AccessConfigValue value, a missing attribute value was detected. "+
					"A AccessConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccessConfigValue Attribute Type",
				"While creating a AccessConfigValue value, an invalid attribute value was detected. "+
					"A AccessConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccessConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccessConfigValue Attribute Value",
				"While creating a AccessConfigValue value, an extra attribute value was detected. "+
					"A AccessConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccessConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccessConfigValueUnknown(), diags
	}

	accessEntriesAttribute, ok := attributes["access_entries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_entries is missing from object`)

		return NewAccessConfigValueUnknown(), diags
	}

	accessEntriesVal, ok := accessEntriesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_entries expected to be basetypes.SetValue, was: %T`, accessEntriesAttribute))
	}

	authenticationModeAttribute, ok := attributes["authentication_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_mode is missing from object`)

		return NewAccessConfigValueUnknown(), diags
	}

	authenticationModeVal, ok := authenticationModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_mode expected to be basetypes.StringValue, was: %T`, authenticationModeAttribute))
	}

	bootstrapClusterCreatorAdminPermissionsAttribute, ok := attributes["bootstrap_cluster_creator_admin_permissions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_cluster_creator_admin_permissions is missing from object`)

		return NewAccessConfigValueUnknown(), diags
	}

	bootstrapClusterCreatorAdminPermissionsVal, ok := bootstrapClusterCreatorAdminPermissionsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_cluster_creator_admin_permissions expected to be basetypes.BoolValue, was: %T`, bootstrapClusterCreatorAdminPermissionsAttribute))
	}

	if diags.HasError() {
		return NewAccessConfigValueUnknown(), diags
	}

	return AccessConfigValue{
		AccessEntries:                           accessEntriesVal,
		AuthenticationMode:                      authenticationModeVal,
		BootstrapClusterCreatorAdminPermissions: bootstrapClusterCreatorAdminPermissionsVal,
		state:                                   attr.ValueStateKnown,
	}, diags
}

func NewAccessConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccessConfigValue {
	object, diags := NewAccessConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccessConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccessConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccessConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccessConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccessConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccessConfigValueMust(AccessConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccessConfigType) ValueType(ctx context.Context) attr.Value {
	return AccessConfigValue{}
}

var _ basetypes.ObjectValuable = AccessConfigValue{}

type AccessConfigValue struct {
	AccessEntries                           basetypes.SetValue    `tfsdk:"access_entries"`
	AuthenticationMode                      basetypes.StringValue `tfsdk:"authentication_mode"`
	BootstrapClusterCreatorAdminPermissions basetypes.BoolValue   `tfsdk:"bootstrap_cluster_creator_admin_permissions"`
	state                                   attr.ValueState
}

func (v AccessConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["access_entries"] = basetypes.SetType{
		ElemType: AccessEntriesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["authentication_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bootstrap_cluster_creator_admin_permissions"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AccessEntries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_entries"] = val

		val, err = v.AuthenticationMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authentication_mode"] = val

		val, err = v.BootstrapClusterCreatorAdminPermissions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bootstrap_cluster_creator_admin_permissions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccessConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccessConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccessConfigValue) String() string {
	return "AccessConfigValue"
}

func (v AccessConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	accessEntries := types.SetValueMust(
		AccessEntriesType{
			basetypes.ObjectType{
				AttrTypes: AccessEntriesValue{}.AttributeTypes(ctx),
			},
		},
		v.AccessEntries.Elements(),
	)

	if v.AccessEntries.IsNull() {
		accessEntries = types.SetNull(
			AccessEntriesType{
				basetypes.ObjectType{
					AttrTypes: AccessEntriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AccessEntries.IsUnknown() {
		accessEntries = types.SetUnknown(
			AccessEntriesType{
				basetypes.ObjectType{
					AttrTypes: AccessEntriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"access_entries": basetypes.SetType{
			ElemType: AccessEntriesValue{}.Type(ctx),
		},
		"authentication_mode":                         basetypes.StringType{},
		"bootstrap_cluster_creator_admin_permissions": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_entries":                              accessEntries,
			"authentication_mode":                         v.AuthenticationMode,
			"bootstrap_cluster_creator_admin_permissions": v.BootstrapClusterCreatorAdminPermissions,
		})

	return objVal, diags
}

func (v AccessConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(AccessConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessEntries.Equal(other.AccessEntries) {
		return false
	}

	if !v.AuthenticationMode.Equal(other.AuthenticationMode) {
		return false
	}

	if !v.BootstrapClusterCreatorAdminPermissions.Equal(other.BootstrapClusterCreatorAdminPermissions) {
		return false
	}

	return true
}

func (v AccessConfigValue) Type(ctx context.Context) attr.Type {
	return AccessConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccessConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_entries": basetypes.SetType{
			ElemType: AccessEntriesValue{}.Type(ctx),
		},
		"authentication_mode":                         basetypes.StringType{},
		"bootstrap_cluster_creator_admin_permissions": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = AccessEntriesType{}

type AccessEntriesType struct {
	basetypes.ObjectType
}

func (t AccessEntriesType) Equal(o attr.Type) bool {
	other, ok := o.(AccessEntriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccessEntriesType) String() string {
	return "AccessEntriesType"
}

func (t AccessEntriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessPoliciesAttribute, ok := attributes["access_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_policies is missing from object`)

		return nil, diags
	}

	accessPoliciesVal, ok := accessPoliciesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_policies expected to be basetypes.SetValue, was: %T`, accessPoliciesAttribute))
	}

	kubernetesGroupsAttribute, ok := attributes["kubernetes_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_groups is missing from object`)

		return nil, diags
	}

	kubernetesGroupsVal, ok := kubernetesGroupsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_groups expected to be basetypes.SetValue, was: %T`, kubernetesGroupsAttribute))
	}

	kubernetesUsernameAttribute, ok := attributes["kubernetes_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_username is missing from object`)

		return nil, diags
	}

	kubernetesUsernameVal, ok := kubernetesUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_username expected to be basetypes.StringValue, was: %T`, kubernetesUsernameAttribute))
	}

	principalArnAttribute, ok := attributes["principal_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal_arn is missing from object`)

		return nil, diags
	}

	principalArnVal, ok := principalArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal_arn expected to be basetypes.StringValue, was: %T`, principalArnAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccessEntriesValue{
		AccessPolicies:     accessPoliciesVal,
		KubernetesGroups:   kubernetesGroupsVal,
		KubernetesUsername: kubernetesUsernameVal,
		PrincipalArn:       principalArnVal,
		Tags:               tagsVal,
		AccessEntriesType:  typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAccessEntriesValueNull() AccessEntriesValue {
	return AccessEntriesValue{
		state: attr.ValueStateNull,
	}
}

func NewAccessEntriesValueUnknown() AccessEntriesValue {
	return AccessEntriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccessEntriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccessEntriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccessEntriesValue Attribute Value",
				"While creating a AccessEntriesValue value, a missing attribute value was detected. "+
					"A AccessEntriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessEntriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccessEntriesValue Attribute Type",
				"While creating a AccessEntriesValue value, an invalid attribute value was detected. "+
					"A AccessEntriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessEntriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccessEntriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccessEntriesValue Attribute Value",
				"While creating a AccessEntriesValue value, an extra attribute value was detected. "+
					"A AccessEntriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccessEntriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccessEntriesValueUnknown(), diags
	}

	accessPoliciesAttribute, ok := attributes["access_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_policies is missing from object`)

		return NewAccessEntriesValueUnknown(), diags
	}

	accessPoliciesVal, ok := accessPoliciesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_policies expected to be basetypes.SetValue, was: %T`, accessPoliciesAttribute))
	}

	kubernetesGroupsAttribute, ok := attributes["kubernetes_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_groups is missing from object`)

		return NewAccessEntriesValueUnknown(), diags
	}

	kubernetesGroupsVal, ok := kubernetesGroupsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_groups expected to be basetypes.SetValue, was: %T`, kubernetesGroupsAttribute))
	}

	kubernetesUsernameAttribute, ok := attributes["kubernetes_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_username is missing from object`)

		return NewAccessEntriesValueUnknown(), diags
	}

	kubernetesUsernameVal, ok := kubernetesUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_username expected to be basetypes.StringValue, was: %T`, kubernetesUsernameAttribute))
	}

	principalArnAttribute, ok := attributes["principal_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal_arn is missing from object`)

		return NewAccessEntriesValueUnknown(), diags
	}

	principalArnVal, ok := principalArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal_arn expected to be basetypes.StringValue, was: %T`, principalArnAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewAccessEntriesValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAccessEntriesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAccessEntriesValueUnknown(), diags
	}

	return AccessEntriesValue{
		AccessPolicies:     accessPoliciesVal,
		KubernetesGroups:   kubernetesGroupsVal,
		KubernetesUsername: kubernetesUsernameVal,
		PrincipalArn:       principalArnVal,
		Tags:               tagsVal,
		AccessEntriesType:  typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAccessEntriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccessEntriesValue {
	object, diags := NewAccessEntriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccessEntriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccessEntriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccessEntriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccessEntriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccessEntriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccessEntriesValueMust(AccessEntriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccessEntriesType) ValueType(ctx context.Context) attr.Value {
	return AccessEntriesValue{}
}

var _ basetypes.ObjectValuable = AccessEntriesValue{}

type AccessEntriesValue struct {
	AccessPolicies     basetypes.SetValue    `tfsdk:"access_policies"`
	KubernetesGroups   basetypes.SetValue    `tfsdk:"kubernetes_groups"`
	KubernetesUsername basetypes.StringValue `tfsdk:"kubernetes_username"`
	PrincipalArn       basetypes.StringValue `tfsdk:"principal_arn"`
	Tags               basetypes.MapValue    `tfsdk:"tags"`
	AccessEntriesType  basetypes.StringValue `tfsdk:"type"`
	state              attr.ValueState
}

func (v AccessEntriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["access_policies"] = basetypes.SetType{
		ElemType: AccessPoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["kubernetes_groups"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kubernetes_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["principal_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AccessPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_policies"] = val

		val, err = v.KubernetesGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubernetes_groups"] = val

		val, err = v.KubernetesUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubernetes_username"] = val

		val, err = v.PrincipalArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["principal_arn"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.AccessEntriesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccessEntriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccessEntriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccessEntriesValue) String() string {
	return "AccessEntriesValue"
}

func (v AccessEntriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	accessPolicies := types.SetValueMust(
		AccessPoliciesType{
			basetypes.ObjectType{
				AttrTypes: AccessPoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.AccessPolicies.Elements(),
	)

	if v.AccessPolicies.IsNull() {
		accessPolicies = types.SetNull(
			AccessPoliciesType{
				basetypes.ObjectType{
					AttrTypes: AccessPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AccessPolicies.IsUnknown() {
		accessPolicies = types.SetUnknown(
			AccessPoliciesType{
				basetypes.ObjectType{
					AttrTypes: AccessPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var kubernetesGroupsVal basetypes.SetValue
	switch {
	case v.KubernetesGroups.IsUnknown():
		kubernetesGroupsVal = types.SetUnknown(types.StringType)
	case v.KubernetesGroups.IsNull():
		kubernetesGroupsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		kubernetesGroupsVal, d = types.SetValue(types.StringType, v.KubernetesGroups.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"access_policies": basetypes.SetType{
				ElemType: AccessPoliciesValue{}.Type(ctx),
			},
			"kubernetes_groups": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kubernetes_username": basetypes.StringType{},
			"principal_arn":       basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"access_policies": basetypes.SetType{
				ElemType: AccessPoliciesValue{}.Type(ctx),
			},
			"kubernetes_groups": basetypes.SetType{
				ElemType: types.StringType,
			},
			"kubernetes_username": basetypes.StringType{},
			"principal_arn":       basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"access_policies": basetypes.SetType{
			ElemType: AccessPoliciesValue{}.Type(ctx),
		},
		"kubernetes_groups": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kubernetes_username": basetypes.StringType{},
		"principal_arn":       basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_policies":     accessPolicies,
			"kubernetes_groups":   kubernetesGroupsVal,
			"kubernetes_username": v.KubernetesUsername,
			"principal_arn":       v.PrincipalArn,
			"tags":                tagsVal,
			"type":                v.AccessEntriesType,
		})

	return objVal, diags
}

func (v AccessEntriesValue) Equal(o attr.Value) bool {
	other, ok := o.(AccessEntriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessPolicies.Equal(other.AccessPolicies) {
		return false
	}

	if !v.KubernetesGroups.Equal(other.KubernetesGroups) {
		return false
	}

	if !v.KubernetesUsername.Equal(other.KubernetesUsername) {
		return false
	}

	if !v.PrincipalArn.Equal(other.PrincipalArn) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.AccessEntriesType.Equal(other.AccessEntriesType) {
		return false
	}

	return true
}

func (v AccessEntriesValue) Type(ctx context.Context) attr.Type {
	return AccessEntriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccessEntriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_policies": basetypes.SetType{
			ElemType: AccessPoliciesValue{}.Type(ctx),
		},
		"kubernetes_groups": basetypes.SetType{
			ElemType: types.StringType,
		},
		"kubernetes_username": basetypes.StringType{},
		"principal_arn":       basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AccessPoliciesType{}

type AccessPoliciesType struct {
	basetypes.ObjectType
}

func (t AccessPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(AccessPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccessPoliciesType) String() string {
	return "AccessPoliciesType"
}

func (t AccessPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessScopeAttribute, ok := attributes["access_scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_scope is missing from object`)

		return nil, diags
	}

	accessScopeVal, ok := accessScopeAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_scope expected to be basetypes.SetValue, was: %T`, accessScopeAttribute))
	}

	policyArnAttribute, ok := attributes["policy_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_arn is missing from object`)

		return nil, diags
	}

	policyArnVal, ok := policyArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_arn expected to be basetypes.StringValue, was: %T`, policyArnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccessPoliciesValue{
		AccessScope: accessScopeVal,
		PolicyArn:   policyArnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAccessPoliciesValueNull() AccessPoliciesValue {
	return AccessPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewAccessPoliciesValueUnknown() AccessPoliciesValue {
	return AccessPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccessPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccessPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccessPoliciesValue Attribute Value",
				"While creating a AccessPoliciesValue value, a missing attribute value was detected. "+
					"A AccessPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccessPoliciesValue Attribute Type",
				"While creating a AccessPoliciesValue value, an invalid attribute value was detected. "+
					"A AccessPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccessPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccessPoliciesValue Attribute Value",
				"While creating a AccessPoliciesValue value, an extra attribute value was detected. "+
					"A AccessPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccessPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccessPoliciesValueUnknown(), diags
	}

	accessScopeAttribute, ok := attributes["access_scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_scope is missing from object`)

		return NewAccessPoliciesValueUnknown(), diags
	}

	accessScopeVal, ok := accessScopeAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_scope expected to be basetypes.SetValue, was: %T`, accessScopeAttribute))
	}

	policyArnAttribute, ok := attributes["policy_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_arn is missing from object`)

		return NewAccessPoliciesValueUnknown(), diags
	}

	policyArnVal, ok := policyArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_arn expected to be basetypes.StringValue, was: %T`, policyArnAttribute))
	}

	if diags.HasError() {
		return NewAccessPoliciesValueUnknown(), diags
	}

	return AccessPoliciesValue{
		AccessScope: accessScopeVal,
		PolicyArn:   policyArnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAccessPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccessPoliciesValue {
	object, diags := NewAccessPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccessPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccessPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccessPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccessPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccessPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccessPoliciesValueMust(AccessPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccessPoliciesType) ValueType(ctx context.Context) attr.Value {
	return AccessPoliciesValue{}
}

var _ basetypes.ObjectValuable = AccessPoliciesValue{}

type AccessPoliciesValue struct {
	AccessScope basetypes.SetValue    `tfsdk:"access_scope"`
	PolicyArn   basetypes.StringValue `tfsdk:"policy_arn"`
	state       attr.ValueState
}

func (v AccessPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["access_scope"] = basetypes.SetType{
		ElemType: AccessScopeValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["policy_arn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AccessScope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_scope"] = val

		val, err = v.PolicyArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_arn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccessPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccessPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccessPoliciesValue) String() string {
	return "AccessPoliciesValue"
}

func (v AccessPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	accessScope := types.SetValueMust(
		AccessScopeType{
			basetypes.ObjectType{
				AttrTypes: AccessScopeValue{}.AttributeTypes(ctx),
			},
		},
		v.AccessScope.Elements(),
	)

	if v.AccessScope.IsNull() {
		accessScope = types.SetNull(
			AccessScopeType{
				basetypes.ObjectType{
					AttrTypes: AccessScopeValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AccessScope.IsUnknown() {
		accessScope = types.SetUnknown(
			AccessScopeType{
				basetypes.ObjectType{
					AttrTypes: AccessScopeValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"access_scope": basetypes.SetType{
			ElemType: AccessScopeValue{}.Type(ctx),
		},
		"policy_arn": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_scope": accessScope,
			"policy_arn":   v.PolicyArn,
		})

	return objVal, diags
}

func (v AccessPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(AccessPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessScope.Equal(other.AccessScope) {
		return false
	}

	if !v.PolicyArn.Equal(other.PolicyArn) {
		return false
	}

	return true
}

func (v AccessPoliciesValue) Type(ctx context.Context) attr.Type {
	return AccessPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccessPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_scope": basetypes.SetType{
			ElemType: AccessScopeValue{}.Type(ctx),
		},
		"policy_arn": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AccessScopeType{}

type AccessScopeType struct {
	basetypes.ObjectType
}

func (t AccessScopeType) Equal(o attr.Type) bool {
	other, ok := o.(AccessScopeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccessScopeType) String() string {
	return "AccessScopeType"
}

func (t AccessScopeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	namespacesAttribute, ok := attributes["namespaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespaces is missing from object`)

		return nil, diags
	}

	namespacesVal, ok := namespacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespaces expected to be basetypes.SetValue, was: %T`, namespacesAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccessScopeValue{
		Namespaces:      namespacesVal,
		AccessScopeType: typeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAccessScopeValueNull() AccessScopeValue {
	return AccessScopeValue{
		state: attr.ValueStateNull,
	}
}

func NewAccessScopeValueUnknown() AccessScopeValue {
	return AccessScopeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccessScopeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccessScopeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccessScopeValue Attribute Value",
				"While creating a AccessScopeValue value, a missing attribute value was detected. "+
					"A AccessScopeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessScopeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccessScopeValue Attribute Type",
				"While creating a AccessScopeValue value, an invalid attribute value was detected. "+
					"A AccessScopeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessScopeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccessScopeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccessScopeValue Attribute Value",
				"While creating a AccessScopeValue value, an extra attribute value was detected. "+
					"A AccessScopeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccessScopeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccessScopeValueUnknown(), diags
	}

	namespacesAttribute, ok := attributes["namespaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespaces is missing from object`)

		return NewAccessScopeValueUnknown(), diags
	}

	namespacesVal, ok := namespacesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespaces expected to be basetypes.SetValue, was: %T`, namespacesAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAccessScopeValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAccessScopeValueUnknown(), diags
	}

	return AccessScopeValue{
		Namespaces:      namespacesVal,
		AccessScopeType: typeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAccessScopeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccessScopeValue {
	object, diags := NewAccessScopeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccessScopeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccessScopeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccessScopeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccessScopeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccessScopeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccessScopeValueMust(AccessScopeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccessScopeType) ValueType(ctx context.Context) attr.Value {
	return AccessScopeValue{}
}

var _ basetypes.ObjectValuable = AccessScopeValue{}

type AccessScopeValue struct {
	Namespaces      basetypes.SetValue    `tfsdk:"namespaces"`
	AccessScopeType basetypes.StringValue `tfsdk:"type"`
	state           attr.ValueState
}

func (v AccessScopeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["namespaces"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Namespaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespaces"] = val

		val, err = v.AccessScopeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccessScopeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccessScopeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccessScopeValue) String() string {
	return "AccessScopeValue"
}

func (v AccessScopeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var namespacesVal basetypes.SetValue
	switch {
	case v.Namespaces.IsUnknown():
		namespacesVal = types.SetUnknown(types.StringType)
	case v.Namespaces.IsNull():
		namespacesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		namespacesVal, d = types.SetValue(types.StringType, v.Namespaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"namespaces": basetypes.SetType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"namespaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"namespaces": namespacesVal,
			"type":       v.AccessScopeType,
		})

	return objVal, diags
}

func (v AccessScopeValue) Equal(o attr.Value) bool {
	other, ok := o.(AccessScopeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Namespaces.Equal(other.Namespaces) {
		return false
	}

	if !v.AccessScopeType.Equal(other.AccessScopeType) {
		return false
	}

	return true
}

func (v AccessScopeValue) Type(ctx context.Context) attr.Type {
	return AccessScopeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccessScopeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"namespaces": basetypes.SetType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AddonsType{}

type AddonsType struct {
	basetypes.ObjectType
}

func (t AddonsType) Equal(o attr.Type) bool {
	other, ok := o.(AddonsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AddonsType) String() string {
	return "AddonsType"
}

func (t AddonsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachPolicy3Attribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy3 is missing from object`)

		return nil, diags
	}

	attachPolicy3Val, ok := attachPolicy3Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy3 expected to be basetypes.SetValue, was: %T`, attachPolicy3Attribute))
	}

	attachPolicyArns3Attribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns3 is missing from object`)

		return nil, diags
	}

	attachPolicyArns3Val, ok := attachPolicyArns3Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns3 expected to be basetypes.SetValue, was: %T`, attachPolicyArns3Attribute))
	}

	attachPolicyV22Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2_2 is missing from object`)

		return nil, diags
	}

	attachPolicyV22Val, ok := attachPolicyV22Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2_2 expected to be basetypes.StringValue, was: %T`, attachPolicyV22Attribute))
	}

	configurationValuesAttribute, ok := attributes["configuration_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration_values is missing from object`)

		return nil, diags
	}

	configurationValuesVal, ok := configurationValuesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration_values expected to be basetypes.StringValue, was: %T`, configurationValuesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	permissionsBoundary2Attribute, ok := attributes["permissions_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permissions_boundary2 is missing from object`)

		return nil, diags
	}

	permissionsBoundary2Val, ok := permissionsBoundary2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permissions_boundary2 expected to be basetypes.StringValue, was: %T`, permissionsBoundary2Attribute))
	}

	podIdentityAssociations2Attribute, ok := attributes["pod_identity_associations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_identity_associations2 is missing from object`)

		return nil, diags
	}

	podIdentityAssociations2Val, ok := podIdentityAssociations2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_identity_associations2 expected to be basetypes.SetValue, was: %T`, podIdentityAssociations2Attribute))
	}

	serviceAccountRoleArnAttribute, ok := attributes["service_account_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_role_arn is missing from object`)

		return nil, diags
	}

	serviceAccountRoleArnVal, ok := serviceAccountRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_role_arn expected to be basetypes.StringValue, was: %T`, serviceAccountRoleArnAttribute))
	}

	tags4Attribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags4 is missing from object`)

		return nil, diags
	}

	tags4Val, ok := tags4Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags4 expected to be basetypes.MapValue, was: %T`, tags4Attribute))
	}

	useDefaultPodIdentityAssociationsAttribute, ok := attributes["use_default_pod_identity_associations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_default_pod_identity_associations is missing from object`)

		return nil, diags
	}

	useDefaultPodIdentityAssociationsVal, ok := useDefaultPodIdentityAssociationsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_default_pod_identity_associations expected to be basetypes.BoolValue, was: %T`, useDefaultPodIdentityAssociationsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	wellKnownPolicies3Attribute, ok := attributes["well_known_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`well_known_policies3 is missing from object`)

		return nil, diags
	}

	wellKnownPolicies3Val, ok := wellKnownPolicies3Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`well_known_policies3 expected to be basetypes.SetValue, was: %T`, wellKnownPolicies3Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AddonsValue{
		AttachPolicy3:                     attachPolicy3Val,
		AttachPolicyArns3:                 attachPolicyArns3Val,
		AttachPolicyV22:                   attachPolicyV22Val,
		ConfigurationValues:               configurationValuesVal,
		Name:                              nameVal,
		PermissionsBoundary2:              permissionsBoundary2Val,
		PodIdentityAssociations2:          podIdentityAssociations2Val,
		ServiceAccountRoleArn:             serviceAccountRoleArnVal,
		Tags4:                             tags4Val,
		UseDefaultPodIdentityAssociations: useDefaultPodIdentityAssociationsVal,
		Version:                           versionVal,
		WellKnownPolicies3:                wellKnownPolicies3Val,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewAddonsValueNull() AddonsValue {
	return AddonsValue{
		state: attr.ValueStateNull,
	}
}

func NewAddonsValueUnknown() AddonsValue {
	return AddonsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAddonsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AddonsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AddonsValue Attribute Value",
				"While creating a AddonsValue value, a missing attribute value was detected. "+
					"A AddonsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AddonsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AddonsValue Attribute Type",
				"While creating a AddonsValue value, an invalid attribute value was detected. "+
					"A AddonsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AddonsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AddonsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AddonsValue Attribute Value",
				"While creating a AddonsValue value, an extra attribute value was detected. "+
					"A AddonsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AddonsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAddonsValueUnknown(), diags
	}

	attachPolicy3Attribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy3 is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	attachPolicy3Val, ok := attachPolicy3Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy3 expected to be basetypes.SetValue, was: %T`, attachPolicy3Attribute))
	}

	attachPolicyArns3Attribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns3 is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	attachPolicyArns3Val, ok := attachPolicyArns3Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns3 expected to be basetypes.SetValue, was: %T`, attachPolicyArns3Attribute))
	}

	attachPolicyV22Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2_2 is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	attachPolicyV22Val, ok := attachPolicyV22Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2_2 expected to be basetypes.StringValue, was: %T`, attachPolicyV22Attribute))
	}

	configurationValuesAttribute, ok := attributes["configuration_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration_values is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	configurationValuesVal, ok := configurationValuesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration_values expected to be basetypes.StringValue, was: %T`, configurationValuesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	permissionsBoundary2Attribute, ok := attributes["permissions_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permissions_boundary2 is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	permissionsBoundary2Val, ok := permissionsBoundary2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permissions_boundary2 expected to be basetypes.StringValue, was: %T`, permissionsBoundary2Attribute))
	}

	podIdentityAssociations2Attribute, ok := attributes["pod_identity_associations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_identity_associations2 is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	podIdentityAssociations2Val, ok := podIdentityAssociations2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_identity_associations2 expected to be basetypes.SetValue, was: %T`, podIdentityAssociations2Attribute))
	}

	serviceAccountRoleArnAttribute, ok := attributes["service_account_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_role_arn is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	serviceAccountRoleArnVal, ok := serviceAccountRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_role_arn expected to be basetypes.StringValue, was: %T`, serviceAccountRoleArnAttribute))
	}

	tags4Attribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags4 is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	tags4Val, ok := tags4Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags4 expected to be basetypes.MapValue, was: %T`, tags4Attribute))
	}

	useDefaultPodIdentityAssociationsAttribute, ok := attributes["use_default_pod_identity_associations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_default_pod_identity_associations is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	useDefaultPodIdentityAssociationsVal, ok := useDefaultPodIdentityAssociationsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_default_pod_identity_associations expected to be basetypes.BoolValue, was: %T`, useDefaultPodIdentityAssociationsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	wellKnownPolicies3Attribute, ok := attributes["well_known_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`well_known_policies3 is missing from object`)

		return NewAddonsValueUnknown(), diags
	}

	wellKnownPolicies3Val, ok := wellKnownPolicies3Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`well_known_policies3 expected to be basetypes.SetValue, was: %T`, wellKnownPolicies3Attribute))
	}

	if diags.HasError() {
		return NewAddonsValueUnknown(), diags
	}

	return AddonsValue{
		AttachPolicy3:                     attachPolicy3Val,
		AttachPolicyArns3:                 attachPolicyArns3Val,
		AttachPolicyV22:                   attachPolicyV22Val,
		ConfigurationValues:               configurationValuesVal,
		Name:                              nameVal,
		PermissionsBoundary2:              permissionsBoundary2Val,
		PodIdentityAssociations2:          podIdentityAssociations2Val,
		ServiceAccountRoleArn:             serviceAccountRoleArnVal,
		Tags4:                             tags4Val,
		UseDefaultPodIdentityAssociations: useDefaultPodIdentityAssociationsVal,
		Version:                           versionVal,
		WellKnownPolicies3:                wellKnownPolicies3Val,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewAddonsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AddonsValue {
	object, diags := NewAddonsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAddonsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AddonsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAddonsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAddonsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAddonsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAddonsValueMust(AddonsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AddonsType) ValueType(ctx context.Context) attr.Value {
	return AddonsValue{}
}

var _ basetypes.ObjectValuable = AddonsValue{}

type AddonsValue struct {
	AttachPolicy3                     basetypes.SetValue    `tfsdk:"attach_policy"`
	AttachPolicyArns3                 basetypes.SetValue    `tfsdk:"attach_policy_arns"`
	AttachPolicyV22                   basetypes.StringValue `tfsdk:"attach_policy_v2"`
	ConfigurationValues               basetypes.StringValue `tfsdk:"configuration_values"`
	Name                              basetypes.StringValue `tfsdk:"name"`
	PermissionsBoundary2              basetypes.StringValue `tfsdk:"permissions_boundary"`
	PodIdentityAssociations2          basetypes.SetValue    `tfsdk:"pod_identity_associations"`
	ServiceAccountRoleArn             basetypes.StringValue `tfsdk:"service_account_role_arn"`
	Tags4                             basetypes.MapValue    `tfsdk:"tags"`
	UseDefaultPodIdentityAssociations basetypes.BoolValue   `tfsdk:"use_default_pod_identity_associations"`
	Version                           basetypes.StringValue `tfsdk:"version"`
	WellKnownPolicies3                basetypes.SetValue    `tfsdk:"well_known_policies"`
	state                             attr.ValueState
}

func (v AddonsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["attach_policy"] = basetypes.SetType{
		ElemType: AttachPolicy3Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["attach_policy_arns"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["attach_policy_v2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["configuration_values"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permissions_boundary"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod_identity_associations"] = basetypes.SetType{
		ElemType: PodIdentityAssociations2Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_account_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["use_default_pod_identity_associations"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["well_known_policies"] = basetypes.SetType{
		ElemType: WellKnownPolicies3Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AttachPolicy3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy"] = val

		val, err = v.AttachPolicyArns3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_arns"] = val

		val, err = v.AttachPolicyV22.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_v2"] = val

		val, err = v.ConfigurationValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configuration_values"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PermissionsBoundary2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permissions_boundary"] = val

		val, err = v.PodIdentityAssociations2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_identity_associations"] = val

		val, err = v.ServiceAccountRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_account_role_arn"] = val

		val, err = v.Tags4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.UseDefaultPodIdentityAssociations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_default_pod_identity_associations"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.WellKnownPolicies3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["well_known_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AddonsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AddonsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AddonsValue) String() string {
	return "AddonsValue"
}

func (v AddonsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attachPolicy3 := types.SetValueMust(
		AttachPolicy3Type{
			basetypes.ObjectType{
				AttrTypes: AttachPolicy3Value{}.AttributeTypes(ctx),
			},
		},
		v.AttachPolicy3.Elements(),
	)

	if v.AttachPolicy3.IsNull() {
		attachPolicy3 = types.SetNull(
			AttachPolicy3Type{
				basetypes.ObjectType{
					AttrTypes: AttachPolicy3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AttachPolicy3.IsUnknown() {
		attachPolicy3 = types.SetUnknown(
			AttachPolicy3Type{
				basetypes.ObjectType{
					AttrTypes: AttachPolicy3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	podIdentityAssociations2 := types.SetValueMust(
		PodIdentityAssociations2Type{
			basetypes.ObjectType{
				AttrTypes: PodIdentityAssociations2Value{}.AttributeTypes(ctx),
			},
		},
		v.PodIdentityAssociations2.Elements(),
	)

	if v.PodIdentityAssociations2.IsNull() {
		podIdentityAssociations2 = types.SetNull(
			PodIdentityAssociations2Type{
				basetypes.ObjectType{
					AttrTypes: PodIdentityAssociations2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PodIdentityAssociations2.IsUnknown() {
		podIdentityAssociations2 = types.SetUnknown(
			PodIdentityAssociations2Type{
				basetypes.ObjectType{
					AttrTypes: PodIdentityAssociations2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	wellKnownPolicies3 := types.SetValueMust(
		WellKnownPolicies3Type{
			basetypes.ObjectType{
				AttrTypes: WellKnownPolicies3Value{}.AttributeTypes(ctx),
			},
		},
		v.WellKnownPolicies3.Elements(),
	)

	if v.WellKnownPolicies3.IsNull() {
		wellKnownPolicies3 = types.SetNull(
			WellKnownPolicies3Type{
				basetypes.ObjectType{
					AttrTypes: WellKnownPolicies3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.WellKnownPolicies3.IsUnknown() {
		wellKnownPolicies3 = types.SetUnknown(
			WellKnownPolicies3Type{
				basetypes.ObjectType{
					AttrTypes: WellKnownPolicies3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var attachPolicyArns3Val basetypes.SetValue
	switch {
	case v.AttachPolicyArns3.IsUnknown():
		attachPolicyArns3Val = types.SetUnknown(types.StringType)
	case v.AttachPolicyArns3.IsNull():
		attachPolicyArns3Val = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachPolicyArns3Val, d = types.SetValue(types.StringType, v.AttachPolicyArns3.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_policy": basetypes.SetType{
				ElemType: AttachPolicy3Value{}.Type(ctx),
			},
			"attach_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"attach_policy_v2":     basetypes.StringType{},
			"configuration_values": basetypes.StringType{},
			"name":                 basetypes.StringType{},
			"permissions_boundary": basetypes.StringType{},
			"pod_identity_associations": basetypes.SetType{
				ElemType: PodIdentityAssociations2Value{}.Type(ctx),
			},
			"service_account_role_arn": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"use_default_pod_identity_associations": basetypes.BoolType{},
			"version":                               basetypes.StringType{},
			"well_known_policies": basetypes.SetType{
				ElemType: WellKnownPolicies3Value{}.Type(ctx),
			},
		}), diags
	}

	var tags4Val basetypes.MapValue
	switch {
	case v.Tags4.IsUnknown():
		tags4Val = types.MapUnknown(types.StringType)
	case v.Tags4.IsNull():
		tags4Val = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tags4Val, d = types.MapValue(types.StringType, v.Tags4.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_policy": basetypes.SetType{
				ElemType: AttachPolicy3Value{}.Type(ctx),
			},
			"attach_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"attach_policy_v2":     basetypes.StringType{},
			"configuration_values": basetypes.StringType{},
			"name":                 basetypes.StringType{},
			"permissions_boundary": basetypes.StringType{},
			"pod_identity_associations": basetypes.SetType{
				ElemType: PodIdentityAssociations2Value{}.Type(ctx),
			},
			"service_account_role_arn": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"use_default_pod_identity_associations": basetypes.BoolType{},
			"version":                               basetypes.StringType{},
			"well_known_policies": basetypes.SetType{
				ElemType: WellKnownPolicies3Value{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_policy": basetypes.SetType{
			ElemType: AttachPolicy3Value{}.Type(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2":     basetypes.StringType{},
		"configuration_values": basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"permissions_boundary": basetypes.StringType{},
		"pod_identity_associations": basetypes.SetType{
			ElemType: PodIdentityAssociations2Value{}.Type(ctx),
		},
		"service_account_role_arn": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"use_default_pod_identity_associations": basetypes.BoolType{},
		"version":                               basetypes.StringType{},
		"well_known_policies": basetypes.SetType{
			ElemType: WellKnownPolicies3Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_policy":                         attachPolicy3,
			"attach_policy_arns":                    attachPolicyArns3Val,
			"attach_policy_v2":                      v.AttachPolicyV22,
			"configuration_values":                  v.ConfigurationValues,
			"name":                                  v.Name,
			"permissions_boundary":                  v.PermissionsBoundary2,
			"pod_identity_associations":             podIdentityAssociations2,
			"service_account_role_arn":              v.ServiceAccountRoleArn,
			"tags":                                  tags4Val,
			"use_default_pod_identity_associations": v.UseDefaultPodIdentityAssociations,
			"version":                               v.Version,
			"well_known_policies":                   wellKnownPolicies3,
		})

	return objVal, diags
}

func (v AddonsValue) Equal(o attr.Value) bool {
	other, ok := o.(AddonsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachPolicy3.Equal(other.AttachPolicy3) {
		return false
	}

	if !v.AttachPolicyArns3.Equal(other.AttachPolicyArns3) {
		return false
	}

	if !v.AttachPolicyV22.Equal(other.AttachPolicyV22) {
		return false
	}

	if !v.ConfigurationValues.Equal(other.ConfigurationValues) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PermissionsBoundary2.Equal(other.PermissionsBoundary2) {
		return false
	}

	if !v.PodIdentityAssociations2.Equal(other.PodIdentityAssociations2) {
		return false
	}

	if !v.ServiceAccountRoleArn.Equal(other.ServiceAccountRoleArn) {
		return false
	}

	if !v.Tags4.Equal(other.Tags4) {
		return false
	}

	if !v.UseDefaultPodIdentityAssociations.Equal(other.UseDefaultPodIdentityAssociations) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.WellKnownPolicies3.Equal(other.WellKnownPolicies3) {
		return false
	}

	return true
}

func (v AddonsValue) Type(ctx context.Context) attr.Type {
	return AddonsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AddonsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_policy": basetypes.SetType{
			ElemType: AttachPolicy3Value{}.Type(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2":     basetypes.StringType{},
		"configuration_values": basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"permissions_boundary": basetypes.StringType{},
		"pod_identity_associations": basetypes.SetType{
			ElemType: PodIdentityAssociations2Value{}.Type(ctx),
		},
		"service_account_role_arn": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"use_default_pod_identity_associations": basetypes.BoolType{},
		"version":                               basetypes.StringType{},
		"well_known_policies": basetypes.SetType{
			ElemType: WellKnownPolicies3Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AttachPolicy3Type{}

type AttachPolicy3Type struct {
	basetypes.ObjectType
}

func (t AttachPolicy3Type) Equal(o attr.Type) bool {
	other, ok := o.(AttachPolicy3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachPolicy3Type) String() string {
	return "AttachPolicy3Type"
}

func (t AttachPolicy3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statement2Attribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement2 is missing from object`)

		return nil, diags
	}

	statement2Val, ok := statement2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement2 expected to be basetypes.SetValue, was: %T`, statement2Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachPolicy3Value{
		Id:         idVal,
		Statement2: statement2Val,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicy3ValueNull() AttachPolicy3Value {
	return AttachPolicy3Value{
		state: attr.ValueStateNull,
	}
}

func NewAttachPolicy3ValueUnknown() AttachPolicy3Value {
	return AttachPolicy3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachPolicy3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachPolicy3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachPolicy3Value Attribute Value",
				"While creating a AttachPolicy3Value value, a missing attribute value was detected. "+
					"A AttachPolicy3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicy3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachPolicy3Value Attribute Type",
				"While creating a AttachPolicy3Value value, an invalid attribute value was detected. "+
					"A AttachPolicy3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicy3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachPolicy3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachPolicy3Value Attribute Value",
				"While creating a AttachPolicy3Value value, an extra attribute value was detected. "+
					"A AttachPolicy3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachPolicy3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachPolicy3ValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewAttachPolicy3ValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statement2Attribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement2 is missing from object`)

		return NewAttachPolicy3ValueUnknown(), diags
	}

	statement2Val, ok := statement2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement2 expected to be basetypes.SetValue, was: %T`, statement2Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewAttachPolicy3ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewAttachPolicy3ValueUnknown(), diags
	}

	return AttachPolicy3Value{
		Id:         idVal,
		Statement2: statement2Val,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicy3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachPolicy3Value {
	object, diags := NewAttachPolicy3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachPolicy3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachPolicy3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachPolicy3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachPolicy3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachPolicy3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachPolicy3ValueMust(AttachPolicy3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t AttachPolicy3Type) ValueType(ctx context.Context) attr.Value {
	return AttachPolicy3Value{}
}

var _ basetypes.ObjectValuable = AttachPolicy3Value{}

type AttachPolicy3Value struct {
	Id         basetypes.StringValue `tfsdk:"id"`
	Statement2 basetypes.SetValue    `tfsdk:"statement"`
	Version    basetypes.StringValue `tfsdk:"version"`
	state      attr.ValueState
}

func (v AttachPolicy3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["statement"] = basetypes.SetType{
		ElemType: Statement2Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Statement2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statement"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachPolicy3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachPolicy3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachPolicy3Value) String() string {
	return "AttachPolicy3Value"
}

func (v AttachPolicy3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	statement2 := types.SetValueMust(
		Statement2Type{
			basetypes.ObjectType{
				AttrTypes: Statement2Value{}.AttributeTypes(ctx),
			},
		},
		v.Statement2.Elements(),
	)

	if v.Statement2.IsNull() {
		statement2 = types.SetNull(
			Statement2Type{
				basetypes.ObjectType{
					AttrTypes: Statement2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Statement2.IsUnknown() {
		statement2 = types.SetUnknown(
			Statement2Type{
				basetypes.ObjectType{
					AttrTypes: Statement2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: Statement2Value{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":        v.Id,
			"statement": statement2,
			"version":   v.Version,
		})

	return objVal, diags
}

func (v AttachPolicy3Value) Equal(o attr.Value) bool {
	other, ok := o.(AttachPolicy3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Statement2.Equal(other.Statement2) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v AttachPolicy3Value) Type(ctx context.Context) attr.Type {
	return AttachPolicy3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachPolicy3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: Statement2Value{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Statement2Type{}

type Statement2Type struct {
	basetypes.ObjectType
}

func (t Statement2Type) Equal(o attr.Type) bool {
	other, ok := o.(Statement2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Statement2Type) String() string {
	return "Statement2Type"
}

func (t Statement2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return nil, diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return nil, diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return nil, diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return nil, diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return nil, diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Statement2Value{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatement2ValueNull() Statement2Value {
	return Statement2Value{
		state: attr.ValueStateNull,
	}
}

func NewStatement2ValueUnknown() Statement2Value {
	return Statement2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewStatement2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Statement2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Statement2Value Attribute Value",
				"While creating a Statement2Value value, a missing attribute value was detected. "+
					"A Statement2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Statement2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Statement2Value Attribute Type",
				"While creating a Statement2Value value, an invalid attribute value was detected. "+
					"A Statement2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Statement2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Statement2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Statement2Value Attribute Value",
				"While creating a Statement2Value value, an extra attribute value was detected. "+
					"A Statement2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Statement2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatement2ValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return NewStatement2ValueUnknown(), diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return NewStatement2ValueUnknown(), diags
	}

	return Statement2Value{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatement2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Statement2Value {
	object, diags := NewStatement2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatement2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Statement2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatement2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatement2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatement2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatement2ValueMust(Statement2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Statement2Type) ValueType(ctx context.Context) attr.Value {
	return Statement2Value{}
}

var _ basetypes.ObjectValuable = Statement2Value{}

type Statement2Value struct {
	Action       basetypes.SetValue    `tfsdk:"action"`
	Condition    basetypes.StringValue `tfsdk:"condition"`
	Effect       basetypes.StringValue `tfsdk:"effect"`
	NotAction    basetypes.SetValue    `tfsdk:"not_action"`
	NotPrincipal basetypes.StringValue `tfsdk:"not_principal"`
	NotResource  basetypes.SetValue    `tfsdk:"not_resource"`
	Principal    basetypes.StringValue `tfsdk:"principal"`
	Resource     basetypes.StringValue `tfsdk:"resource"`
	Sid          basetypes.StringValue `tfsdk:"sid"`
	state        attr.ValueState
}

func (v Statement2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["not_principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_resource"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.NotAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_action"] = val

		val, err = v.NotPrincipal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_principal"] = val

		val, err = v.NotResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_resource"] = val

		val, err = v.Principal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["principal"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Sid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Statement2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Statement2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Statement2Value) String() string {
	return "Statement2Value"
}

func (v Statement2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var actionVal basetypes.SetValue
	switch {
	case v.Action.IsUnknown():
		actionVal = types.SetUnknown(types.StringType)
	case v.Action.IsNull():
		actionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		actionVal, d = types.SetValue(types.StringType, v.Action.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notActionVal basetypes.SetValue
	switch {
	case v.NotAction.IsUnknown():
		notActionVal = types.SetUnknown(types.StringType)
	case v.NotAction.IsNull():
		notActionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notActionVal, d = types.SetValue(types.StringType, v.NotAction.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notResourceVal basetypes.SetValue
	switch {
	case v.NotResource.IsUnknown():
		notResourceVal = types.SetUnknown(types.StringType)
	case v.NotResource.IsNull():
		notResourceVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notResourceVal, d = types.SetValue(types.StringType, v.NotResource.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":        actionVal,
			"condition":     v.Condition,
			"effect":        v.Effect,
			"not_action":    notActionVal,
			"not_principal": v.NotPrincipal,
			"not_resource":  notResourceVal,
			"principal":     v.Principal,
			"resource":      v.Resource,
			"sid":           v.Sid,
		})

	return objVal, diags
}

func (v Statement2Value) Equal(o attr.Value) bool {
	other, ok := o.(Statement2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.NotAction.Equal(other.NotAction) {
		return false
	}

	if !v.NotPrincipal.Equal(other.NotPrincipal) {
		return false
	}

	if !v.NotResource.Equal(other.NotResource) {
		return false
	}

	if !v.Principal.Equal(other.Principal) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Sid.Equal(other.Sid) {
		return false
	}

	return true
}

func (v Statement2Value) Type(ctx context.Context) attr.Type {
	return Statement2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Statement2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PodIdentityAssociations2Type{}

type PodIdentityAssociations2Type struct {
	basetypes.ObjectType
}

func (t PodIdentityAssociations2Type) Equal(o attr.Type) bool {
	other, ok := o.(PodIdentityAssociations2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodIdentityAssociations2Type) String() string {
	return "PodIdentityAssociations2Type"
}

func (t PodIdentityAssociations2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createServiceAccountAttribute, ok := attributes["create_service_account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_service_account is missing from object`)

		return nil, diags
	}

	createServiceAccountVal, ok := createServiceAccountAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_service_account expected to be basetypes.BoolValue, was: %T`, createServiceAccountAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	permissionBoundaryArnAttribute, ok := attributes["permission_boundary_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_boundary_arn is missing from object`)

		return nil, diags
	}

	permissionBoundaryArnVal, ok := permissionBoundaryArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_boundary_arn expected to be basetypes.StringValue, was: %T`, permissionBoundaryArnAttribute))
	}

	permissionPolicyAttribute, ok := attributes["permission_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_policy is missing from object`)

		return nil, diags
	}

	permissionPolicyVal, ok := permissionPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_policy expected to be basetypes.StringValue, was: %T`, permissionPolicyAttribute))
	}

	permissionPolicyArnsAttribute, ok := attributes["permission_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_policy_arns is missing from object`)

		return nil, diags
	}

	permissionPolicyArnsVal, ok := permissionPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_policy_arns expected to be basetypes.SetValue, was: %T`, permissionPolicyArnsAttribute))
	}

	roleArnAttribute, ok := attributes["role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_arn is missing from object`)

		return nil, diags
	}

	roleArnVal, ok := roleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_arn expected to be basetypes.StringValue, was: %T`, roleArnAttribute))
	}

	roleNameAttribute, ok := attributes["role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_name is missing from object`)

		return nil, diags
	}

	roleNameVal, ok := roleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_name expected to be basetypes.StringValue, was: %T`, roleNameAttribute))
	}

	serviceAccountNameAttribute, ok := attributes["service_account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_name is missing from object`)

		return nil, diags
	}

	serviceAccountNameVal, ok := serviceAccountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_name expected to be basetypes.StringValue, was: %T`, serviceAccountNameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	wellKnownPolicies4Attribute, ok := attributes["well_known_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`well_known_policies4 is missing from object`)

		return nil, diags
	}

	wellKnownPolicies4Val, ok := wellKnownPolicies4Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`well_known_policies4 expected to be basetypes.SetValue, was: %T`, wellKnownPolicies4Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodIdentityAssociations2Value{
		CreateServiceAccount:  createServiceAccountVal,
		Namespace:             namespaceVal,
		PermissionBoundaryArn: permissionBoundaryArnVal,
		PermissionPolicy:      permissionPolicyVal,
		PermissionPolicyArns:  permissionPolicyArnsVal,
		RoleArn:               roleArnVal,
		RoleName:              roleNameVal,
		ServiceAccountName:    serviceAccountNameVal,
		Tags:                  tagsVal,
		WellKnownPolicies4:    wellKnownPolicies4Val,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPodIdentityAssociations2ValueNull() PodIdentityAssociations2Value {
	return PodIdentityAssociations2Value{
		state: attr.ValueStateNull,
	}
}

func NewPodIdentityAssociations2ValueUnknown() PodIdentityAssociations2Value {
	return PodIdentityAssociations2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPodIdentityAssociations2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodIdentityAssociations2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodIdentityAssociations2Value Attribute Value",
				"While creating a PodIdentityAssociations2Value value, a missing attribute value was detected. "+
					"A PodIdentityAssociations2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodIdentityAssociations2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodIdentityAssociations2Value Attribute Type",
				"While creating a PodIdentityAssociations2Value value, an invalid attribute value was detected. "+
					"A PodIdentityAssociations2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodIdentityAssociations2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodIdentityAssociations2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodIdentityAssociations2Value Attribute Value",
				"While creating a PodIdentityAssociations2Value value, an extra attribute value was detected. "+
					"A PodIdentityAssociations2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodIdentityAssociations2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	createServiceAccountAttribute, ok := attributes["create_service_account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_service_account is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	createServiceAccountVal, ok := createServiceAccountAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_service_account expected to be basetypes.BoolValue, was: %T`, createServiceAccountAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	permissionBoundaryArnAttribute, ok := attributes["permission_boundary_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_boundary_arn is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	permissionBoundaryArnVal, ok := permissionBoundaryArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_boundary_arn expected to be basetypes.StringValue, was: %T`, permissionBoundaryArnAttribute))
	}

	permissionPolicyAttribute, ok := attributes["permission_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_policy is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	permissionPolicyVal, ok := permissionPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_policy expected to be basetypes.StringValue, was: %T`, permissionPolicyAttribute))
	}

	permissionPolicyArnsAttribute, ok := attributes["permission_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_policy_arns is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	permissionPolicyArnsVal, ok := permissionPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_policy_arns expected to be basetypes.SetValue, was: %T`, permissionPolicyArnsAttribute))
	}

	roleArnAttribute, ok := attributes["role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_arn is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	roleArnVal, ok := roleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_arn expected to be basetypes.StringValue, was: %T`, roleArnAttribute))
	}

	roleNameAttribute, ok := attributes["role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_name is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	roleNameVal, ok := roleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_name expected to be basetypes.StringValue, was: %T`, roleNameAttribute))
	}

	serviceAccountNameAttribute, ok := attributes["service_account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_name is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	serviceAccountNameVal, ok := serviceAccountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_name expected to be basetypes.StringValue, was: %T`, serviceAccountNameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	wellKnownPolicies4Attribute, ok := attributes["well_known_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`well_known_policies4 is missing from object`)

		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	wellKnownPolicies4Val, ok := wellKnownPolicies4Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`well_known_policies4 expected to be basetypes.SetValue, was: %T`, wellKnownPolicies4Attribute))
	}

	if diags.HasError() {
		return NewPodIdentityAssociations2ValueUnknown(), diags
	}

	return PodIdentityAssociations2Value{
		CreateServiceAccount:  createServiceAccountVal,
		Namespace:             namespaceVal,
		PermissionBoundaryArn: permissionBoundaryArnVal,
		PermissionPolicy:      permissionPolicyVal,
		PermissionPolicyArns:  permissionPolicyArnsVal,
		RoleArn:               roleArnVal,
		RoleName:              roleNameVal,
		ServiceAccountName:    serviceAccountNameVal,
		Tags:                  tagsVal,
		WellKnownPolicies4:    wellKnownPolicies4Val,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPodIdentityAssociations2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodIdentityAssociations2Value {
	object, diags := NewPodIdentityAssociations2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodIdentityAssociations2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodIdentityAssociations2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodIdentityAssociations2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodIdentityAssociations2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodIdentityAssociations2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodIdentityAssociations2ValueMust(PodIdentityAssociations2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PodIdentityAssociations2Type) ValueType(ctx context.Context) attr.Value {
	return PodIdentityAssociations2Value{}
}

var _ basetypes.ObjectValuable = PodIdentityAssociations2Value{}

type PodIdentityAssociations2Value struct {
	CreateServiceAccount  basetypes.BoolValue   `tfsdk:"create_service_account"`
	Namespace             basetypes.StringValue `tfsdk:"namespace"`
	PermissionBoundaryArn basetypes.StringValue `tfsdk:"permission_boundary_arn"`
	PermissionPolicy      basetypes.StringValue `tfsdk:"permission_policy"`
	PermissionPolicyArns  basetypes.SetValue    `tfsdk:"permission_policy_arns"`
	RoleArn               basetypes.StringValue `tfsdk:"role_arn"`
	RoleName              basetypes.StringValue `tfsdk:"role_name"`
	ServiceAccountName    basetypes.StringValue `tfsdk:"service_account_name"`
	Tags                  basetypes.MapValue    `tfsdk:"tags"`
	WellKnownPolicies4    basetypes.SetValue    `tfsdk:"well_known_policies"`
	state                 attr.ValueState
}

func (v PodIdentityAssociations2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["create_service_account"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission_boundary_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission_policy_arns"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_account_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["well_known_policies"] = basetypes.SetType{
		ElemType: WellKnownPolicies4Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.CreateServiceAccount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["create_service_account"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		val, err = v.PermissionBoundaryArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission_boundary_arn"] = val

		val, err = v.PermissionPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission_policy"] = val

		val, err = v.PermissionPolicyArns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission_policy_arns"] = val

		val, err = v.RoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_arn"] = val

		val, err = v.RoleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_name"] = val

		val, err = v.ServiceAccountName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_account_name"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.WellKnownPolicies4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["well_known_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodIdentityAssociations2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodIdentityAssociations2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodIdentityAssociations2Value) String() string {
	return "PodIdentityAssociations2Value"
}

func (v PodIdentityAssociations2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	wellKnownPolicies4 := types.SetValueMust(
		WellKnownPolicies4Type{
			basetypes.ObjectType{
				AttrTypes: WellKnownPolicies4Value{}.AttributeTypes(ctx),
			},
		},
		v.WellKnownPolicies4.Elements(),
	)

	if v.WellKnownPolicies4.IsNull() {
		wellKnownPolicies4 = types.SetNull(
			WellKnownPolicies4Type{
				basetypes.ObjectType{
					AttrTypes: WellKnownPolicies4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.WellKnownPolicies4.IsUnknown() {
		wellKnownPolicies4 = types.SetUnknown(
			WellKnownPolicies4Type{
				basetypes.ObjectType{
					AttrTypes: WellKnownPolicies4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var permissionPolicyArnsVal basetypes.SetValue
	switch {
	case v.PermissionPolicyArns.IsUnknown():
		permissionPolicyArnsVal = types.SetUnknown(types.StringType)
	case v.PermissionPolicyArns.IsNull():
		permissionPolicyArnsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		permissionPolicyArnsVal, d = types.SetValue(types.StringType, v.PermissionPolicyArns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"create_service_account":  basetypes.BoolType{},
			"namespace":               basetypes.StringType{},
			"permission_boundary_arn": basetypes.StringType{},
			"permission_policy":       basetypes.StringType{},
			"permission_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"role_arn":             basetypes.StringType{},
			"role_name":            basetypes.StringType{},
			"service_account_name": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"well_known_policies": basetypes.SetType{
				ElemType: WellKnownPolicies4Value{}.Type(ctx),
			},
		}), diags
	}

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"create_service_account":  basetypes.BoolType{},
			"namespace":               basetypes.StringType{},
			"permission_boundary_arn": basetypes.StringType{},
			"permission_policy":       basetypes.StringType{},
			"permission_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"role_arn":             basetypes.StringType{},
			"role_name":            basetypes.StringType{},
			"service_account_name": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"well_known_policies": basetypes.SetType{
				ElemType: WellKnownPolicies4Value{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"create_service_account":  basetypes.BoolType{},
		"namespace":               basetypes.StringType{},
		"permission_boundary_arn": basetypes.StringType{},
		"permission_policy":       basetypes.StringType{},
		"permission_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"role_arn":             basetypes.StringType{},
		"role_name":            basetypes.StringType{},
		"service_account_name": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"well_known_policies": basetypes.SetType{
			ElemType: WellKnownPolicies4Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"create_service_account":  v.CreateServiceAccount,
			"namespace":               v.Namespace,
			"permission_boundary_arn": v.PermissionBoundaryArn,
			"permission_policy":       v.PermissionPolicy,
			"permission_policy_arns":  permissionPolicyArnsVal,
			"role_arn":                v.RoleArn,
			"role_name":               v.RoleName,
			"service_account_name":    v.ServiceAccountName,
			"tags":                    tagsVal,
			"well_known_policies":     wellKnownPolicies4,
		})

	return objVal, diags
}

func (v PodIdentityAssociations2Value) Equal(o attr.Value) bool {
	other, ok := o.(PodIdentityAssociations2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreateServiceAccount.Equal(other.CreateServiceAccount) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	if !v.PermissionBoundaryArn.Equal(other.PermissionBoundaryArn) {
		return false
	}

	if !v.PermissionPolicy.Equal(other.PermissionPolicy) {
		return false
	}

	if !v.PermissionPolicyArns.Equal(other.PermissionPolicyArns) {
		return false
	}

	if !v.RoleArn.Equal(other.RoleArn) {
		return false
	}

	if !v.RoleName.Equal(other.RoleName) {
		return false
	}

	if !v.ServiceAccountName.Equal(other.ServiceAccountName) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.WellKnownPolicies4.Equal(other.WellKnownPolicies4) {
		return false
	}

	return true
}

func (v PodIdentityAssociations2Value) Type(ctx context.Context) attr.Type {
	return PodIdentityAssociations2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodIdentityAssociations2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"create_service_account":  basetypes.BoolType{},
		"namespace":               basetypes.StringType{},
		"permission_boundary_arn": basetypes.StringType{},
		"permission_policy":       basetypes.StringType{},
		"permission_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"role_arn":             basetypes.StringType{},
		"role_name":            basetypes.StringType{},
		"service_account_name": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"well_known_policies": basetypes.SetType{
			ElemType: WellKnownPolicies4Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = WellKnownPolicies4Type{}

type WellKnownPolicies4Type struct {
	basetypes.ObjectType
}

func (t WellKnownPolicies4Type) Equal(o attr.Type) bool {
	other, ok := o.(WellKnownPolicies4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WellKnownPolicies4Type) String() string {
	return "WellKnownPolicies4Type"
}

func (t WellKnownPolicies4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	awsLoadBalancerControllerAttribute, ok := attributes["aws_load_balancer_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_load_balancer_controller is missing from object`)

		return nil, diags
	}

	awsLoadBalancerControllerVal, ok := awsLoadBalancerControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_load_balancer_controller expected to be basetypes.BoolValue, was: %T`, awsLoadBalancerControllerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	ebsCsiControllerAttribute, ok := attributes["ebs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_csi_controller is missing from object`)

		return nil, diags
	}

	ebsCsiControllerVal, ok := ebsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_csi_controller expected to be basetypes.BoolValue, was: %T`, ebsCsiControllerAttribute))
	}

	efsCsiControllerAttribute, ok := attributes["efs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs_csi_controller is missing from object`)

		return nil, diags
	}

	efsCsiControllerVal, ok := efsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs_csi_controller expected to be basetypes.BoolValue, was: %T`, efsCsiControllerAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WellKnownPolicies4Value{
		AutoScaler:                autoScalerVal,
		AwsLoadBalancerController: awsLoadBalancerControllerVal,
		CertManager:               certManagerVal,
		EbsCsiController:          ebsCsiControllerVal,
		EfsCsiController:          efsCsiControllerVal,
		ExternalDns:               externalDnsVal,
		ImageBuilder:              imageBuilderVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWellKnownPolicies4ValueNull() WellKnownPolicies4Value {
	return WellKnownPolicies4Value{
		state: attr.ValueStateNull,
	}
}

func NewWellKnownPolicies4ValueUnknown() WellKnownPolicies4Value {
	return WellKnownPolicies4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewWellKnownPolicies4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WellKnownPolicies4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WellKnownPolicies4Value Attribute Value",
				"While creating a WellKnownPolicies4Value value, a missing attribute value was detected. "+
					"A WellKnownPolicies4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WellKnownPolicies4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WellKnownPolicies4Value Attribute Type",
				"While creating a WellKnownPolicies4Value value, an invalid attribute value was detected. "+
					"A WellKnownPolicies4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WellKnownPolicies4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WellKnownPolicies4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WellKnownPolicies4Value Attribute Value",
				"While creating a WellKnownPolicies4Value value, an extra attribute value was detected. "+
					"A WellKnownPolicies4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WellKnownPolicies4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	awsLoadBalancerControllerAttribute, ok := attributes["aws_load_balancer_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_load_balancer_controller is missing from object`)

		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	awsLoadBalancerControllerVal, ok := awsLoadBalancerControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_load_balancer_controller expected to be basetypes.BoolValue, was: %T`, awsLoadBalancerControllerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	ebsCsiControllerAttribute, ok := attributes["ebs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_csi_controller is missing from object`)

		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	ebsCsiControllerVal, ok := ebsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_csi_controller expected to be basetypes.BoolValue, was: %T`, ebsCsiControllerAttribute))
	}

	efsCsiControllerAttribute, ok := attributes["efs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs_csi_controller is missing from object`)

		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	efsCsiControllerVal, ok := efsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs_csi_controller expected to be basetypes.BoolValue, was: %T`, efsCsiControllerAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	if diags.HasError() {
		return NewWellKnownPolicies4ValueUnknown(), diags
	}

	return WellKnownPolicies4Value{
		AutoScaler:                autoScalerVal,
		AwsLoadBalancerController: awsLoadBalancerControllerVal,
		CertManager:               certManagerVal,
		EbsCsiController:          ebsCsiControllerVal,
		EfsCsiController:          efsCsiControllerVal,
		ExternalDns:               externalDnsVal,
		ImageBuilder:              imageBuilderVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWellKnownPolicies4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WellKnownPolicies4Value {
	object, diags := NewWellKnownPolicies4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWellKnownPolicies4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WellKnownPolicies4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWellKnownPolicies4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWellKnownPolicies4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWellKnownPolicies4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWellKnownPolicies4ValueMust(WellKnownPolicies4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t WellKnownPolicies4Type) ValueType(ctx context.Context) attr.Value {
	return WellKnownPolicies4Value{}
}

var _ basetypes.ObjectValuable = WellKnownPolicies4Value{}

type WellKnownPolicies4Value struct {
	AutoScaler                basetypes.BoolValue `tfsdk:"auto_scaler"`
	AwsLoadBalancerController basetypes.BoolValue `tfsdk:"aws_load_balancer_controller"`
	CertManager               basetypes.BoolValue `tfsdk:"cert_manager"`
	EbsCsiController          basetypes.BoolValue `tfsdk:"ebs_csi_controller"`
	EfsCsiController          basetypes.BoolValue `tfsdk:"efs_csi_controller"`
	ExternalDns               basetypes.BoolValue `tfsdk:"external_dns"`
	ImageBuilder              basetypes.BoolValue `tfsdk:"image_builder"`
	state                     attr.ValueState
}

func (v WellKnownPolicies4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aws_load_balancer_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs_csi_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs_csi_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.AwsLoadBalancerController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws_load_balancer_controller"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.EbsCsiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs_csi_controller"] = val

		val, err = v.EfsCsiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs_csi_controller"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WellKnownPolicies4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WellKnownPolicies4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WellKnownPolicies4Value) String() string {
	return "WellKnownPolicies4Value"
}

func (v WellKnownPolicies4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auto_scaler":                  basetypes.BoolType{},
		"aws_load_balancer_controller": basetypes.BoolType{},
		"cert_manager":                 basetypes.BoolType{},
		"ebs_csi_controller":           basetypes.BoolType{},
		"efs_csi_controller":           basetypes.BoolType{},
		"external_dns":                 basetypes.BoolType{},
		"image_builder":                basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_scaler":                  v.AutoScaler,
			"aws_load_balancer_controller": v.AwsLoadBalancerController,
			"cert_manager":                 v.CertManager,
			"ebs_csi_controller":           v.EbsCsiController,
			"efs_csi_controller":           v.EfsCsiController,
			"external_dns":                 v.ExternalDns,
			"image_builder":                v.ImageBuilder,
		})

	return objVal, diags
}

func (v WellKnownPolicies4Value) Equal(o attr.Value) bool {
	other, ok := o.(WellKnownPolicies4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.AwsLoadBalancerController.Equal(other.AwsLoadBalancerController) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.EbsCsiController.Equal(other.EbsCsiController) {
		return false
	}

	if !v.EfsCsiController.Equal(other.EfsCsiController) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	return true
}

func (v WellKnownPolicies4Value) Type(ctx context.Context) attr.Type {
	return WellKnownPolicies4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WellKnownPolicies4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_scaler":                  basetypes.BoolType{},
		"aws_load_balancer_controller": basetypes.BoolType{},
		"cert_manager":                 basetypes.BoolType{},
		"ebs_csi_controller":           basetypes.BoolType{},
		"efs_csi_controller":           basetypes.BoolType{},
		"external_dns":                 basetypes.BoolType{},
		"image_builder":                basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = WellKnownPolicies3Type{}

type WellKnownPolicies3Type struct {
	basetypes.ObjectType
}

func (t WellKnownPolicies3Type) Equal(o attr.Type) bool {
	other, ok := o.(WellKnownPolicies3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WellKnownPolicies3Type) String() string {
	return "WellKnownPolicies3Type"
}

func (t WellKnownPolicies3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	awsLoadBalancerControllerAttribute, ok := attributes["aws_load_balancer_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_load_balancer_controller is missing from object`)

		return nil, diags
	}

	awsLoadBalancerControllerVal, ok := awsLoadBalancerControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_load_balancer_controller expected to be basetypes.BoolValue, was: %T`, awsLoadBalancerControllerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	ebsCsiControllerAttribute, ok := attributes["ebs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_csi_controller is missing from object`)

		return nil, diags
	}

	ebsCsiControllerVal, ok := ebsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_csi_controller expected to be basetypes.BoolValue, was: %T`, ebsCsiControllerAttribute))
	}

	efsCsiControllerAttribute, ok := attributes["efs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs_csi_controller is missing from object`)

		return nil, diags
	}

	efsCsiControllerVal, ok := efsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs_csi_controller expected to be basetypes.BoolValue, was: %T`, efsCsiControllerAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WellKnownPolicies3Value{
		AutoScaler:                autoScalerVal,
		AwsLoadBalancerController: awsLoadBalancerControllerVal,
		CertManager:               certManagerVal,
		EbsCsiController:          ebsCsiControllerVal,
		EfsCsiController:          efsCsiControllerVal,
		ExternalDns:               externalDnsVal,
		ImageBuilder:              imageBuilderVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWellKnownPolicies3ValueNull() WellKnownPolicies3Value {
	return WellKnownPolicies3Value{
		state: attr.ValueStateNull,
	}
}

func NewWellKnownPolicies3ValueUnknown() WellKnownPolicies3Value {
	return WellKnownPolicies3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewWellKnownPolicies3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WellKnownPolicies3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WellKnownPolicies3Value Attribute Value",
				"While creating a WellKnownPolicies3Value value, a missing attribute value was detected. "+
					"A WellKnownPolicies3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WellKnownPolicies3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WellKnownPolicies3Value Attribute Type",
				"While creating a WellKnownPolicies3Value value, an invalid attribute value was detected. "+
					"A WellKnownPolicies3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WellKnownPolicies3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WellKnownPolicies3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WellKnownPolicies3Value Attribute Value",
				"While creating a WellKnownPolicies3Value value, an extra attribute value was detected. "+
					"A WellKnownPolicies3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WellKnownPolicies3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	awsLoadBalancerControllerAttribute, ok := attributes["aws_load_balancer_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_load_balancer_controller is missing from object`)

		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	awsLoadBalancerControllerVal, ok := awsLoadBalancerControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_load_balancer_controller expected to be basetypes.BoolValue, was: %T`, awsLoadBalancerControllerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	ebsCsiControllerAttribute, ok := attributes["ebs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_csi_controller is missing from object`)

		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	ebsCsiControllerVal, ok := ebsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_csi_controller expected to be basetypes.BoolValue, was: %T`, ebsCsiControllerAttribute))
	}

	efsCsiControllerAttribute, ok := attributes["efs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs_csi_controller is missing from object`)

		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	efsCsiControllerVal, ok := efsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs_csi_controller expected to be basetypes.BoolValue, was: %T`, efsCsiControllerAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	if diags.HasError() {
		return NewWellKnownPolicies3ValueUnknown(), diags
	}

	return WellKnownPolicies3Value{
		AutoScaler:                autoScalerVal,
		AwsLoadBalancerController: awsLoadBalancerControllerVal,
		CertManager:               certManagerVal,
		EbsCsiController:          ebsCsiControllerVal,
		EfsCsiController:          efsCsiControllerVal,
		ExternalDns:               externalDnsVal,
		ImageBuilder:              imageBuilderVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWellKnownPolicies3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WellKnownPolicies3Value {
	object, diags := NewWellKnownPolicies3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWellKnownPolicies3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WellKnownPolicies3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWellKnownPolicies3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWellKnownPolicies3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWellKnownPolicies3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWellKnownPolicies3ValueMust(WellKnownPolicies3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t WellKnownPolicies3Type) ValueType(ctx context.Context) attr.Value {
	return WellKnownPolicies3Value{}
}

var _ basetypes.ObjectValuable = WellKnownPolicies3Value{}

type WellKnownPolicies3Value struct {
	AutoScaler                basetypes.BoolValue `tfsdk:"auto_scaler"`
	AwsLoadBalancerController basetypes.BoolValue `tfsdk:"aws_load_balancer_controller"`
	CertManager               basetypes.BoolValue `tfsdk:"cert_manager"`
	EbsCsiController          basetypes.BoolValue `tfsdk:"ebs_csi_controller"`
	EfsCsiController          basetypes.BoolValue `tfsdk:"efs_csi_controller"`
	ExternalDns               basetypes.BoolValue `tfsdk:"external_dns"`
	ImageBuilder              basetypes.BoolValue `tfsdk:"image_builder"`
	state                     attr.ValueState
}

func (v WellKnownPolicies3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aws_load_balancer_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs_csi_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs_csi_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.AwsLoadBalancerController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws_load_balancer_controller"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.EbsCsiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs_csi_controller"] = val

		val, err = v.EfsCsiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs_csi_controller"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WellKnownPolicies3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WellKnownPolicies3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WellKnownPolicies3Value) String() string {
	return "WellKnownPolicies3Value"
}

func (v WellKnownPolicies3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auto_scaler":                  basetypes.BoolType{},
		"aws_load_balancer_controller": basetypes.BoolType{},
		"cert_manager":                 basetypes.BoolType{},
		"ebs_csi_controller":           basetypes.BoolType{},
		"efs_csi_controller":           basetypes.BoolType{},
		"external_dns":                 basetypes.BoolType{},
		"image_builder":                basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_scaler":                  v.AutoScaler,
			"aws_load_balancer_controller": v.AwsLoadBalancerController,
			"cert_manager":                 v.CertManager,
			"ebs_csi_controller":           v.EbsCsiController,
			"efs_csi_controller":           v.EfsCsiController,
			"external_dns":                 v.ExternalDns,
			"image_builder":                v.ImageBuilder,
		})

	return objVal, diags
}

func (v WellKnownPolicies3Value) Equal(o attr.Value) bool {
	other, ok := o.(WellKnownPolicies3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.AwsLoadBalancerController.Equal(other.AwsLoadBalancerController) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.EbsCsiController.Equal(other.EbsCsiController) {
		return false
	}

	if !v.EfsCsiController.Equal(other.EfsCsiController) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	return true
}

func (v WellKnownPolicies3Value) Type(ctx context.Context) attr.Type {
	return WellKnownPolicies3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WellKnownPolicies3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_scaler":                  basetypes.BoolType{},
		"aws_load_balancer_controller": basetypes.BoolType{},
		"cert_manager":                 basetypes.BoolType{},
		"ebs_csi_controller":           basetypes.BoolType{},
		"efs_csi_controller":           basetypes.BoolType{},
		"external_dns":                 basetypes.BoolType{},
		"image_builder":                basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = AddonsConfigType{}

type AddonsConfigType struct {
	basetypes.ObjectType
}

func (t AddonsConfigType) Equal(o attr.Type) bool {
	other, ok := o.(AddonsConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AddonsConfigType) String() string {
	return "AddonsConfigType"
}

func (t AddonsConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoApplyPodIdentityAssociationsAttribute, ok := attributes["auto_apply_pod_identity_associations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_apply_pod_identity_associations is missing from object`)

		return nil, diags
	}

	autoApplyPodIdentityAssociationsVal, ok := autoApplyPodIdentityAssociationsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_apply_pod_identity_associations expected to be basetypes.BoolValue, was: %T`, autoApplyPodIdentityAssociationsAttribute))
	}

	disableEbsCsiDriverAttribute, ok := attributes["disable_ebs_csi_driver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_ebs_csi_driver is missing from object`)

		return nil, diags
	}

	disableEbsCsiDriverVal, ok := disableEbsCsiDriverAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_ebs_csi_driver expected to be basetypes.BoolValue, was: %T`, disableEbsCsiDriverAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AddonsConfigValue{
		AutoApplyPodIdentityAssociations: autoApplyPodIdentityAssociationsVal,
		DisableEbsCsiDriver:              disableEbsCsiDriverVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewAddonsConfigValueNull() AddonsConfigValue {
	return AddonsConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewAddonsConfigValueUnknown() AddonsConfigValue {
	return AddonsConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAddonsConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AddonsConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AddonsConfigValue Attribute Value",
				"While creating a AddonsConfigValue value, a missing attribute value was detected. "+
					"A AddonsConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AddonsConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AddonsConfigValue Attribute Type",
				"While creating a AddonsConfigValue value, an invalid attribute value was detected. "+
					"A AddonsConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AddonsConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AddonsConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AddonsConfigValue Attribute Value",
				"While creating a AddonsConfigValue value, an extra attribute value was detected. "+
					"A AddonsConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AddonsConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAddonsConfigValueUnknown(), diags
	}

	autoApplyPodIdentityAssociationsAttribute, ok := attributes["auto_apply_pod_identity_associations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_apply_pod_identity_associations is missing from object`)

		return NewAddonsConfigValueUnknown(), diags
	}

	autoApplyPodIdentityAssociationsVal, ok := autoApplyPodIdentityAssociationsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_apply_pod_identity_associations expected to be basetypes.BoolValue, was: %T`, autoApplyPodIdentityAssociationsAttribute))
	}

	disableEbsCsiDriverAttribute, ok := attributes["disable_ebs_csi_driver"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_ebs_csi_driver is missing from object`)

		return NewAddonsConfigValueUnknown(), diags
	}

	disableEbsCsiDriverVal, ok := disableEbsCsiDriverAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_ebs_csi_driver expected to be basetypes.BoolValue, was: %T`, disableEbsCsiDriverAttribute))
	}

	if diags.HasError() {
		return NewAddonsConfigValueUnknown(), diags
	}

	return AddonsConfigValue{
		AutoApplyPodIdentityAssociations: autoApplyPodIdentityAssociationsVal,
		DisableEbsCsiDriver:              disableEbsCsiDriverVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewAddonsConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AddonsConfigValue {
	object, diags := NewAddonsConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAddonsConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AddonsConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAddonsConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAddonsConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAddonsConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAddonsConfigValueMust(AddonsConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AddonsConfigType) ValueType(ctx context.Context) attr.Value {
	return AddonsConfigValue{}
}

var _ basetypes.ObjectValuable = AddonsConfigValue{}

type AddonsConfigValue struct {
	AutoApplyPodIdentityAssociations basetypes.BoolValue `tfsdk:"auto_apply_pod_identity_associations"`
	DisableEbsCsiDriver              basetypes.BoolValue `tfsdk:"disable_ebs_csi_driver"`
	state                            attr.ValueState
}

func (v AddonsConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["auto_apply_pod_identity_associations"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_ebs_csi_driver"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AutoApplyPodIdentityAssociations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_apply_pod_identity_associations"] = val

		val, err = v.DisableEbsCsiDriver.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_ebs_csi_driver"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AddonsConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AddonsConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AddonsConfigValue) String() string {
	return "AddonsConfigValue"
}

func (v AddonsConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auto_apply_pod_identity_associations": basetypes.BoolType{},
		"disable_ebs_csi_driver":               basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_apply_pod_identity_associations": v.AutoApplyPodIdentityAssociations,
			"disable_ebs_csi_driver":               v.DisableEbsCsiDriver,
		})

	return objVal, diags
}

func (v AddonsConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(AddonsConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoApplyPodIdentityAssociations.Equal(other.AutoApplyPodIdentityAssociations) {
		return false
	}

	if !v.DisableEbsCsiDriver.Equal(other.DisableEbsCsiDriver) {
		return false
	}

	return true
}

func (v AddonsConfigValue) Type(ctx context.Context) attr.Type {
	return AddonsConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AddonsConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_apply_pod_identity_associations": basetypes.BoolType{},
		"disable_ebs_csi_driver":               basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = AutoModeConfigType{}

type AutoModeConfigType struct {
	basetypes.ObjectType
}

func (t AutoModeConfigType) Equal(o attr.Type) bool {
	other, ok := o.(AutoModeConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoModeConfigType) String() string {
	return "AutoModeConfigType"
}

func (t AutoModeConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	nodePoolsAttribute, ok := attributes["node_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_pools is missing from object`)

		return nil, diags
	}

	nodePoolsVal, ok := nodePoolsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_pools expected to be basetypes.ListValue, was: %T`, nodePoolsAttribute))
	}

	nodeRoleArnAttribute, ok := attributes["node_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_role_arn is missing from object`)

		return nil, diags
	}

	nodeRoleArnVal, ok := nodeRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_role_arn expected to be basetypes.StringValue, was: %T`, nodeRoleArnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoModeConfigValue{
		Enabled:     enabledVal,
		NodePools:   nodePoolsVal,
		NodeRoleArn: nodeRoleArnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAutoModeConfigValueNull() AutoModeConfigValue {
	return AutoModeConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoModeConfigValueUnknown() AutoModeConfigValue {
	return AutoModeConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoModeConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoModeConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoModeConfigValue Attribute Value",
				"While creating a AutoModeConfigValue value, a missing attribute value was detected. "+
					"A AutoModeConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoModeConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoModeConfigValue Attribute Type",
				"While creating a AutoModeConfigValue value, an invalid attribute value was detected. "+
					"A AutoModeConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoModeConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoModeConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoModeConfigValue Attribute Value",
				"While creating a AutoModeConfigValue value, an extra attribute value was detected. "+
					"A AutoModeConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoModeConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoModeConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAutoModeConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	nodePoolsAttribute, ok := attributes["node_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_pools is missing from object`)

		return NewAutoModeConfigValueUnknown(), diags
	}

	nodePoolsVal, ok := nodePoolsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_pools expected to be basetypes.ListValue, was: %T`, nodePoolsAttribute))
	}

	nodeRoleArnAttribute, ok := attributes["node_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_role_arn is missing from object`)

		return NewAutoModeConfigValueUnknown(), diags
	}

	nodeRoleArnVal, ok := nodeRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_role_arn expected to be basetypes.StringValue, was: %T`, nodeRoleArnAttribute))
	}

	if diags.HasError() {
		return NewAutoModeConfigValueUnknown(), diags
	}

	return AutoModeConfigValue{
		Enabled:     enabledVal,
		NodePools:   nodePoolsVal,
		NodeRoleArn: nodeRoleArnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAutoModeConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoModeConfigValue {
	object, diags := NewAutoModeConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoModeConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoModeConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoModeConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoModeConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoModeConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoModeConfigValueMust(AutoModeConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoModeConfigType) ValueType(ctx context.Context) attr.Value {
	return AutoModeConfigValue{}
}

var _ basetypes.ObjectValuable = AutoModeConfigValue{}

type AutoModeConfigValue struct {
	Enabled     basetypes.BoolValue   `tfsdk:"enabled"`
	NodePools   basetypes.ListValue   `tfsdk:"node_pools"`
	NodeRoleArn basetypes.StringValue `tfsdk:"node_role_arn"`
	state       attr.ValueState
}

func (v AutoModeConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["node_pools"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["node_role_arn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.NodePools.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_pools"] = val

		val, err = v.NodeRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_role_arn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoModeConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoModeConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoModeConfigValue) String() string {
	return "AutoModeConfigValue"
}

func (v AutoModeConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nodePoolsVal basetypes.ListValue
	switch {
	case v.NodePools.IsUnknown():
		nodePoolsVal = types.ListUnknown(types.StringType)
	case v.NodePools.IsNull():
		nodePoolsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodePoolsVal, d = types.ListValue(types.StringType, v.NodePools.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"node_pools": basetypes.ListType{
				ElemType: types.StringType,
			},
			"node_role_arn": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"node_pools": basetypes.ListType{
			ElemType: types.StringType,
		},
		"node_role_arn": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":       v.Enabled,
			"node_pools":    nodePoolsVal,
			"node_role_arn": v.NodeRoleArn,
		})

	return objVal, diags
}

func (v AutoModeConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoModeConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.NodePools.Equal(other.NodePools) {
		return false
	}

	if !v.NodeRoleArn.Equal(other.NodeRoleArn) {
		return false
	}

	return true
}

func (v AutoModeConfigValue) Type(ctx context.Context) attr.Type {
	return AutoModeConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoModeConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"node_pools": basetypes.ListType{
			ElemType: types.StringType,
		},
		"node_role_arn": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CloudWatchType{}

type CloudWatchType struct {
	basetypes.ObjectType
}

func (t CloudWatchType) Equal(o attr.Type) bool {
	other, ok := o.(CloudWatchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CloudWatchType) String() string {
	return "CloudWatchType"
}

func (t CloudWatchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clusterLoggingAttribute, ok := attributes["cluster_logging"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_logging is missing from object`)

		return nil, diags
	}

	clusterLoggingVal, ok := clusterLoggingAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_logging expected to be basetypes.ListValue, was: %T`, clusterLoggingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CloudWatchValue{
		ClusterLogging: clusterLoggingVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCloudWatchValueNull() CloudWatchValue {
	return CloudWatchValue{
		state: attr.ValueStateNull,
	}
}

func NewCloudWatchValueUnknown() CloudWatchValue {
	return CloudWatchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCloudWatchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CloudWatchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CloudWatchValue Attribute Value",
				"While creating a CloudWatchValue value, a missing attribute value was detected. "+
					"A CloudWatchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudWatchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CloudWatchValue Attribute Type",
				"While creating a CloudWatchValue value, an invalid attribute value was detected. "+
					"A CloudWatchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudWatchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CloudWatchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CloudWatchValue Attribute Value",
				"While creating a CloudWatchValue value, an extra attribute value was detected. "+
					"A CloudWatchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CloudWatchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCloudWatchValueUnknown(), diags
	}

	clusterLoggingAttribute, ok := attributes["cluster_logging"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_logging is missing from object`)

		return NewCloudWatchValueUnknown(), diags
	}

	clusterLoggingVal, ok := clusterLoggingAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_logging expected to be basetypes.ListValue, was: %T`, clusterLoggingAttribute))
	}

	if diags.HasError() {
		return NewCloudWatchValueUnknown(), diags
	}

	return CloudWatchValue{
		ClusterLogging: clusterLoggingVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCloudWatchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CloudWatchValue {
	object, diags := NewCloudWatchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCloudWatchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CloudWatchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCloudWatchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCloudWatchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCloudWatchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCloudWatchValueMust(CloudWatchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CloudWatchType) ValueType(ctx context.Context) attr.Value {
	return CloudWatchValue{}
}

var _ basetypes.ObjectValuable = CloudWatchValue{}

type CloudWatchValue struct {
	ClusterLogging basetypes.ListValue `tfsdk:"cluster_logging"`
	state          attr.ValueState
}

func (v CloudWatchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["cluster_logging"] = basetypes.ListType{
		ElemType: ClusterLoggingValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ClusterLogging.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_logging"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CloudWatchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CloudWatchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CloudWatchValue) String() string {
	return "CloudWatchValue"
}

func (v CloudWatchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	clusterLogging := types.ListValueMust(
		ClusterLoggingType{
			basetypes.ObjectType{
				AttrTypes: ClusterLoggingValue{}.AttributeTypes(ctx),
			},
		},
		v.ClusterLogging.Elements(),
	)

	if v.ClusterLogging.IsNull() {
		clusterLogging = types.ListNull(
			ClusterLoggingType{
				basetypes.ObjectType{
					AttrTypes: ClusterLoggingValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ClusterLogging.IsUnknown() {
		clusterLogging = types.ListUnknown(
			ClusterLoggingType{
				basetypes.ObjectType{
					AttrTypes: ClusterLoggingValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"cluster_logging": basetypes.ListType{
			ElemType: ClusterLoggingValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cluster_logging": clusterLogging,
		})

	return objVal, diags
}

func (v CloudWatchValue) Equal(o attr.Value) bool {
	other, ok := o.(CloudWatchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClusterLogging.Equal(other.ClusterLogging) {
		return false
	}

	return true
}

func (v CloudWatchValue) Type(ctx context.Context) attr.Type {
	return CloudWatchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CloudWatchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cluster_logging": basetypes.ListType{
			ElemType: ClusterLoggingValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterLoggingType{}

type ClusterLoggingType struct {
	basetypes.ObjectType
}

func (t ClusterLoggingType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterLoggingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterLoggingType) String() string {
	return "ClusterLoggingType"
}

func (t ClusterLoggingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableTypesAttribute, ok := attributes["enable_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_types is missing from object`)

		return nil, diags
	}

	enableTypesVal, ok := enableTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_types expected to be basetypes.ListValue, was: %T`, enableTypesAttribute))
	}

	logRetentionInDaysAttribute, ok := attributes["log_retention_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_retention_in_days is missing from object`)

		return nil, diags
	}

	logRetentionInDaysVal, ok := logRetentionInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_retention_in_days expected to be basetypes.Int64Value, was: %T`, logRetentionInDaysAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterLoggingValue{
		EnableTypes:        enableTypesVal,
		LogRetentionInDays: logRetentionInDaysVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewClusterLoggingValueNull() ClusterLoggingValue {
	return ClusterLoggingValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterLoggingValueUnknown() ClusterLoggingValue {
	return ClusterLoggingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterLoggingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterLoggingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterLoggingValue Attribute Value",
				"While creating a ClusterLoggingValue value, a missing attribute value was detected. "+
					"A ClusterLoggingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterLoggingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterLoggingValue Attribute Type",
				"While creating a ClusterLoggingValue value, an invalid attribute value was detected. "+
					"A ClusterLoggingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterLoggingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterLoggingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterLoggingValue Attribute Value",
				"While creating a ClusterLoggingValue value, an extra attribute value was detected. "+
					"A ClusterLoggingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterLoggingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterLoggingValueUnknown(), diags
	}

	enableTypesAttribute, ok := attributes["enable_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_types is missing from object`)

		return NewClusterLoggingValueUnknown(), diags
	}

	enableTypesVal, ok := enableTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_types expected to be basetypes.ListValue, was: %T`, enableTypesAttribute))
	}

	logRetentionInDaysAttribute, ok := attributes["log_retention_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_retention_in_days is missing from object`)

		return NewClusterLoggingValueUnknown(), diags
	}

	logRetentionInDaysVal, ok := logRetentionInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_retention_in_days expected to be basetypes.Int64Value, was: %T`, logRetentionInDaysAttribute))
	}

	if diags.HasError() {
		return NewClusterLoggingValueUnknown(), diags
	}

	return ClusterLoggingValue{
		EnableTypes:        enableTypesVal,
		LogRetentionInDays: logRetentionInDaysVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewClusterLoggingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterLoggingValue {
	object, diags := NewClusterLoggingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterLoggingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterLoggingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterLoggingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterLoggingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterLoggingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterLoggingValueMust(ClusterLoggingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterLoggingType) ValueType(ctx context.Context) attr.Value {
	return ClusterLoggingValue{}
}

var _ basetypes.ObjectValuable = ClusterLoggingValue{}

type ClusterLoggingValue struct {
	EnableTypes        basetypes.ListValue  `tfsdk:"enable_types"`
	LogRetentionInDays basetypes.Int64Value `tfsdk:"log_retention_in_days"`
	state              attr.ValueState
}

func (v ClusterLoggingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enable_types"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["log_retention_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EnableTypes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_types"] = val

		val, err = v.LogRetentionInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_retention_in_days"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterLoggingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterLoggingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterLoggingValue) String() string {
	return "ClusterLoggingValue"
}

func (v ClusterLoggingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var enableTypesVal basetypes.ListValue
	switch {
	case v.EnableTypes.IsUnknown():
		enableTypesVal = types.ListUnknown(types.StringType)
	case v.EnableTypes.IsNull():
		enableTypesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		enableTypesVal, d = types.ListValue(types.StringType, v.EnableTypes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enable_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"log_retention_in_days": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enable_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"log_retention_in_days": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable_types":          enableTypesVal,
			"log_retention_in_days": v.LogRetentionInDays,
		})

	return objVal, diags
}

func (v ClusterLoggingValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterLoggingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnableTypes.Equal(other.EnableTypes) {
		return false
	}

	if !v.LogRetentionInDays.Equal(other.LogRetentionInDays) {
		return false
	}

	return true
}

func (v ClusterLoggingValue) Type(ctx context.Context) attr.Type {
	return ClusterLoggingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterLoggingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"log_retention_in_days": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = FargateProfilesType{}

type FargateProfilesType struct {
	basetypes.ObjectType
}

func (t FargateProfilesType) Equal(o attr.Type) bool {
	other, ok := o.(FargateProfilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FargateProfilesType) String() string {
	return "FargateProfilesType"
}

func (t FargateProfilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	podExecutionRoleArnAttribute, ok := attributes["pod_execution_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_execution_role_arn is missing from object`)

		return nil, diags
	}

	podExecutionRoleArnVal, ok := podExecutionRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_execution_role_arn expected to be basetypes.StringValue, was: %T`, podExecutionRoleArnAttribute))
	}

	selectorsAttribute, ok := attributes["selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`selectors is missing from object`)

		return nil, diags
	}

	selectorsVal, ok := selectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`selectors expected to be basetypes.ListValue, was: %T`, selectorsAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FargateProfilesValue{
		Name:                nameVal,
		PodExecutionRoleArn: podExecutionRoleArnVal,
		Selectors:           selectorsVal,
		Status:              statusVal,
		Subnets:             subnetsVal,
		Tags:                tagsVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewFargateProfilesValueNull() FargateProfilesValue {
	return FargateProfilesValue{
		state: attr.ValueStateNull,
	}
}

func NewFargateProfilesValueUnknown() FargateProfilesValue {
	return FargateProfilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFargateProfilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FargateProfilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FargateProfilesValue Attribute Value",
				"While creating a FargateProfilesValue value, a missing attribute value was detected. "+
					"A FargateProfilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FargateProfilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FargateProfilesValue Attribute Type",
				"While creating a FargateProfilesValue value, an invalid attribute value was detected. "+
					"A FargateProfilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FargateProfilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FargateProfilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FargateProfilesValue Attribute Value",
				"While creating a FargateProfilesValue value, an extra attribute value was detected. "+
					"A FargateProfilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FargateProfilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFargateProfilesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFargateProfilesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	podExecutionRoleArnAttribute, ok := attributes["pod_execution_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_execution_role_arn is missing from object`)

		return NewFargateProfilesValueUnknown(), diags
	}

	podExecutionRoleArnVal, ok := podExecutionRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_execution_role_arn expected to be basetypes.StringValue, was: %T`, podExecutionRoleArnAttribute))
	}

	selectorsAttribute, ok := attributes["selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`selectors is missing from object`)

		return NewFargateProfilesValueUnknown(), diags
	}

	selectorsVal, ok := selectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`selectors expected to be basetypes.ListValue, was: %T`, selectorsAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFargateProfilesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewFargateProfilesValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewFargateProfilesValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return NewFargateProfilesValueUnknown(), diags
	}

	return FargateProfilesValue{
		Name:                nameVal,
		PodExecutionRoleArn: podExecutionRoleArnVal,
		Selectors:           selectorsVal,
		Status:              statusVal,
		Subnets:             subnetsVal,
		Tags:                tagsVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewFargateProfilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FargateProfilesValue {
	object, diags := NewFargateProfilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFargateProfilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FargateProfilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFargateProfilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFargateProfilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFargateProfilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFargateProfilesValueMust(FargateProfilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FargateProfilesType) ValueType(ctx context.Context) attr.Value {
	return FargateProfilesValue{}
}

var _ basetypes.ObjectValuable = FargateProfilesValue{}

type FargateProfilesValue struct {
	Name                basetypes.StringValue `tfsdk:"name"`
	PodExecutionRoleArn basetypes.StringValue `tfsdk:"pod_execution_role_arn"`
	Selectors           basetypes.ListValue   `tfsdk:"selectors"`
	Status              basetypes.StringValue `tfsdk:"status"`
	Subnets             basetypes.ListValue   `tfsdk:"subnets"`
	Tags                basetypes.MapValue    `tfsdk:"tags"`
	state               attr.ValueState
}

func (v FargateProfilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod_execution_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["selectors"] = basetypes.ListType{
		ElemType: SelectorsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PodExecutionRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_execution_role_arn"] = val

		val, err = v.Selectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["selectors"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FargateProfilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FargateProfilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FargateProfilesValue) String() string {
	return "FargateProfilesValue"
}

func (v FargateProfilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	selectors := types.ListValueMust(
		SelectorsType{
			basetypes.ObjectType{
				AttrTypes: SelectorsValue{}.AttributeTypes(ctx),
			},
		},
		v.Selectors.Elements(),
	)

	if v.Selectors.IsNull() {
		selectors = types.ListNull(
			SelectorsType{
				basetypes.ObjectType{
					AttrTypes: SelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Selectors.IsUnknown() {
		selectors = types.ListUnknown(
			SelectorsType{
				basetypes.ObjectType{
					AttrTypes: SelectorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var subnetsVal basetypes.ListValue
	switch {
	case v.Subnets.IsUnknown():
		subnetsVal = types.ListUnknown(types.StringType)
	case v.Subnets.IsNull():
		subnetsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		subnetsVal, d = types.ListValue(types.StringType, v.Subnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"name":                   basetypes.StringType{},
			"pod_execution_role_arn": basetypes.StringType{},
			"selectors": basetypes.ListType{
				ElemType: SelectorsValue{}.Type(ctx),
			},
			"status": basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"name":                   basetypes.StringType{},
			"pod_execution_role_arn": basetypes.StringType{},
			"selectors": basetypes.ListType{
				ElemType: SelectorsValue{}.Type(ctx),
			},
			"status": basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"name":                   basetypes.StringType{},
		"pod_execution_role_arn": basetypes.StringType{},
		"selectors": basetypes.ListType{
			ElemType: SelectorsValue{}.Type(ctx),
		},
		"status": basetypes.StringType{},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":                   v.Name,
			"pod_execution_role_arn": v.PodExecutionRoleArn,
			"selectors":              selectors,
			"status":                 v.Status,
			"subnets":                subnetsVal,
			"tags":                   tagsVal,
		})

	return objVal, diags
}

func (v FargateProfilesValue) Equal(o attr.Value) bool {
	other, ok := o.(FargateProfilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PodExecutionRoleArn.Equal(other.PodExecutionRoleArn) {
		return false
	}

	if !v.Selectors.Equal(other.Selectors) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	return true
}

func (v FargateProfilesValue) Type(ctx context.Context) attr.Type {
	return FargateProfilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FargateProfilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":                   basetypes.StringType{},
		"pod_execution_role_arn": basetypes.StringType{},
		"selectors": basetypes.ListType{
			ElemType: SelectorsValue{}.Type(ctx),
		},
		"status": basetypes.StringType{},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = SelectorsType{}

type SelectorsType struct {
	basetypes.ObjectType
}

func (t SelectorsType) Equal(o attr.Type) bool {
	other, ok := o.(SelectorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SelectorsType) String() string {
	return "SelectorsType"
}

func (t SelectorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SelectorsValue{
		Labels:    labelsVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSelectorsValueNull() SelectorsValue {
	return SelectorsValue{
		state: attr.ValueStateNull,
	}
}

func NewSelectorsValueUnknown() SelectorsValue {
	return SelectorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSelectorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SelectorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SelectorsValue Attribute Value",
				"While creating a SelectorsValue value, a missing attribute value was detected. "+
					"A SelectorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelectorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SelectorsValue Attribute Type",
				"While creating a SelectorsValue value, an invalid attribute value was detected. "+
					"A SelectorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelectorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SelectorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SelectorsValue Attribute Value",
				"While creating a SelectorsValue value, an extra attribute value was detected. "+
					"A SelectorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SelectorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSelectorsValueUnknown(), diags
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewSelectorsValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewSelectorsValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewSelectorsValueUnknown(), diags
	}

	return SelectorsValue{
		Labels:    labelsVal,
		Namespace: namespaceVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSelectorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SelectorsValue {
	object, diags := NewSelectorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSelectorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SelectorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSelectorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSelectorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSelectorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSelectorsValueMust(SelectorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SelectorsType) ValueType(ctx context.Context) attr.Value {
	return SelectorsValue{}
}

var _ basetypes.ObjectValuable = SelectorsValue{}

type SelectorsValue struct {
	Labels    basetypes.MapValue    `tfsdk:"labels"`
	Namespace basetypes.StringValue `tfsdk:"namespace"`
	state     attr.ValueState
}

func (v SelectorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SelectorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SelectorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SelectorsValue) String() string {
	return "SelectorsValue"
}

func (v SelectorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"labels":    labelsVal,
			"namespace": v.Namespace,
		})

	return objVal, diags
}

func (v SelectorsValue) Equal(o attr.Value) bool {
	other, ok := o.(SelectorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v SelectorsValue) Type(ctx context.Context) attr.Type {
	return SelectorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SelectorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Iam3Type{}

type Iam3Type struct {
	basetypes.ObjectType
}

func (t Iam3Type) Equal(o attr.Type) bool {
	other, ok := o.(Iam3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Iam3Type) String() string {
	return "Iam3Type"
}

func (t Iam3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fargatePodExecutionRoleArnAttribute, ok := attributes["fargate_pod_execution_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fargate_pod_execution_role_arn is missing from object`)

		return nil, diags
	}

	fargatePodExecutionRoleArnVal, ok := fargatePodExecutionRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fargate_pod_execution_role_arn expected to be basetypes.StringValue, was: %T`, fargatePodExecutionRoleArnAttribute))
	}

	fargatePodExecutionRolePermissionsBoundaryAttribute, ok := attributes["fargate_pod_execution_role_permissions_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fargate_pod_execution_role_permissions_boundary is missing from object`)

		return nil, diags
	}

	fargatePodExecutionRolePermissionsBoundaryVal, ok := fargatePodExecutionRolePermissionsBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fargate_pod_execution_role_permissions_boundary expected to be basetypes.StringValue, was: %T`, fargatePodExecutionRolePermissionsBoundaryAttribute))
	}

	podIdentityAssociationsAttribute, ok := attributes["pod_identity_associations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_identity_associations is missing from object`)

		return nil, diags
	}

	podIdentityAssociationsVal, ok := podIdentityAssociationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_identity_associations expected to be basetypes.ListValue, was: %T`, podIdentityAssociationsAttribute))
	}

	serviceAccountsAttribute, ok := attributes["service_accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_accounts is missing from object`)

		return nil, diags
	}

	serviceAccountsVal, ok := serviceAccountsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_accounts expected to be basetypes.SetValue, was: %T`, serviceAccountsAttribute))
	}

	serviceRoleArnAttribute, ok := attributes["service_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_role_arn is missing from object`)

		return nil, diags
	}

	serviceRoleArnVal, ok := serviceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_role_arn expected to be basetypes.StringValue, was: %T`, serviceRoleArnAttribute))
	}

	serviceRolePermissionBoundaryAttribute, ok := attributes["service_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_role_permission_boundary is missing from object`)

		return nil, diags
	}

	serviceRolePermissionBoundaryVal, ok := serviceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_role_permission_boundary expected to be basetypes.StringValue, was: %T`, serviceRolePermissionBoundaryAttribute))
	}

	vpcResourceControllerPolicyAttribute, ok := attributes["vpc_resource_controller_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_resource_controller_policy is missing from object`)

		return nil, diags
	}

	vpcResourceControllerPolicyVal, ok := vpcResourceControllerPolicyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_resource_controller_policy expected to be basetypes.BoolValue, was: %T`, vpcResourceControllerPolicyAttribute))
	}

	withOidcAttribute, ok := attributes["with_oidc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_oidc is missing from object`)

		return nil, diags
	}

	withOidcVal, ok := withOidcAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_oidc expected to be basetypes.BoolValue, was: %T`, withOidcAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Iam3Value{
		FargatePodExecutionRoleArn:                 fargatePodExecutionRoleArnVal,
		FargatePodExecutionRolePermissionsBoundary: fargatePodExecutionRolePermissionsBoundaryVal,
		PodIdentityAssociations:                    podIdentityAssociationsVal,
		ServiceAccounts:                            serviceAccountsVal,
		ServiceRoleArn:                             serviceRoleArnVal,
		ServiceRolePermissionBoundary:              serviceRolePermissionBoundaryVal,
		VpcResourceControllerPolicy:                vpcResourceControllerPolicyVal,
		WithOidc:                                   withOidcVal,
		state:                                      attr.ValueStateKnown,
	}, diags
}

func NewIam3ValueNull() Iam3Value {
	return Iam3Value{
		state: attr.ValueStateNull,
	}
}

func NewIam3ValueUnknown() Iam3Value {
	return Iam3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIam3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Iam3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Iam3Value Attribute Value",
				"While creating a Iam3Value value, a missing attribute value was detected. "+
					"A Iam3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Iam3Value Attribute Type",
				"While creating a Iam3Value value, an invalid attribute value was detected. "+
					"A Iam3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Iam3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Iam3Value Attribute Value",
				"While creating a Iam3Value value, an extra attribute value was detected. "+
					"A Iam3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Iam3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIam3ValueUnknown(), diags
	}

	fargatePodExecutionRoleArnAttribute, ok := attributes["fargate_pod_execution_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fargate_pod_execution_role_arn is missing from object`)

		return NewIam3ValueUnknown(), diags
	}

	fargatePodExecutionRoleArnVal, ok := fargatePodExecutionRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fargate_pod_execution_role_arn expected to be basetypes.StringValue, was: %T`, fargatePodExecutionRoleArnAttribute))
	}

	fargatePodExecutionRolePermissionsBoundaryAttribute, ok := attributes["fargate_pod_execution_role_permissions_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fargate_pod_execution_role_permissions_boundary is missing from object`)

		return NewIam3ValueUnknown(), diags
	}

	fargatePodExecutionRolePermissionsBoundaryVal, ok := fargatePodExecutionRolePermissionsBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fargate_pod_execution_role_permissions_boundary expected to be basetypes.StringValue, was: %T`, fargatePodExecutionRolePermissionsBoundaryAttribute))
	}

	podIdentityAssociationsAttribute, ok := attributes["pod_identity_associations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_identity_associations is missing from object`)

		return NewIam3ValueUnknown(), diags
	}

	podIdentityAssociationsVal, ok := podIdentityAssociationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_identity_associations expected to be basetypes.ListValue, was: %T`, podIdentityAssociationsAttribute))
	}

	serviceAccountsAttribute, ok := attributes["service_accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_accounts is missing from object`)

		return NewIam3ValueUnknown(), diags
	}

	serviceAccountsVal, ok := serviceAccountsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_accounts expected to be basetypes.SetValue, was: %T`, serviceAccountsAttribute))
	}

	serviceRoleArnAttribute, ok := attributes["service_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_role_arn is missing from object`)

		return NewIam3ValueUnknown(), diags
	}

	serviceRoleArnVal, ok := serviceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_role_arn expected to be basetypes.StringValue, was: %T`, serviceRoleArnAttribute))
	}

	serviceRolePermissionBoundaryAttribute, ok := attributes["service_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_role_permission_boundary is missing from object`)

		return NewIam3ValueUnknown(), diags
	}

	serviceRolePermissionBoundaryVal, ok := serviceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_role_permission_boundary expected to be basetypes.StringValue, was: %T`, serviceRolePermissionBoundaryAttribute))
	}

	vpcResourceControllerPolicyAttribute, ok := attributes["vpc_resource_controller_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_resource_controller_policy is missing from object`)

		return NewIam3ValueUnknown(), diags
	}

	vpcResourceControllerPolicyVal, ok := vpcResourceControllerPolicyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_resource_controller_policy expected to be basetypes.BoolValue, was: %T`, vpcResourceControllerPolicyAttribute))
	}

	withOidcAttribute, ok := attributes["with_oidc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_oidc is missing from object`)

		return NewIam3ValueUnknown(), diags
	}

	withOidcVal, ok := withOidcAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_oidc expected to be basetypes.BoolValue, was: %T`, withOidcAttribute))
	}

	if diags.HasError() {
		return NewIam3ValueUnknown(), diags
	}

	return Iam3Value{
		FargatePodExecutionRoleArn:                 fargatePodExecutionRoleArnVal,
		FargatePodExecutionRolePermissionsBoundary: fargatePodExecutionRolePermissionsBoundaryVal,
		PodIdentityAssociations:                    podIdentityAssociationsVal,
		ServiceAccounts:                            serviceAccountsVal,
		ServiceRoleArn:                             serviceRoleArnVal,
		ServiceRolePermissionBoundary:              serviceRolePermissionBoundaryVal,
		VpcResourceControllerPolicy:                vpcResourceControllerPolicyVal,
		WithOidc:                                   withOidcVal,
		state:                                      attr.ValueStateKnown,
	}, diags
}

func NewIam3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Iam3Value {
	object, diags := NewIam3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIam3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Iam3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIam3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIam3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIam3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIam3ValueMust(Iam3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Iam3Type) ValueType(ctx context.Context) attr.Value {
	return Iam3Value{}
}

var _ basetypes.ObjectValuable = Iam3Value{}

type Iam3Value struct {
	FargatePodExecutionRoleArn                 basetypes.StringValue `tfsdk:"fargate_pod_execution_role_arn"`
	FargatePodExecutionRolePermissionsBoundary basetypes.StringValue `tfsdk:"fargate_pod_execution_role_permissions_boundary"`
	PodIdentityAssociations                    basetypes.ListValue   `tfsdk:"pod_identity_associations"`
	ServiceAccounts                            basetypes.SetValue    `tfsdk:"service_accounts"`
	ServiceRoleArn                             basetypes.StringValue `tfsdk:"service_role_arn"`
	ServiceRolePermissionBoundary              basetypes.StringValue `tfsdk:"service_role_permission_boundary"`
	VpcResourceControllerPolicy                basetypes.BoolValue   `tfsdk:"vpc_resource_controller_policy"`
	WithOidc                                   basetypes.BoolValue   `tfsdk:"with_oidc"`
	state                                      attr.ValueState
}

func (v Iam3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["fargate_pod_execution_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fargate_pod_execution_role_permissions_boundary"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod_identity_associations"] = basetypes.ListType{
		ElemType: PodIdentityAssociationsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_accounts"] = basetypes.SetType{
		ElemType: ServiceAccountsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_role_permission_boundary"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpc_resource_controller_policy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["with_oidc"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.FargatePodExecutionRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fargate_pod_execution_role_arn"] = val

		val, err = v.FargatePodExecutionRolePermissionsBoundary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fargate_pod_execution_role_permissions_boundary"] = val

		val, err = v.PodIdentityAssociations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_identity_associations"] = val

		val, err = v.ServiceAccounts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_accounts"] = val

		val, err = v.ServiceRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_role_arn"] = val

		val, err = v.ServiceRolePermissionBoundary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_role_permission_boundary"] = val

		val, err = v.VpcResourceControllerPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpc_resource_controller_policy"] = val

		val, err = v.WithOidc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_oidc"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Iam3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Iam3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Iam3Value) String() string {
	return "Iam3Value"
}

func (v Iam3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	podIdentityAssociations := types.ListValueMust(
		PodIdentityAssociationsType{
			basetypes.ObjectType{
				AttrTypes: PodIdentityAssociationsValue{}.AttributeTypes(ctx),
			},
		},
		v.PodIdentityAssociations.Elements(),
	)

	if v.PodIdentityAssociations.IsNull() {
		podIdentityAssociations = types.ListNull(
			PodIdentityAssociationsType{
				basetypes.ObjectType{
					AttrTypes: PodIdentityAssociationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PodIdentityAssociations.IsUnknown() {
		podIdentityAssociations = types.ListUnknown(
			PodIdentityAssociationsType{
				basetypes.ObjectType{
					AttrTypes: PodIdentityAssociationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	serviceAccounts := types.SetValueMust(
		ServiceAccountsType{
			basetypes.ObjectType{
				AttrTypes: ServiceAccountsValue{}.AttributeTypes(ctx),
			},
		},
		v.ServiceAccounts.Elements(),
	)

	if v.ServiceAccounts.IsNull() {
		serviceAccounts = types.SetNull(
			ServiceAccountsType{
				basetypes.ObjectType{
					AttrTypes: ServiceAccountsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ServiceAccounts.IsUnknown() {
		serviceAccounts = types.SetUnknown(
			ServiceAccountsType{
				basetypes.ObjectType{
					AttrTypes: ServiceAccountsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"fargate_pod_execution_role_arn":                  basetypes.StringType{},
		"fargate_pod_execution_role_permissions_boundary": basetypes.StringType{},
		"pod_identity_associations": basetypes.ListType{
			ElemType: PodIdentityAssociationsValue{}.Type(ctx),
		},
		"service_accounts": basetypes.SetType{
			ElemType: ServiceAccountsValue{}.Type(ctx),
		},
		"service_role_arn":                 basetypes.StringType{},
		"service_role_permission_boundary": basetypes.StringType{},
		"vpc_resource_controller_policy":   basetypes.BoolType{},
		"with_oidc":                        basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fargate_pod_execution_role_arn":                  v.FargatePodExecutionRoleArn,
			"fargate_pod_execution_role_permissions_boundary": v.FargatePodExecutionRolePermissionsBoundary,
			"pod_identity_associations":                       podIdentityAssociations,
			"service_accounts":                                serviceAccounts,
			"service_role_arn":                                v.ServiceRoleArn,
			"service_role_permission_boundary":                v.ServiceRolePermissionBoundary,
			"vpc_resource_controller_policy":                  v.VpcResourceControllerPolicy,
			"with_oidc":                                       v.WithOidc,
		})

	return objVal, diags
}

func (v Iam3Value) Equal(o attr.Value) bool {
	other, ok := o.(Iam3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FargatePodExecutionRoleArn.Equal(other.FargatePodExecutionRoleArn) {
		return false
	}

	if !v.FargatePodExecutionRolePermissionsBoundary.Equal(other.FargatePodExecutionRolePermissionsBoundary) {
		return false
	}

	if !v.PodIdentityAssociations.Equal(other.PodIdentityAssociations) {
		return false
	}

	if !v.ServiceAccounts.Equal(other.ServiceAccounts) {
		return false
	}

	if !v.ServiceRoleArn.Equal(other.ServiceRoleArn) {
		return false
	}

	if !v.ServiceRolePermissionBoundary.Equal(other.ServiceRolePermissionBoundary) {
		return false
	}

	if !v.VpcResourceControllerPolicy.Equal(other.VpcResourceControllerPolicy) {
		return false
	}

	if !v.WithOidc.Equal(other.WithOidc) {
		return false
	}

	return true
}

func (v Iam3Value) Type(ctx context.Context) attr.Type {
	return Iam3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Iam3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fargate_pod_execution_role_arn":                  basetypes.StringType{},
		"fargate_pod_execution_role_permissions_boundary": basetypes.StringType{},
		"pod_identity_associations": basetypes.ListType{
			ElemType: PodIdentityAssociationsValue{}.Type(ctx),
		},
		"service_accounts": basetypes.SetType{
			ElemType: ServiceAccountsValue{}.Type(ctx),
		},
		"service_role_arn":                 basetypes.StringType{},
		"service_role_permission_boundary": basetypes.StringType{},
		"vpc_resource_controller_policy":   basetypes.BoolType{},
		"with_oidc":                        basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PodIdentityAssociationsType{}

type PodIdentityAssociationsType struct {
	basetypes.ObjectType
}

func (t PodIdentityAssociationsType) Equal(o attr.Type) bool {
	other, ok := o.(PodIdentityAssociationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodIdentityAssociationsType) String() string {
	return "PodIdentityAssociationsType"
}

func (t PodIdentityAssociationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createServiceAccountAttribute, ok := attributes["create_service_account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_service_account is missing from object`)

		return nil, diags
	}

	createServiceAccountVal, ok := createServiceAccountAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_service_account expected to be basetypes.BoolValue, was: %T`, createServiceAccountAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	permissionBoundaryArnAttribute, ok := attributes["permission_boundary_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_boundary_arn is missing from object`)

		return nil, diags
	}

	permissionBoundaryArnVal, ok := permissionBoundaryArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_boundary_arn expected to be basetypes.StringValue, was: %T`, permissionBoundaryArnAttribute))
	}

	permissionPolicyAttribute, ok := attributes["permission_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_policy is missing from object`)

		return nil, diags
	}

	permissionPolicyVal, ok := permissionPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_policy expected to be basetypes.StringValue, was: %T`, permissionPolicyAttribute))
	}

	permissionPolicyArnsAttribute, ok := attributes["permission_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_policy_arns is missing from object`)

		return nil, diags
	}

	permissionPolicyArnsVal, ok := permissionPolicyArnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_policy_arns expected to be basetypes.ListValue, was: %T`, permissionPolicyArnsAttribute))
	}

	roleArnAttribute, ok := attributes["role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_arn is missing from object`)

		return nil, diags
	}

	roleArnVal, ok := roleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_arn expected to be basetypes.StringValue, was: %T`, roleArnAttribute))
	}

	roleNameAttribute, ok := attributes["role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_name is missing from object`)

		return nil, diags
	}

	roleNameVal, ok := roleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_name expected to be basetypes.StringValue, was: %T`, roleNameAttribute))
	}

	serviceAccountNameAttribute, ok := attributes["service_account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_name is missing from object`)

		return nil, diags
	}

	serviceAccountNameVal, ok := serviceAccountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_name expected to be basetypes.StringValue, was: %T`, serviceAccountNameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	wellKnownPoliciesAttribute, ok := attributes["well_known_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`well_known_policies is missing from object`)

		return nil, diags
	}

	wellKnownPoliciesVal, ok := wellKnownPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`well_known_policies expected to be basetypes.ListValue, was: %T`, wellKnownPoliciesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodIdentityAssociationsValue{
		CreateServiceAccount:  createServiceAccountVal,
		Namespace:             namespaceVal,
		PermissionBoundaryArn: permissionBoundaryArnVal,
		PermissionPolicy:      permissionPolicyVal,
		PermissionPolicyArns:  permissionPolicyArnsVal,
		RoleArn:               roleArnVal,
		RoleName:              roleNameVal,
		ServiceAccountName:    serviceAccountNameVal,
		Tags:                  tagsVal,
		WellKnownPolicies:     wellKnownPoliciesVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPodIdentityAssociationsValueNull() PodIdentityAssociationsValue {
	return PodIdentityAssociationsValue{
		state: attr.ValueStateNull,
	}
}

func NewPodIdentityAssociationsValueUnknown() PodIdentityAssociationsValue {
	return PodIdentityAssociationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodIdentityAssociationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodIdentityAssociationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodIdentityAssociationsValue Attribute Value",
				"While creating a PodIdentityAssociationsValue value, a missing attribute value was detected. "+
					"A PodIdentityAssociationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodIdentityAssociationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodIdentityAssociationsValue Attribute Type",
				"While creating a PodIdentityAssociationsValue value, an invalid attribute value was detected. "+
					"A PodIdentityAssociationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodIdentityAssociationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodIdentityAssociationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodIdentityAssociationsValue Attribute Value",
				"While creating a PodIdentityAssociationsValue value, an extra attribute value was detected. "+
					"A PodIdentityAssociationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodIdentityAssociationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	createServiceAccountAttribute, ok := attributes["create_service_account"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_service_account is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	createServiceAccountVal, ok := createServiceAccountAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_service_account expected to be basetypes.BoolValue, was: %T`, createServiceAccountAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	permissionBoundaryArnAttribute, ok := attributes["permission_boundary_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_boundary_arn is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	permissionBoundaryArnVal, ok := permissionBoundaryArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_boundary_arn expected to be basetypes.StringValue, was: %T`, permissionBoundaryArnAttribute))
	}

	permissionPolicyAttribute, ok := attributes["permission_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_policy is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	permissionPolicyVal, ok := permissionPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_policy expected to be basetypes.StringValue, was: %T`, permissionPolicyAttribute))
	}

	permissionPolicyArnsAttribute, ok := attributes["permission_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission_policy_arns is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	permissionPolicyArnsVal, ok := permissionPolicyArnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission_policy_arns expected to be basetypes.ListValue, was: %T`, permissionPolicyArnsAttribute))
	}

	roleArnAttribute, ok := attributes["role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_arn is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	roleArnVal, ok := roleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_arn expected to be basetypes.StringValue, was: %T`, roleArnAttribute))
	}

	roleNameAttribute, ok := attributes["role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_name is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	roleNameVal, ok := roleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_name expected to be basetypes.StringValue, was: %T`, roleNameAttribute))
	}

	serviceAccountNameAttribute, ok := attributes["service_account_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_account_name is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	serviceAccountNameVal, ok := serviceAccountNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_account_name expected to be basetypes.StringValue, was: %T`, serviceAccountNameAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	wellKnownPoliciesAttribute, ok := attributes["well_known_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`well_known_policies is missing from object`)

		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	wellKnownPoliciesVal, ok := wellKnownPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`well_known_policies expected to be basetypes.ListValue, was: %T`, wellKnownPoliciesAttribute))
	}

	if diags.HasError() {
		return NewPodIdentityAssociationsValueUnknown(), diags
	}

	return PodIdentityAssociationsValue{
		CreateServiceAccount:  createServiceAccountVal,
		Namespace:             namespaceVal,
		PermissionBoundaryArn: permissionBoundaryArnVal,
		PermissionPolicy:      permissionPolicyVal,
		PermissionPolicyArns:  permissionPolicyArnsVal,
		RoleArn:               roleArnVal,
		RoleName:              roleNameVal,
		ServiceAccountName:    serviceAccountNameVal,
		Tags:                  tagsVal,
		WellKnownPolicies:     wellKnownPoliciesVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPodIdentityAssociationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodIdentityAssociationsValue {
	object, diags := NewPodIdentityAssociationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodIdentityAssociationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodIdentityAssociationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodIdentityAssociationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodIdentityAssociationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodIdentityAssociationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodIdentityAssociationsValueMust(PodIdentityAssociationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodIdentityAssociationsType) ValueType(ctx context.Context) attr.Value {
	return PodIdentityAssociationsValue{}
}

var _ basetypes.ObjectValuable = PodIdentityAssociationsValue{}

type PodIdentityAssociationsValue struct {
	CreateServiceAccount  basetypes.BoolValue   `tfsdk:"create_service_account"`
	Namespace             basetypes.StringValue `tfsdk:"namespace"`
	PermissionBoundaryArn basetypes.StringValue `tfsdk:"permission_boundary_arn"`
	PermissionPolicy      basetypes.StringValue `tfsdk:"permission_policy"`
	PermissionPolicyArns  basetypes.ListValue   `tfsdk:"permission_policy_arns"`
	RoleArn               basetypes.StringValue `tfsdk:"role_arn"`
	RoleName              basetypes.StringValue `tfsdk:"role_name"`
	ServiceAccountName    basetypes.StringValue `tfsdk:"service_account_name"`
	Tags                  basetypes.MapValue    `tfsdk:"tags"`
	WellKnownPolicies     basetypes.ListValue   `tfsdk:"well_known_policies"`
	state                 attr.ValueState
}

func (v PodIdentityAssociationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["create_service_account"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission_boundary_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission_policy_arns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_account_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["well_known_policies"] = basetypes.ListType{
		ElemType: WellKnownPoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.CreateServiceAccount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["create_service_account"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		val, err = v.PermissionBoundaryArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission_boundary_arn"] = val

		val, err = v.PermissionPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission_policy"] = val

		val, err = v.PermissionPolicyArns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission_policy_arns"] = val

		val, err = v.RoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_arn"] = val

		val, err = v.RoleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_name"] = val

		val, err = v.ServiceAccountName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_account_name"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.WellKnownPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["well_known_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodIdentityAssociationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodIdentityAssociationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodIdentityAssociationsValue) String() string {
	return "PodIdentityAssociationsValue"
}

func (v PodIdentityAssociationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	wellKnownPolicies := types.ListValueMust(
		WellKnownPoliciesType{
			basetypes.ObjectType{
				AttrTypes: WellKnownPoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.WellKnownPolicies.Elements(),
	)

	if v.WellKnownPolicies.IsNull() {
		wellKnownPolicies = types.ListNull(
			WellKnownPoliciesType{
				basetypes.ObjectType{
					AttrTypes: WellKnownPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.WellKnownPolicies.IsUnknown() {
		wellKnownPolicies = types.ListUnknown(
			WellKnownPoliciesType{
				basetypes.ObjectType{
					AttrTypes: WellKnownPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var permissionPolicyArnsVal basetypes.ListValue
	switch {
	case v.PermissionPolicyArns.IsUnknown():
		permissionPolicyArnsVal = types.ListUnknown(types.StringType)
	case v.PermissionPolicyArns.IsNull():
		permissionPolicyArnsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		permissionPolicyArnsVal, d = types.ListValue(types.StringType, v.PermissionPolicyArns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"create_service_account":  basetypes.BoolType{},
			"namespace":               basetypes.StringType{},
			"permission_boundary_arn": basetypes.StringType{},
			"permission_policy":       basetypes.StringType{},
			"permission_policy_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"role_arn":             basetypes.StringType{},
			"role_name":            basetypes.StringType{},
			"service_account_name": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"well_known_policies": basetypes.ListType{
				ElemType: WellKnownPoliciesValue{}.Type(ctx),
			},
		}), diags
	}

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"create_service_account":  basetypes.BoolType{},
			"namespace":               basetypes.StringType{},
			"permission_boundary_arn": basetypes.StringType{},
			"permission_policy":       basetypes.StringType{},
			"permission_policy_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"role_arn":             basetypes.StringType{},
			"role_name":            basetypes.StringType{},
			"service_account_name": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"well_known_policies": basetypes.ListType{
				ElemType: WellKnownPoliciesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"create_service_account":  basetypes.BoolType{},
		"namespace":               basetypes.StringType{},
		"permission_boundary_arn": basetypes.StringType{},
		"permission_policy":       basetypes.StringType{},
		"permission_policy_arns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"role_arn":             basetypes.StringType{},
		"role_name":            basetypes.StringType{},
		"service_account_name": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"well_known_policies": basetypes.ListType{
			ElemType: WellKnownPoliciesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"create_service_account":  v.CreateServiceAccount,
			"namespace":               v.Namespace,
			"permission_boundary_arn": v.PermissionBoundaryArn,
			"permission_policy":       v.PermissionPolicy,
			"permission_policy_arns":  permissionPolicyArnsVal,
			"role_arn":                v.RoleArn,
			"role_name":               v.RoleName,
			"service_account_name":    v.ServiceAccountName,
			"tags":                    tagsVal,
			"well_known_policies":     wellKnownPolicies,
		})

	return objVal, diags
}

func (v PodIdentityAssociationsValue) Equal(o attr.Value) bool {
	other, ok := o.(PodIdentityAssociationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreateServiceAccount.Equal(other.CreateServiceAccount) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	if !v.PermissionBoundaryArn.Equal(other.PermissionBoundaryArn) {
		return false
	}

	if !v.PermissionPolicy.Equal(other.PermissionPolicy) {
		return false
	}

	if !v.PermissionPolicyArns.Equal(other.PermissionPolicyArns) {
		return false
	}

	if !v.RoleArn.Equal(other.RoleArn) {
		return false
	}

	if !v.RoleName.Equal(other.RoleName) {
		return false
	}

	if !v.ServiceAccountName.Equal(other.ServiceAccountName) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.WellKnownPolicies.Equal(other.WellKnownPolicies) {
		return false
	}

	return true
}

func (v PodIdentityAssociationsValue) Type(ctx context.Context) attr.Type {
	return PodIdentityAssociationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodIdentityAssociationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"create_service_account":  basetypes.BoolType{},
		"namespace":               basetypes.StringType{},
		"permission_boundary_arn": basetypes.StringType{},
		"permission_policy":       basetypes.StringType{},
		"permission_policy_arns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"role_arn":             basetypes.StringType{},
		"role_name":            basetypes.StringType{},
		"service_account_name": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"well_known_policies": basetypes.ListType{
			ElemType: WellKnownPoliciesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = WellKnownPoliciesType{}

type WellKnownPoliciesType struct {
	basetypes.ObjectType
}

func (t WellKnownPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(WellKnownPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WellKnownPoliciesType) String() string {
	return "WellKnownPoliciesType"
}

func (t WellKnownPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	awsLoadBalancerControllerAttribute, ok := attributes["aws_load_balancer_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_load_balancer_controller is missing from object`)

		return nil, diags
	}

	awsLoadBalancerControllerVal, ok := awsLoadBalancerControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_load_balancer_controller expected to be basetypes.BoolValue, was: %T`, awsLoadBalancerControllerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	ebsCsiControllerAttribute, ok := attributes["ebs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_csi_controller is missing from object`)

		return nil, diags
	}

	ebsCsiControllerVal, ok := ebsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_csi_controller expected to be basetypes.BoolValue, was: %T`, ebsCsiControllerAttribute))
	}

	efsCsiControllerAttribute, ok := attributes["efs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs_csi_controller is missing from object`)

		return nil, diags
	}

	efsCsiControllerVal, ok := efsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs_csi_controller expected to be basetypes.BoolValue, was: %T`, efsCsiControllerAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WellKnownPoliciesValue{
		AutoScaler:                autoScalerVal,
		AwsLoadBalancerController: awsLoadBalancerControllerVal,
		CertManager:               certManagerVal,
		EbsCsiController:          ebsCsiControllerVal,
		EfsCsiController:          efsCsiControllerVal,
		ExternalDns:               externalDnsVal,
		ImageBuilder:              imageBuilderVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWellKnownPoliciesValueNull() WellKnownPoliciesValue {
	return WellKnownPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewWellKnownPoliciesValueUnknown() WellKnownPoliciesValue {
	return WellKnownPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWellKnownPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WellKnownPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WellKnownPoliciesValue Attribute Value",
				"While creating a WellKnownPoliciesValue value, a missing attribute value was detected. "+
					"A WellKnownPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WellKnownPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WellKnownPoliciesValue Attribute Type",
				"While creating a WellKnownPoliciesValue value, an invalid attribute value was detected. "+
					"A WellKnownPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WellKnownPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WellKnownPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WellKnownPoliciesValue Attribute Value",
				"While creating a WellKnownPoliciesValue value, an extra attribute value was detected. "+
					"A WellKnownPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WellKnownPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWellKnownPoliciesValueUnknown(), diags
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewWellKnownPoliciesValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	awsLoadBalancerControllerAttribute, ok := attributes["aws_load_balancer_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_load_balancer_controller is missing from object`)

		return NewWellKnownPoliciesValueUnknown(), diags
	}

	awsLoadBalancerControllerVal, ok := awsLoadBalancerControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_load_balancer_controller expected to be basetypes.BoolValue, was: %T`, awsLoadBalancerControllerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewWellKnownPoliciesValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	ebsCsiControllerAttribute, ok := attributes["ebs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_csi_controller is missing from object`)

		return NewWellKnownPoliciesValueUnknown(), diags
	}

	ebsCsiControllerVal, ok := ebsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_csi_controller expected to be basetypes.BoolValue, was: %T`, ebsCsiControllerAttribute))
	}

	efsCsiControllerAttribute, ok := attributes["efs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs_csi_controller is missing from object`)

		return NewWellKnownPoliciesValueUnknown(), diags
	}

	efsCsiControllerVal, ok := efsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs_csi_controller expected to be basetypes.BoolValue, was: %T`, efsCsiControllerAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewWellKnownPoliciesValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewWellKnownPoliciesValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	if diags.HasError() {
		return NewWellKnownPoliciesValueUnknown(), diags
	}

	return WellKnownPoliciesValue{
		AutoScaler:                autoScalerVal,
		AwsLoadBalancerController: awsLoadBalancerControllerVal,
		CertManager:               certManagerVal,
		EbsCsiController:          ebsCsiControllerVal,
		EfsCsiController:          efsCsiControllerVal,
		ExternalDns:               externalDnsVal,
		ImageBuilder:              imageBuilderVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWellKnownPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WellKnownPoliciesValue {
	object, diags := NewWellKnownPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWellKnownPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WellKnownPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWellKnownPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWellKnownPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWellKnownPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWellKnownPoliciesValueMust(WellKnownPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WellKnownPoliciesType) ValueType(ctx context.Context) attr.Value {
	return WellKnownPoliciesValue{}
}

var _ basetypes.ObjectValuable = WellKnownPoliciesValue{}

type WellKnownPoliciesValue struct {
	AutoScaler                basetypes.BoolValue `tfsdk:"auto_scaler"`
	AwsLoadBalancerController basetypes.BoolValue `tfsdk:"aws_load_balancer_controller"`
	CertManager               basetypes.BoolValue `tfsdk:"cert_manager"`
	EbsCsiController          basetypes.BoolValue `tfsdk:"ebs_csi_controller"`
	EfsCsiController          basetypes.BoolValue `tfsdk:"efs_csi_controller"`
	ExternalDns               basetypes.BoolValue `tfsdk:"external_dns"`
	ImageBuilder              basetypes.BoolValue `tfsdk:"image_builder"`
	state                     attr.ValueState
}

func (v WellKnownPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aws_load_balancer_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs_csi_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs_csi_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.AwsLoadBalancerController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws_load_balancer_controller"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.EbsCsiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs_csi_controller"] = val

		val, err = v.EfsCsiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs_csi_controller"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WellKnownPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WellKnownPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WellKnownPoliciesValue) String() string {
	return "WellKnownPoliciesValue"
}

func (v WellKnownPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auto_scaler":                  basetypes.BoolType{},
		"aws_load_balancer_controller": basetypes.BoolType{},
		"cert_manager":                 basetypes.BoolType{},
		"ebs_csi_controller":           basetypes.BoolType{},
		"efs_csi_controller":           basetypes.BoolType{},
		"external_dns":                 basetypes.BoolType{},
		"image_builder":                basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_scaler":                  v.AutoScaler,
			"aws_load_balancer_controller": v.AwsLoadBalancerController,
			"cert_manager":                 v.CertManager,
			"ebs_csi_controller":           v.EbsCsiController,
			"efs_csi_controller":           v.EfsCsiController,
			"external_dns":                 v.ExternalDns,
			"image_builder":                v.ImageBuilder,
		})

	return objVal, diags
}

func (v WellKnownPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(WellKnownPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.AwsLoadBalancerController.Equal(other.AwsLoadBalancerController) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.EbsCsiController.Equal(other.EbsCsiController) {
		return false
	}

	if !v.EfsCsiController.Equal(other.EfsCsiController) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	return true
}

func (v WellKnownPoliciesValue) Type(ctx context.Context) attr.Type {
	return WellKnownPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WellKnownPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_scaler":                  basetypes.BoolType{},
		"aws_load_balancer_controller": basetypes.BoolType{},
		"cert_manager":                 basetypes.BoolType{},
		"ebs_csi_controller":           basetypes.BoolType{},
		"efs_csi_controller":           basetypes.BoolType{},
		"external_dns":                 basetypes.BoolType{},
		"image_builder":                basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ServiceAccountsType{}

type ServiceAccountsType struct {
	basetypes.ObjectType
}

func (t ServiceAccountsType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceAccountsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceAccountsType) String() string {
	return "ServiceAccountsType"
}

func (t ServiceAccountsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachPolicyAttribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy is missing from object`)

		return nil, diags
	}

	attachPolicyVal, ok := attachPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy expected to be basetypes.StringValue, was: %T`, attachPolicyAttribute))
	}

	attachPolicyArns2Attribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns2 is missing from object`)

		return nil, diags
	}

	attachPolicyArns2Val, ok := attachPolicyArns2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns2 expected to be basetypes.SetValue, was: %T`, attachPolicyArns2Attribute))
	}

	attachRoleArnAttribute, ok := attributes["attach_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_role_arn is missing from object`)

		return nil, diags
	}

	attachRoleArnVal, ok := attachRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_role_arn expected to be basetypes.StringValue, was: %T`, attachRoleArnAttribute))
	}

	metadata3Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata3 is missing from object`)

		return nil, diags
	}

	metadata3Val, ok := metadata3Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata3 expected to be basetypes.SetValue, was: %T`, metadata3Attribute))
	}

	permissionsBoundaryAttribute, ok := attributes["permissions_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permissions_boundary is missing from object`)

		return nil, diags
	}

	permissionsBoundaryVal, ok := permissionsBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permissions_boundary expected to be basetypes.StringValue, was: %T`, permissionsBoundaryAttribute))
	}

	roleNameAttribute, ok := attributes["role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_name is missing from object`)

		return nil, diags
	}

	roleNameVal, ok := roleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_name expected to be basetypes.StringValue, was: %T`, roleNameAttribute))
	}

	roleOnlyAttribute, ok := attributes["role_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_only is missing from object`)

		return nil, diags
	}

	roleOnlyVal, ok := roleOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_only expected to be basetypes.BoolValue, was: %T`, roleOnlyAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.SetValue, was: %T`, statusAttribute))
	}

	tags3Attribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags3 is missing from object`)

		return nil, diags
	}

	tags3Val, ok := tags3Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags3 expected to be basetypes.MapValue, was: %T`, tags3Attribute))
	}

	wellKnownPolicies2Attribute, ok := attributes["well_known_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`well_known_policies2 is missing from object`)

		return nil, diags
	}

	wellKnownPolicies2Val, ok := wellKnownPolicies2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`well_known_policies2 expected to be basetypes.SetValue, was: %T`, wellKnownPolicies2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceAccountsValue{
		AttachPolicy:        attachPolicyVal,
		AttachPolicyArns2:   attachPolicyArns2Val,
		AttachRoleArn:       attachRoleArnVal,
		Metadata3:           metadata3Val,
		PermissionsBoundary: permissionsBoundaryVal,
		RoleName:            roleNameVal,
		RoleOnly:            roleOnlyVal,
		Status:              statusVal,
		Tags3:               tags3Val,
		WellKnownPolicies2:  wellKnownPolicies2Val,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewServiceAccountsValueNull() ServiceAccountsValue {
	return ServiceAccountsValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceAccountsValueUnknown() ServiceAccountsValue {
	return ServiceAccountsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceAccountsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceAccountsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceAccountsValue Attribute Value",
				"While creating a ServiceAccountsValue value, a missing attribute value was detected. "+
					"A ServiceAccountsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceAccountsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceAccountsValue Attribute Type",
				"While creating a ServiceAccountsValue value, an invalid attribute value was detected. "+
					"A ServiceAccountsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceAccountsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceAccountsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceAccountsValue Attribute Value",
				"While creating a ServiceAccountsValue value, an extra attribute value was detected. "+
					"A ServiceAccountsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceAccountsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceAccountsValueUnknown(), diags
	}

	attachPolicyAttribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	attachPolicyVal, ok := attachPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy expected to be basetypes.StringValue, was: %T`, attachPolicyAttribute))
	}

	attachPolicyArns2Attribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns2 is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	attachPolicyArns2Val, ok := attachPolicyArns2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns2 expected to be basetypes.SetValue, was: %T`, attachPolicyArns2Attribute))
	}

	attachRoleArnAttribute, ok := attributes["attach_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_role_arn is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	attachRoleArnVal, ok := attachRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_role_arn expected to be basetypes.StringValue, was: %T`, attachRoleArnAttribute))
	}

	metadata3Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata3 is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	metadata3Val, ok := metadata3Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata3 expected to be basetypes.SetValue, was: %T`, metadata3Attribute))
	}

	permissionsBoundaryAttribute, ok := attributes["permissions_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permissions_boundary is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	permissionsBoundaryVal, ok := permissionsBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permissions_boundary expected to be basetypes.StringValue, was: %T`, permissionsBoundaryAttribute))
	}

	roleNameAttribute, ok := attributes["role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_name is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	roleNameVal, ok := roleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_name expected to be basetypes.StringValue, was: %T`, roleNameAttribute))
	}

	roleOnlyAttribute, ok := attributes["role_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_only is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	roleOnlyVal, ok := roleOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_only expected to be basetypes.BoolValue, was: %T`, roleOnlyAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.SetValue, was: %T`, statusAttribute))
	}

	tags3Attribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags3 is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	tags3Val, ok := tags3Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags3 expected to be basetypes.MapValue, was: %T`, tags3Attribute))
	}

	wellKnownPolicies2Attribute, ok := attributes["well_known_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`well_known_policies2 is missing from object`)

		return NewServiceAccountsValueUnknown(), diags
	}

	wellKnownPolicies2Val, ok := wellKnownPolicies2Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`well_known_policies2 expected to be basetypes.SetValue, was: %T`, wellKnownPolicies2Attribute))
	}

	if diags.HasError() {
		return NewServiceAccountsValueUnknown(), diags
	}

	return ServiceAccountsValue{
		AttachPolicy:        attachPolicyVal,
		AttachPolicyArns2:   attachPolicyArns2Val,
		AttachRoleArn:       attachRoleArnVal,
		Metadata3:           metadata3Val,
		PermissionsBoundary: permissionsBoundaryVal,
		RoleName:            roleNameVal,
		RoleOnly:            roleOnlyVal,
		Status:              statusVal,
		Tags3:               tags3Val,
		WellKnownPolicies2:  wellKnownPolicies2Val,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewServiceAccountsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceAccountsValue {
	object, diags := NewServiceAccountsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceAccountsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceAccountsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceAccountsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceAccountsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceAccountsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceAccountsValueMust(ServiceAccountsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceAccountsType) ValueType(ctx context.Context) attr.Value {
	return ServiceAccountsValue{}
}

var _ basetypes.ObjectValuable = ServiceAccountsValue{}

type ServiceAccountsValue struct {
	AttachPolicy        basetypes.StringValue `tfsdk:"attach_policy"`
	AttachPolicyArns2   basetypes.SetValue    `tfsdk:"attach_policy_arns"`
	AttachRoleArn       basetypes.StringValue `tfsdk:"attach_role_arn"`
	Metadata3           basetypes.SetValue    `tfsdk:"metadata"`
	PermissionsBoundary basetypes.StringValue `tfsdk:"permissions_boundary"`
	RoleName            basetypes.StringValue `tfsdk:"role_name"`
	RoleOnly            basetypes.BoolValue   `tfsdk:"role_only"`
	Status              basetypes.SetValue    `tfsdk:"status"`
	Tags3               basetypes.MapValue    `tfsdk:"tags"`
	WellKnownPolicies2  basetypes.SetValue    `tfsdk:"well_known_policies"`
	state               attr.ValueState
}

func (v ServiceAccountsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["attach_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["attach_policy_arns"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["attach_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.SetType{
		ElemType: Metadata3Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["permissions_boundary"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.SetType{
		ElemType: StatusValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["well_known_policies"] = basetypes.SetType{
		ElemType: WellKnownPolicies2Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AttachPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy"] = val

		val, err = v.AttachPolicyArns2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_arns"] = val

		val, err = v.AttachRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_role_arn"] = val

		val, err = v.Metadata3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.PermissionsBoundary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permissions_boundary"] = val

		val, err = v.RoleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_name"] = val

		val, err = v.RoleOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_only"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Tags3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.WellKnownPolicies2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["well_known_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceAccountsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceAccountsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceAccountsValue) String() string {
	return "ServiceAccountsValue"
}

func (v ServiceAccountsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	metadata3 := types.SetValueMust(
		Metadata3Type{
			basetypes.ObjectType{
				AttrTypes: Metadata3Value{}.AttributeTypes(ctx),
			},
		},
		v.Metadata3.Elements(),
	)

	if v.Metadata3.IsNull() {
		metadata3 = types.SetNull(
			Metadata3Type{
				basetypes.ObjectType{
					AttrTypes: Metadata3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata3.IsUnknown() {
		metadata3 = types.SetUnknown(
			Metadata3Type{
				basetypes.ObjectType{
					AttrTypes: Metadata3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	status := types.SetValueMust(
		StatusType{
			basetypes.ObjectType{
				AttrTypes: StatusValue{}.AttributeTypes(ctx),
			},
		},
		v.Status.Elements(),
	)

	if v.Status.IsNull() {
		status = types.SetNull(
			StatusType{
				basetypes.ObjectType{
					AttrTypes: StatusValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Status.IsUnknown() {
		status = types.SetUnknown(
			StatusType{
				basetypes.ObjectType{
					AttrTypes: StatusValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	wellKnownPolicies2 := types.SetValueMust(
		WellKnownPolicies2Type{
			basetypes.ObjectType{
				AttrTypes: WellKnownPolicies2Value{}.AttributeTypes(ctx),
			},
		},
		v.WellKnownPolicies2.Elements(),
	)

	if v.WellKnownPolicies2.IsNull() {
		wellKnownPolicies2 = types.SetNull(
			WellKnownPolicies2Type{
				basetypes.ObjectType{
					AttrTypes: WellKnownPolicies2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.WellKnownPolicies2.IsUnknown() {
		wellKnownPolicies2 = types.SetUnknown(
			WellKnownPolicies2Type{
				basetypes.ObjectType{
					AttrTypes: WellKnownPolicies2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var attachPolicyArns2Val basetypes.SetValue
	switch {
	case v.AttachPolicyArns2.IsUnknown():
		attachPolicyArns2Val = types.SetUnknown(types.StringType)
	case v.AttachPolicyArns2.IsNull():
		attachPolicyArns2Val = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachPolicyArns2Val, d = types.SetValue(types.StringType, v.AttachPolicyArns2.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_policy": basetypes.StringType{},
			"attach_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"attach_role_arn": basetypes.StringType{},
			"metadata": basetypes.SetType{
				ElemType: Metadata3Value{}.Type(ctx),
			},
			"permissions_boundary": basetypes.StringType{},
			"role_name":            basetypes.StringType{},
			"role_only":            basetypes.BoolType{},
			"status": basetypes.SetType{
				ElemType: StatusValue{}.Type(ctx),
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"well_known_policies": basetypes.SetType{
				ElemType: WellKnownPolicies2Value{}.Type(ctx),
			},
		}), diags
	}

	var tags3Val basetypes.MapValue
	switch {
	case v.Tags3.IsUnknown():
		tags3Val = types.MapUnknown(types.StringType)
	case v.Tags3.IsNull():
		tags3Val = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tags3Val, d = types.MapValue(types.StringType, v.Tags3.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_policy": basetypes.StringType{},
			"attach_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"attach_role_arn": basetypes.StringType{},
			"metadata": basetypes.SetType{
				ElemType: Metadata3Value{}.Type(ctx),
			},
			"permissions_boundary": basetypes.StringType{},
			"role_name":            basetypes.StringType{},
			"role_only":            basetypes.BoolType{},
			"status": basetypes.SetType{
				ElemType: StatusValue{}.Type(ctx),
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"well_known_policies": basetypes.SetType{
				ElemType: WellKnownPolicies2Value{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_policy": basetypes.StringType{},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_role_arn": basetypes.StringType{},
		"metadata": basetypes.SetType{
			ElemType: Metadata3Value{}.Type(ctx),
		},
		"permissions_boundary": basetypes.StringType{},
		"role_name":            basetypes.StringType{},
		"role_only":            basetypes.BoolType{},
		"status": basetypes.SetType{
			ElemType: StatusValue{}.Type(ctx),
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"well_known_policies": basetypes.SetType{
			ElemType: WellKnownPolicies2Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_policy":        v.AttachPolicy,
			"attach_policy_arns":   attachPolicyArns2Val,
			"attach_role_arn":      v.AttachRoleArn,
			"metadata":             metadata3,
			"permissions_boundary": v.PermissionsBoundary,
			"role_name":            v.RoleName,
			"role_only":            v.RoleOnly,
			"status":               status,
			"tags":                 tags3Val,
			"well_known_policies":  wellKnownPolicies2,
		})

	return objVal, diags
}

func (v ServiceAccountsValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceAccountsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachPolicy.Equal(other.AttachPolicy) {
		return false
	}

	if !v.AttachPolicyArns2.Equal(other.AttachPolicyArns2) {
		return false
	}

	if !v.AttachRoleArn.Equal(other.AttachRoleArn) {
		return false
	}

	if !v.Metadata3.Equal(other.Metadata3) {
		return false
	}

	if !v.PermissionsBoundary.Equal(other.PermissionsBoundary) {
		return false
	}

	if !v.RoleName.Equal(other.RoleName) {
		return false
	}

	if !v.RoleOnly.Equal(other.RoleOnly) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Tags3.Equal(other.Tags3) {
		return false
	}

	if !v.WellKnownPolicies2.Equal(other.WellKnownPolicies2) {
		return false
	}

	return true
}

func (v ServiceAccountsValue) Type(ctx context.Context) attr.Type {
	return ServiceAccountsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceAccountsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_policy": basetypes.StringType{},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_role_arn": basetypes.StringType{},
		"metadata": basetypes.SetType{
			ElemType: Metadata3Value{}.Type(ctx),
		},
		"permissions_boundary": basetypes.StringType{},
		"role_name":            basetypes.StringType{},
		"role_only":            basetypes.BoolType{},
		"status": basetypes.SetType{
			ElemType: StatusValue{}.Type(ctx),
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"well_known_policies": basetypes.SetType{
			ElemType: WellKnownPolicies2Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Metadata3Type{}

type Metadata3Type struct {
	basetypes.ObjectType
}

func (t Metadata3Type) Equal(o attr.Type) bool {
	other, ok := o.(Metadata3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Metadata3Type) String() string {
	return "Metadata3Type"
}

func (t Metadata3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Metadata3Value{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadata3ValueNull() Metadata3Value {
	return Metadata3Value{
		state: attr.ValueStateNull,
	}
}

func NewMetadata3ValueUnknown() Metadata3Value {
	return Metadata3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadata3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Metadata3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Metadata3Value Attribute Value",
				"While creating a Metadata3Value value, a missing attribute value was detected. "+
					"A Metadata3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Metadata3Value Attribute Type",
				"While creating a Metadata3Value value, an invalid attribute value was detected. "+
					"A Metadata3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Metadata3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Metadata3Value Attribute Value",
				"While creating a Metadata3Value value, an extra attribute value was detected. "+
					"A Metadata3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Metadata3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadata3ValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadata3ValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadata3ValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadata3ValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadata3ValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadata3ValueUnknown(), diags
	}

	return Metadata3Value{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadata3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Metadata3Value {
	object, diags := NewMetadata3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadata3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Metadata3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadata3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadata3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadata3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadata3ValueMust(Metadata3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Metadata3Type) ValueType(ctx context.Context) attr.Value {
	return Metadata3Value{}
}

var _ basetypes.ObjectValuable = Metadata3Value{}

type Metadata3Value struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v Metadata3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Metadata3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Metadata3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Metadata3Value) String() string {
	return "Metadata3Value"
}

func (v Metadata3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v Metadata3Value) Equal(o attr.Value) bool {
	other, ok := o.(Metadata3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v Metadata3Value) Type(ctx context.Context) attr.Type {
	return Metadata3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Metadata3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	roleArnAttribute, ok := attributes["role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_arn is missing from object`)

		return nil, diags
	}

	roleArnVal, ok := roleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_arn expected to be basetypes.StringValue, was: %T`, roleArnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		RoleArn: roleArnVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	roleArnAttribute, ok := attributes["role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_arn is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	roleArnVal, ok := roleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_arn expected to be basetypes.StringValue, was: %T`, roleArnAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		RoleArn: roleArnVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	RoleArn basetypes.StringValue `tfsdk:"role_arn"`
	state   attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["role_arn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.RoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_arn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"role_arn": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"role_arn": v.RoleArn,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RoleArn.Equal(other.RoleArn) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"role_arn": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = WellKnownPolicies2Type{}

type WellKnownPolicies2Type struct {
	basetypes.ObjectType
}

func (t WellKnownPolicies2Type) Equal(o attr.Type) bool {
	other, ok := o.(WellKnownPolicies2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WellKnownPolicies2Type) String() string {
	return "WellKnownPolicies2Type"
}

func (t WellKnownPolicies2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	awsLoadBalancerControllerAttribute, ok := attributes["aws_load_balancer_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_load_balancer_controller is missing from object`)

		return nil, diags
	}

	awsLoadBalancerControllerVal, ok := awsLoadBalancerControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_load_balancer_controller expected to be basetypes.BoolValue, was: %T`, awsLoadBalancerControllerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	ebsCsiControllerAttribute, ok := attributes["ebs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_csi_controller is missing from object`)

		return nil, diags
	}

	ebsCsiControllerVal, ok := ebsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_csi_controller expected to be basetypes.BoolValue, was: %T`, ebsCsiControllerAttribute))
	}

	efsCsiControllerAttribute, ok := attributes["efs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs_csi_controller is missing from object`)

		return nil, diags
	}

	efsCsiControllerVal, ok := efsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs_csi_controller expected to be basetypes.BoolValue, was: %T`, efsCsiControllerAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WellKnownPolicies2Value{
		AutoScaler:                autoScalerVal,
		AwsLoadBalancerController: awsLoadBalancerControllerVal,
		CertManager:               certManagerVal,
		EbsCsiController:          ebsCsiControllerVal,
		EfsCsiController:          efsCsiControllerVal,
		ExternalDns:               externalDnsVal,
		ImageBuilder:              imageBuilderVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWellKnownPolicies2ValueNull() WellKnownPolicies2Value {
	return WellKnownPolicies2Value{
		state: attr.ValueStateNull,
	}
}

func NewWellKnownPolicies2ValueUnknown() WellKnownPolicies2Value {
	return WellKnownPolicies2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewWellKnownPolicies2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WellKnownPolicies2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WellKnownPolicies2Value Attribute Value",
				"While creating a WellKnownPolicies2Value value, a missing attribute value was detected. "+
					"A WellKnownPolicies2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WellKnownPolicies2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WellKnownPolicies2Value Attribute Type",
				"While creating a WellKnownPolicies2Value value, an invalid attribute value was detected. "+
					"A WellKnownPolicies2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WellKnownPolicies2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WellKnownPolicies2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WellKnownPolicies2Value Attribute Value",
				"While creating a WellKnownPolicies2Value value, an extra attribute value was detected. "+
					"A WellKnownPolicies2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WellKnownPolicies2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	awsLoadBalancerControllerAttribute, ok := attributes["aws_load_balancer_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aws_load_balancer_controller is missing from object`)

		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	awsLoadBalancerControllerVal, ok := awsLoadBalancerControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aws_load_balancer_controller expected to be basetypes.BoolValue, was: %T`, awsLoadBalancerControllerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	ebsCsiControllerAttribute, ok := attributes["ebs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_csi_controller is missing from object`)

		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	ebsCsiControllerVal, ok := ebsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_csi_controller expected to be basetypes.BoolValue, was: %T`, ebsCsiControllerAttribute))
	}

	efsCsiControllerAttribute, ok := attributes["efs_csi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs_csi_controller is missing from object`)

		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	efsCsiControllerVal, ok := efsCsiControllerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs_csi_controller expected to be basetypes.BoolValue, was: %T`, efsCsiControllerAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	if diags.HasError() {
		return NewWellKnownPolicies2ValueUnknown(), diags
	}

	return WellKnownPolicies2Value{
		AutoScaler:                autoScalerVal,
		AwsLoadBalancerController: awsLoadBalancerControllerVal,
		CertManager:               certManagerVal,
		EbsCsiController:          ebsCsiControllerVal,
		EfsCsiController:          efsCsiControllerVal,
		ExternalDns:               externalDnsVal,
		ImageBuilder:              imageBuilderVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWellKnownPolicies2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WellKnownPolicies2Value {
	object, diags := NewWellKnownPolicies2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWellKnownPolicies2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WellKnownPolicies2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWellKnownPolicies2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWellKnownPolicies2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWellKnownPolicies2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWellKnownPolicies2ValueMust(WellKnownPolicies2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t WellKnownPolicies2Type) ValueType(ctx context.Context) attr.Value {
	return WellKnownPolicies2Value{}
}

var _ basetypes.ObjectValuable = WellKnownPolicies2Value{}

type WellKnownPolicies2Value struct {
	AutoScaler                basetypes.BoolValue `tfsdk:"auto_scaler"`
	AwsLoadBalancerController basetypes.BoolValue `tfsdk:"aws_load_balancer_controller"`
	CertManager               basetypes.BoolValue `tfsdk:"cert_manager"`
	EbsCsiController          basetypes.BoolValue `tfsdk:"ebs_csi_controller"`
	EfsCsiController          basetypes.BoolValue `tfsdk:"efs_csi_controller"`
	ExternalDns               basetypes.BoolValue `tfsdk:"external_dns"`
	ImageBuilder              basetypes.BoolValue `tfsdk:"image_builder"`
	state                     attr.ValueState
}

func (v WellKnownPolicies2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aws_load_balancer_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs_csi_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs_csi_controller"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.AwsLoadBalancerController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aws_load_balancer_controller"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.EbsCsiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs_csi_controller"] = val

		val, err = v.EfsCsiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs_csi_controller"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WellKnownPolicies2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WellKnownPolicies2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WellKnownPolicies2Value) String() string {
	return "WellKnownPolicies2Value"
}

func (v WellKnownPolicies2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auto_scaler":                  basetypes.BoolType{},
		"aws_load_balancer_controller": basetypes.BoolType{},
		"cert_manager":                 basetypes.BoolType{},
		"ebs_csi_controller":           basetypes.BoolType{},
		"efs_csi_controller":           basetypes.BoolType{},
		"external_dns":                 basetypes.BoolType{},
		"image_builder":                basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_scaler":                  v.AutoScaler,
			"aws_load_balancer_controller": v.AwsLoadBalancerController,
			"cert_manager":                 v.CertManager,
			"ebs_csi_controller":           v.EbsCsiController,
			"efs_csi_controller":           v.EfsCsiController,
			"external_dns":                 v.ExternalDns,
			"image_builder":                v.ImageBuilder,
		})

	return objVal, diags
}

func (v WellKnownPolicies2Value) Equal(o attr.Value) bool {
	other, ok := o.(WellKnownPolicies2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.AwsLoadBalancerController.Equal(other.AwsLoadBalancerController) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.EbsCsiController.Equal(other.EbsCsiController) {
		return false
	}

	if !v.EfsCsiController.Equal(other.EfsCsiController) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	return true
}

func (v WellKnownPolicies2Value) Type(ctx context.Context) attr.Type {
	return WellKnownPolicies2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WellKnownPolicies2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_scaler":                  basetypes.BoolType{},
		"aws_load_balancer_controller": basetypes.BoolType{},
		"cert_manager":                 basetypes.BoolType{},
		"ebs_csi_controller":           basetypes.BoolType{},
		"efs_csi_controller":           basetypes.BoolType{},
		"external_dns":                 basetypes.BoolType{},
		"image_builder":                basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IdentityMappingsType{}

type IdentityMappingsType struct {
	basetypes.ObjectType
}

func (t IdentityMappingsType) Equal(o attr.Type) bool {
	other, ok := o.(IdentityMappingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdentityMappingsType) String() string {
	return "IdentityMappingsType"
}

func (t IdentityMappingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountsAttribute, ok := attributes["accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accounts is missing from object`)

		return nil, diags
	}

	accountsVal, ok := accountsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accounts expected to be basetypes.SetValue, was: %T`, accountsAttribute))
	}

	arnsAttribute, ok := attributes["arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arns is missing from object`)

		return nil, diags
	}

	arnsVal, ok := arnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arns expected to be basetypes.SetValue, was: %T`, arnsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdentityMappingsValue{
		Accounts: accountsVal,
		Arns:     arnsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIdentityMappingsValueNull() IdentityMappingsValue {
	return IdentityMappingsValue{
		state: attr.ValueStateNull,
	}
}

func NewIdentityMappingsValueUnknown() IdentityMappingsValue {
	return IdentityMappingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdentityMappingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdentityMappingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdentityMappingsValue Attribute Value",
				"While creating a IdentityMappingsValue value, a missing attribute value was detected. "+
					"A IdentityMappingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdentityMappingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdentityMappingsValue Attribute Type",
				"While creating a IdentityMappingsValue value, an invalid attribute value was detected. "+
					"A IdentityMappingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdentityMappingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdentityMappingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdentityMappingsValue Attribute Value",
				"While creating a IdentityMappingsValue value, an extra attribute value was detected. "+
					"A IdentityMappingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdentityMappingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdentityMappingsValueUnknown(), diags
	}

	accountsAttribute, ok := attributes["accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accounts is missing from object`)

		return NewIdentityMappingsValueUnknown(), diags
	}

	accountsVal, ok := accountsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accounts expected to be basetypes.SetValue, was: %T`, accountsAttribute))
	}

	arnsAttribute, ok := attributes["arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arns is missing from object`)

		return NewIdentityMappingsValueUnknown(), diags
	}

	arnsVal, ok := arnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arns expected to be basetypes.SetValue, was: %T`, arnsAttribute))
	}

	if diags.HasError() {
		return NewIdentityMappingsValueUnknown(), diags
	}

	return IdentityMappingsValue{
		Accounts: accountsVal,
		Arns:     arnsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIdentityMappingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdentityMappingsValue {
	object, diags := NewIdentityMappingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdentityMappingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdentityMappingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdentityMappingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdentityMappingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdentityMappingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdentityMappingsValueMust(IdentityMappingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdentityMappingsType) ValueType(ctx context.Context) attr.Value {
	return IdentityMappingsValue{}
}

var _ basetypes.ObjectValuable = IdentityMappingsValue{}

type IdentityMappingsValue struct {
	Accounts basetypes.SetValue `tfsdk:"accounts"`
	Arns     basetypes.SetValue `tfsdk:"arns"`
	state    attr.ValueState
}

func (v IdentityMappingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["accounts"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["arns"] = basetypes.SetType{
		ElemType: ArnsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Accounts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accounts"] = val

		val, err = v.Arns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arns"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdentityMappingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdentityMappingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdentityMappingsValue) String() string {
	return "IdentityMappingsValue"
}

func (v IdentityMappingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	arns := types.SetValueMust(
		ArnsType{
			basetypes.ObjectType{
				AttrTypes: ArnsValue{}.AttributeTypes(ctx),
			},
		},
		v.Arns.Elements(),
	)

	if v.Arns.IsNull() {
		arns = types.SetNull(
			ArnsType{
				basetypes.ObjectType{
					AttrTypes: ArnsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Arns.IsUnknown() {
		arns = types.SetUnknown(
			ArnsType{
				basetypes.ObjectType{
					AttrTypes: ArnsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var accountsVal basetypes.SetValue
	switch {
	case v.Accounts.IsUnknown():
		accountsVal = types.SetUnknown(types.StringType)
	case v.Accounts.IsNull():
		accountsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		accountsVal, d = types.SetValue(types.StringType, v.Accounts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accounts": basetypes.SetType{
				ElemType: types.StringType,
			},
			"arns": basetypes.SetType{
				ElemType: ArnsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"accounts": basetypes.SetType{
			ElemType: types.StringType,
		},
		"arns": basetypes.SetType{
			ElemType: ArnsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"accounts": accountsVal,
			"arns":     arns,
		})

	return objVal, diags
}

func (v IdentityMappingsValue) Equal(o attr.Value) bool {
	other, ok := o.(IdentityMappingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Accounts.Equal(other.Accounts) {
		return false
	}

	if !v.Arns.Equal(other.Arns) {
		return false
	}

	return true
}

func (v IdentityMappingsValue) Type(ctx context.Context) attr.Type {
	return IdentityMappingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdentityMappingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"accounts": basetypes.SetType{
			ElemType: types.StringType,
		},
		"arns": basetypes.SetType{
			ElemType: ArnsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ArnsType{}

type ArnsType struct {
	basetypes.ObjectType
}

func (t ArnsType) Equal(o attr.Type) bool {
	other, ok := o.(ArnsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ArnsType) String() string {
	return "ArnsType"
}

func (t ArnsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arnAttribute, ok := attributes["arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arn is missing from object`)

		return nil, diags
	}

	arnVal, ok := arnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arn expected to be basetypes.StringValue, was: %T`, arnAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.SetValue, was: %T`, groupAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ArnsValue{
		Arn:      arnVal,
		Group:    groupVal,
		Username: usernameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewArnsValueNull() ArnsValue {
	return ArnsValue{
		state: attr.ValueStateNull,
	}
}

func NewArnsValueUnknown() ArnsValue {
	return ArnsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewArnsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ArnsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ArnsValue Attribute Value",
				"While creating a ArnsValue value, a missing attribute value was detected. "+
					"A ArnsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArnsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ArnsValue Attribute Type",
				"While creating a ArnsValue value, an invalid attribute value was detected. "+
					"A ArnsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArnsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ArnsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ArnsValue Attribute Value",
				"While creating a ArnsValue value, an extra attribute value was detected. "+
					"A ArnsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ArnsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewArnsValueUnknown(), diags
	}

	arnAttribute, ok := attributes["arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arn is missing from object`)

		return NewArnsValueUnknown(), diags
	}

	arnVal, ok := arnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arn expected to be basetypes.StringValue, was: %T`, arnAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewArnsValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.SetValue, was: %T`, groupAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewArnsValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewArnsValueUnknown(), diags
	}

	return ArnsValue{
		Arn:      arnVal,
		Group:    groupVal,
		Username: usernameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewArnsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ArnsValue {
	object, diags := NewArnsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewArnsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ArnsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewArnsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewArnsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewArnsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewArnsValueMust(ArnsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ArnsType) ValueType(ctx context.Context) attr.Value {
	return ArnsValue{}
}

var _ basetypes.ObjectValuable = ArnsValue{}

type ArnsValue struct {
	Arn      basetypes.StringValue `tfsdk:"arn"`
	Group    basetypes.SetValue    `tfsdk:"group"`
	Username basetypes.StringValue `tfsdk:"username"`
	state    attr.ValueState
}

func (v ArnsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["group"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Arn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arn"] = val

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ArnsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ArnsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ArnsValue) String() string {
	return "ArnsValue"
}

func (v ArnsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var groupVal basetypes.SetValue
	switch {
	case v.Group.IsUnknown():
		groupVal = types.SetUnknown(types.StringType)
	case v.Group.IsNull():
		groupVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		groupVal, d = types.SetValue(types.StringType, v.Group.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arn": basetypes.StringType{},
			"group": basetypes.SetType{
				ElemType: types.StringType,
			},
			"username": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"arn": basetypes.StringType{},
		"group": basetypes.SetType{
			ElemType: types.StringType,
		},
		"username": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arn":      v.Arn,
			"group":    groupVal,
			"username": v.Username,
		})

	return objVal, diags
}

func (v ArnsValue) Equal(o attr.Value) bool {
	other, ok := o.(ArnsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Arn.Equal(other.Arn) {
		return false
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v ArnsValue) Type(ctx context.Context) attr.Type {
	return ArnsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ArnsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arn": basetypes.StringType{},
		"group": basetypes.SetType{
			ElemType: types.StringType,
		},
		"username": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IdentityProvidersType{}

type IdentityProvidersType struct {
	basetypes.ObjectType
}

func (t IdentityProvidersType) Equal(o attr.Type) bool {
	other, ok := o.(IdentityProvidersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdentityProvidersType) String() string {
	return "IdentityProvidersType"
}

func (t IdentityProvidersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdentityProvidersValue{
		IdentityProvidersType: typeVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIdentityProvidersValueNull() IdentityProvidersValue {
	return IdentityProvidersValue{
		state: attr.ValueStateNull,
	}
}

func NewIdentityProvidersValueUnknown() IdentityProvidersValue {
	return IdentityProvidersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdentityProvidersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdentityProvidersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdentityProvidersValue Attribute Value",
				"While creating a IdentityProvidersValue value, a missing attribute value was detected. "+
					"A IdentityProvidersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdentityProvidersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdentityProvidersValue Attribute Type",
				"While creating a IdentityProvidersValue value, an invalid attribute value was detected. "+
					"A IdentityProvidersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdentityProvidersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdentityProvidersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdentityProvidersValue Attribute Value",
				"While creating a IdentityProvidersValue value, an extra attribute value was detected. "+
					"A IdentityProvidersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdentityProvidersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdentityProvidersValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIdentityProvidersValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewIdentityProvidersValueUnknown(), diags
	}

	return IdentityProvidersValue{
		IdentityProvidersType: typeVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIdentityProvidersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdentityProvidersValue {
	object, diags := NewIdentityProvidersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdentityProvidersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdentityProvidersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdentityProvidersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdentityProvidersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdentityProvidersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdentityProvidersValueMust(IdentityProvidersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdentityProvidersType) ValueType(ctx context.Context) attr.Value {
	return IdentityProvidersValue{}
}

var _ basetypes.ObjectValuable = IdentityProvidersValue{}

type IdentityProvidersValue struct {
	IdentityProvidersType basetypes.StringValue `tfsdk:"type"`
	state                 attr.ValueState
}

func (v IdentityProvidersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.IdentityProvidersType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdentityProvidersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdentityProvidersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdentityProvidersValue) String() string {
	return "IdentityProvidersValue"
}

func (v IdentityProvidersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type": v.IdentityProvidersType,
		})

	return objVal, diags
}

func (v IdentityProvidersValue) Equal(o attr.Value) bool {
	other, ok := o.(IdentityProvidersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IdentityProvidersType.Equal(other.IdentityProvidersType) {
		return false
	}

	return true
}

func (v IdentityProvidersValue) Type(ctx context.Context) attr.Type {
	return IdentityProvidersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdentityProvidersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = KubernetesNetworkConfigType{}

type KubernetesNetworkConfigType struct {
	basetypes.ObjectType
}

func (t KubernetesNetworkConfigType) Equal(o attr.Type) bool {
	other, ok := o.(KubernetesNetworkConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KubernetesNetworkConfigType) String() string {
	return "KubernetesNetworkConfigType"
}

func (t KubernetesNetworkConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipFamilyAttribute, ok := attributes["ip_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_family is missing from object`)

		return nil, diags
	}

	ipFamilyVal, ok := ipFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_family expected to be basetypes.StringValue, was: %T`, ipFamilyAttribute))
	}

	serviceIpv4CidrAttribute, ok := attributes["service_ipv4_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_ipv4_cidr is missing from object`)

		return nil, diags
	}

	serviceIpv4CidrVal, ok := serviceIpv4CidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_ipv4_cidr expected to be basetypes.StringValue, was: %T`, serviceIpv4CidrAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KubernetesNetworkConfigValue{
		IpFamily:        ipFamilyVal,
		ServiceIpv4Cidr: serviceIpv4CidrVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewKubernetesNetworkConfigValueNull() KubernetesNetworkConfigValue {
	return KubernetesNetworkConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewKubernetesNetworkConfigValueUnknown() KubernetesNetworkConfigValue {
	return KubernetesNetworkConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKubernetesNetworkConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KubernetesNetworkConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KubernetesNetworkConfigValue Attribute Value",
				"While creating a KubernetesNetworkConfigValue value, a missing attribute value was detected. "+
					"A KubernetesNetworkConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KubernetesNetworkConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KubernetesNetworkConfigValue Attribute Type",
				"While creating a KubernetesNetworkConfigValue value, an invalid attribute value was detected. "+
					"A KubernetesNetworkConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KubernetesNetworkConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KubernetesNetworkConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KubernetesNetworkConfigValue Attribute Value",
				"While creating a KubernetesNetworkConfigValue value, an extra attribute value was detected. "+
					"A KubernetesNetworkConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KubernetesNetworkConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKubernetesNetworkConfigValueUnknown(), diags
	}

	ipFamilyAttribute, ok := attributes["ip_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_family is missing from object`)

		return NewKubernetesNetworkConfigValueUnknown(), diags
	}

	ipFamilyVal, ok := ipFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_family expected to be basetypes.StringValue, was: %T`, ipFamilyAttribute))
	}

	serviceIpv4CidrAttribute, ok := attributes["service_ipv4_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_ipv4_cidr is missing from object`)

		return NewKubernetesNetworkConfigValueUnknown(), diags
	}

	serviceIpv4CidrVal, ok := serviceIpv4CidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_ipv4_cidr expected to be basetypes.StringValue, was: %T`, serviceIpv4CidrAttribute))
	}

	if diags.HasError() {
		return NewKubernetesNetworkConfigValueUnknown(), diags
	}

	return KubernetesNetworkConfigValue{
		IpFamily:        ipFamilyVal,
		ServiceIpv4Cidr: serviceIpv4CidrVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewKubernetesNetworkConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KubernetesNetworkConfigValue {
	object, diags := NewKubernetesNetworkConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKubernetesNetworkConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KubernetesNetworkConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKubernetesNetworkConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKubernetesNetworkConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKubernetesNetworkConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKubernetesNetworkConfigValueMust(KubernetesNetworkConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KubernetesNetworkConfigType) ValueType(ctx context.Context) attr.Value {
	return KubernetesNetworkConfigValue{}
}

var _ basetypes.ObjectValuable = KubernetesNetworkConfigValue{}

type KubernetesNetworkConfigValue struct {
	IpFamily        basetypes.StringValue `tfsdk:"ip_family"`
	ServiceIpv4Cidr basetypes.StringValue `tfsdk:"service_ipv4_cidr"`
	state           attr.ValueState
}

func (v KubernetesNetworkConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_ipv4_cidr"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_family"] = val

		val, err = v.ServiceIpv4Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_ipv4_cidr"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KubernetesNetworkConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KubernetesNetworkConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KubernetesNetworkConfigValue) String() string {
	return "KubernetesNetworkConfigValue"
}

func (v KubernetesNetworkConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_family":         basetypes.StringType{},
		"service_ipv4_cidr": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_family":         v.IpFamily,
			"service_ipv4_cidr": v.ServiceIpv4Cidr,
		})

	return objVal, diags
}

func (v KubernetesNetworkConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(KubernetesNetworkConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpFamily.Equal(other.IpFamily) {
		return false
	}

	if !v.ServiceIpv4Cidr.Equal(other.ServiceIpv4Cidr) {
		return false
	}

	return true
}

func (v KubernetesNetworkConfigValue) Type(ctx context.Context) attr.Type {
	return KubernetesNetworkConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KubernetesNetworkConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_family":         basetypes.StringType{},
		"service_ipv4_cidr": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ManagedNodegroupsType{}

type ManagedNodegroupsType struct {
	basetypes.ObjectType
}

func (t ManagedNodegroupsType) Equal(o attr.Type) bool {
	other, ok := o.(ManagedNodegroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ManagedNodegroupsType) String() string {
	return "ManagedNodegroupsType"
}

func (t ManagedNodegroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return nil, diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return nil, diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	asgSuspendProcessesAttribute, ok := attributes["asg_suspend_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_suspend_processes is missing from object`)

		return nil, diags
	}

	asgSuspendProcessesVal, ok := asgSuspendProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_suspend_processes expected to be basetypes.ListValue, was: %T`, asgSuspendProcessesAttribute))
	}

	availabilityZonesAttribute, ok := attributes["availability_zones"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones is missing from object`)

		return nil, diags
	}

	availabilityZonesVal, ok := availabilityZonesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones expected to be basetypes.ListValue, was: %T`, availabilityZonesAttribute))
	}

	bottleRocket4Attribute, ok := attributes["bottle_rocket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bottle_rocket4 is missing from object`)

		return nil, diags
	}

	bottleRocket4Val, ok := bottleRocket4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bottle_rocket4 expected to be basetypes.ListValue, was: %T`, bottleRocket4Attribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return nil, diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return nil, diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return nil, diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	ebsOptimizedAttribute, ok := attributes["ebs_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_optimized is missing from object`)

		return nil, diags
	}

	ebsOptimizedVal, ok := ebsOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_optimized expected to be basetypes.BoolValue, was: %T`, ebsOptimizedAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return nil, diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	enableDetailedMonitoringAttribute, ok := attributes["enable_detailed_monitoring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_detailed_monitoring is missing from object`)

		return nil, diags
	}

	enableDetailedMonitoringVal, ok := enableDetailedMonitoringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_detailed_monitoring expected to be basetypes.BoolValue, was: %T`, enableDetailedMonitoringAttribute))
	}

	iam4Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam4 is missing from object`)

		return nil, diags
	}

	iam4Val, ok := iam4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam4 expected to be basetypes.ListValue, was: %T`, iam4Attribute))
	}

	instanceNameAttribute, ok := attributes["instance_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_name is missing from object`)

		return nil, diags
	}

	instanceNameVal, ok := instanceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_name expected to be basetypes.StringValue, was: %T`, instanceNameAttribute))
	}

	instancePrefixAttribute, ok := attributes["instance_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_prefix is missing from object`)

		return nil, diags
	}

	instancePrefixVal, ok := instancePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_prefix expected to be basetypes.StringValue, was: %T`, instancePrefixAttribute))
	}

	instanceSelector4Attribute, ok := attributes["instance_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_selector4 is missing from object`)

		return nil, diags
	}

	instanceSelector4Val, ok := instanceSelector4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_selector4 expected to be basetypes.ListValue, was: %T`, instanceSelector4Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return nil, diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	instanceTypesAttribute, ok := attributes["instance_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_types is missing from object`)

		return nil, diags
	}

	instanceTypesVal, ok := instanceTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_types expected to be basetypes.ListValue, was: %T`, instanceTypesAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	launchTemplate4Attribute, ok := attributes["launch_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`launch_template4 is missing from object`)

		return nil, diags
	}

	launchTemplate4Val, ok := launchTemplate4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`launch_template4 expected to be basetypes.ListValue, was: %T`, launchTemplate4Attribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return nil, diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeRepairConfig4Attribute, ok := attributes["node_repair_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_repair_config4 is missing from object`)

		return nil, diags
	}

	nodeRepairConfig4Val, ok := nodeRepairConfig4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_repair_config4 expected to be basetypes.ListValue, was: %T`, nodeRepairConfig4Attribute))
	}

	overrideBootstrapCommandAttribute, ok := attributes["override_bootstrap_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_bootstrap_command is missing from object`)

		return nil, diags
	}

	overrideBootstrapCommandVal, ok := overrideBootstrapCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_bootstrap_command expected to be basetypes.StringValue, was: %T`, overrideBootstrapCommandAttribute))
	}

	placement4Attribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement4 is missing from object`)

		return nil, diags
	}

	placement4Val, ok := placement4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement4 expected to be basetypes.ListValue, was: %T`, placement4Attribute))
	}

	preBootstrapCommandsAttribute, ok := attributes["pre_bootstrap_commands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_bootstrap_commands is missing from object`)

		return nil, diags
	}

	preBootstrapCommandsVal, ok := preBootstrapCommandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_bootstrap_commands expected to be basetypes.ListValue, was: %T`, preBootstrapCommandsAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return nil, diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	securityGroups4Attribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups4 is missing from object`)

		return nil, diags
	}

	securityGroups4Val, ok := securityGroups4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups4 expected to be basetypes.ListValue, was: %T`, securityGroups4Attribute))
	}

	spotAttribute, ok := attributes["spot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot is missing from object`)

		return nil, diags
	}

	spotVal, ok := spotAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot expected to be basetypes.BoolValue, was: %T`, spotAttribute))
	}

	ssh4Attribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh4 is missing from object`)

		return nil, diags
	}

	ssh4Val, ok := ssh4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh4 expected to be basetypes.ListValue, was: %T`, ssh4Attribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.SetValue, was: %T`, subnetsAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	taints4Attribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints4 is missing from object`)

		return nil, diags
	}

	taints4Val, ok := taints4Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints4 expected to be basetypes.SetValue, was: %T`, taints4Attribute))
	}

	updateConfig4Attribute, ok := attributes["update_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update_config4 is missing from object`)

		return nil, diags
	}

	updateConfig4Val, ok := updateConfig4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update_config4 expected to be basetypes.ListValue, was: %T`, updateConfig4Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return nil, diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return nil, diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeKmsKeyIdAttribute, ok := attributes["volume_kms_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_kms_key_id is missing from object`)

		return nil, diags
	}

	volumeKmsKeyIdVal, ok := volumeKmsKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_kms_key_id expected to be basetypes.StringValue, was: %T`, volumeKmsKeyIdAttribute))
	}

	volumeNameAttribute, ok := attributes["volume_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_name is missing from object`)

		return nil, diags
	}

	volumeNameVal, ok := volumeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_name expected to be basetypes.StringValue, was: %T`, volumeNameAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return nil, diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ManagedNodegroupsValue{
		Ami:                      amiVal,
		AmiFamily:                amiFamilyVal,
		AsgSuspendProcesses:      asgSuspendProcessesVal,
		AvailabilityZones:        availabilityZonesVal,
		BottleRocket4:            bottleRocket4Val,
		DesiredCapacity:          desiredCapacityVal,
		DisableImdsv1:            disableImdsv1Val,
		DisablePodsImds:          disablePodsImdsVal,
		EbsOptimized:             ebsOptimizedVal,
		EfaEnabled:               efaEnabledVal,
		EnableDetailedMonitoring: enableDetailedMonitoringVal,
		Iam4:                     iam4Val,
		InstanceName:             instanceNameVal,
		InstancePrefix:           instancePrefixVal,
		InstanceSelector4:        instanceSelector4Val,
		InstanceType:             instanceTypeVal,
		InstanceTypes:            instanceTypesVal,
		Labels:                   labelsVal,
		LaunchTemplate4:          launchTemplate4Val,
		MaxPodsPerNode:           maxPodsPerNodeVal,
		MaxSize:                  maxSizeVal,
		MinSize:                  minSizeVal,
		Name:                     nameVal,
		NodeRepairConfig4:        nodeRepairConfig4Val,
		OverrideBootstrapCommand: overrideBootstrapCommandVal,
		Placement4:               placement4Val,
		PreBootstrapCommands:     preBootstrapCommandsVal,
		PrivateNetworking:        privateNetworkingVal,
		SecurityGroups4:          securityGroups4Val,
		Spot:                     spotVal,
		Ssh4:                     ssh4Val,
		Subnets:                  subnetsVal,
		Tags:                     tagsVal,
		Taints4:                  taints4Val,
		UpdateConfig4:            updateConfig4Val,
		Version:                  versionVal,
		VolumeEncrypted:          volumeEncryptedVal,
		VolumeIops:               volumeIopsVal,
		VolumeKmsKeyId:           volumeKmsKeyIdVal,
		VolumeName:               volumeNameVal,
		VolumeSize:               volumeSizeVal,
		VolumeThroughput:         volumeThroughputVal,
		VolumeType:               volumeTypeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewManagedNodegroupsValueNull() ManagedNodegroupsValue {
	return ManagedNodegroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewManagedNodegroupsValueUnknown() ManagedNodegroupsValue {
	return ManagedNodegroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewManagedNodegroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ManagedNodegroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ManagedNodegroupsValue Attribute Value",
				"While creating a ManagedNodegroupsValue value, a missing attribute value was detected. "+
					"A ManagedNodegroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ManagedNodegroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ManagedNodegroupsValue Attribute Type",
				"While creating a ManagedNodegroupsValue value, an invalid attribute value was detected. "+
					"A ManagedNodegroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ManagedNodegroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ManagedNodegroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ManagedNodegroupsValue Attribute Value",
				"While creating a ManagedNodegroupsValue value, an extra attribute value was detected. "+
					"A ManagedNodegroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ManagedNodegroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewManagedNodegroupsValueUnknown(), diags
	}

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	asgSuspendProcessesAttribute, ok := attributes["asg_suspend_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_suspend_processes is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	asgSuspendProcessesVal, ok := asgSuspendProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_suspend_processes expected to be basetypes.ListValue, was: %T`, asgSuspendProcessesAttribute))
	}

	availabilityZonesAttribute, ok := attributes["availability_zones"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	availabilityZonesVal, ok := availabilityZonesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones expected to be basetypes.ListValue, was: %T`, availabilityZonesAttribute))
	}

	bottleRocket4Attribute, ok := attributes["bottle_rocket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bottle_rocket4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	bottleRocket4Val, ok := bottleRocket4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bottle_rocket4 expected to be basetypes.ListValue, was: %T`, bottleRocket4Attribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	ebsOptimizedAttribute, ok := attributes["ebs_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_optimized is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	ebsOptimizedVal, ok := ebsOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_optimized expected to be basetypes.BoolValue, was: %T`, ebsOptimizedAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	enableDetailedMonitoringAttribute, ok := attributes["enable_detailed_monitoring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_detailed_monitoring is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	enableDetailedMonitoringVal, ok := enableDetailedMonitoringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_detailed_monitoring expected to be basetypes.BoolValue, was: %T`, enableDetailedMonitoringAttribute))
	}

	iam4Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	iam4Val, ok := iam4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam4 expected to be basetypes.ListValue, was: %T`, iam4Attribute))
	}

	instanceNameAttribute, ok := attributes["instance_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_name is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	instanceNameVal, ok := instanceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_name expected to be basetypes.StringValue, was: %T`, instanceNameAttribute))
	}

	instancePrefixAttribute, ok := attributes["instance_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_prefix is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	instancePrefixVal, ok := instancePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_prefix expected to be basetypes.StringValue, was: %T`, instancePrefixAttribute))
	}

	instanceSelector4Attribute, ok := attributes["instance_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_selector4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	instanceSelector4Val, ok := instanceSelector4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_selector4 expected to be basetypes.ListValue, was: %T`, instanceSelector4Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	instanceTypesAttribute, ok := attributes["instance_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_types is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	instanceTypesVal, ok := instanceTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_types expected to be basetypes.ListValue, was: %T`, instanceTypesAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	launchTemplate4Attribute, ok := attributes["launch_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`launch_template4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	launchTemplate4Val, ok := launchTemplate4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`launch_template4 expected to be basetypes.ListValue, was: %T`, launchTemplate4Attribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeRepairConfig4Attribute, ok := attributes["node_repair_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_repair_config4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	nodeRepairConfig4Val, ok := nodeRepairConfig4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_repair_config4 expected to be basetypes.ListValue, was: %T`, nodeRepairConfig4Attribute))
	}

	overrideBootstrapCommandAttribute, ok := attributes["override_bootstrap_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_bootstrap_command is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	overrideBootstrapCommandVal, ok := overrideBootstrapCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_bootstrap_command expected to be basetypes.StringValue, was: %T`, overrideBootstrapCommandAttribute))
	}

	placement4Attribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	placement4Val, ok := placement4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement4 expected to be basetypes.ListValue, was: %T`, placement4Attribute))
	}

	preBootstrapCommandsAttribute, ok := attributes["pre_bootstrap_commands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_bootstrap_commands is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	preBootstrapCommandsVal, ok := preBootstrapCommandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_bootstrap_commands expected to be basetypes.ListValue, was: %T`, preBootstrapCommandsAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	securityGroups4Attribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	securityGroups4Val, ok := securityGroups4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups4 expected to be basetypes.ListValue, was: %T`, securityGroups4Attribute))
	}

	spotAttribute, ok := attributes["spot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	spotVal, ok := spotAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot expected to be basetypes.BoolValue, was: %T`, spotAttribute))
	}

	ssh4Attribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	ssh4Val, ok := ssh4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh4 expected to be basetypes.ListValue, was: %T`, ssh4Attribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.SetValue, was: %T`, subnetsAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	taints4Attribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	taints4Val, ok := taints4Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints4 expected to be basetypes.SetValue, was: %T`, taints4Attribute))
	}

	updateConfig4Attribute, ok := attributes["update_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update_config4 is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	updateConfig4Val, ok := updateConfig4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update_config4 expected to be basetypes.ListValue, was: %T`, updateConfig4Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeKmsKeyIdAttribute, ok := attributes["volume_kms_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_kms_key_id is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	volumeKmsKeyIdVal, ok := volumeKmsKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_kms_key_id expected to be basetypes.StringValue, was: %T`, volumeKmsKeyIdAttribute))
	}

	volumeNameAttribute, ok := attributes["volume_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_name is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	volumeNameVal, ok := volumeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_name expected to be basetypes.StringValue, was: %T`, volumeNameAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewManagedNodegroupsValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewManagedNodegroupsValueUnknown(), diags
	}

	return ManagedNodegroupsValue{
		Ami:                      amiVal,
		AmiFamily:                amiFamilyVal,
		AsgSuspendProcesses:      asgSuspendProcessesVal,
		AvailabilityZones:        availabilityZonesVal,
		BottleRocket4:            bottleRocket4Val,
		DesiredCapacity:          desiredCapacityVal,
		DisableImdsv1:            disableImdsv1Val,
		DisablePodsImds:          disablePodsImdsVal,
		EbsOptimized:             ebsOptimizedVal,
		EfaEnabled:               efaEnabledVal,
		EnableDetailedMonitoring: enableDetailedMonitoringVal,
		Iam4:                     iam4Val,
		InstanceName:             instanceNameVal,
		InstancePrefix:           instancePrefixVal,
		InstanceSelector4:        instanceSelector4Val,
		InstanceType:             instanceTypeVal,
		InstanceTypes:            instanceTypesVal,
		Labels:                   labelsVal,
		LaunchTemplate4:          launchTemplate4Val,
		MaxPodsPerNode:           maxPodsPerNodeVal,
		MaxSize:                  maxSizeVal,
		MinSize:                  minSizeVal,
		Name:                     nameVal,
		NodeRepairConfig4:        nodeRepairConfig4Val,
		OverrideBootstrapCommand: overrideBootstrapCommandVal,
		Placement4:               placement4Val,
		PreBootstrapCommands:     preBootstrapCommandsVal,
		PrivateNetworking:        privateNetworkingVal,
		SecurityGroups4:          securityGroups4Val,
		Spot:                     spotVal,
		Ssh4:                     ssh4Val,
		Subnets:                  subnetsVal,
		Tags:                     tagsVal,
		Taints4:                  taints4Val,
		UpdateConfig4:            updateConfig4Val,
		Version:                  versionVal,
		VolumeEncrypted:          volumeEncryptedVal,
		VolumeIops:               volumeIopsVal,
		VolumeKmsKeyId:           volumeKmsKeyIdVal,
		VolumeName:               volumeNameVal,
		VolumeSize:               volumeSizeVal,
		VolumeThroughput:         volumeThroughputVal,
		VolumeType:               volumeTypeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewManagedNodegroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ManagedNodegroupsValue {
	object, diags := NewManagedNodegroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewManagedNodegroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ManagedNodegroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewManagedNodegroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewManagedNodegroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewManagedNodegroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewManagedNodegroupsValueMust(ManagedNodegroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ManagedNodegroupsType) ValueType(ctx context.Context) attr.Value {
	return ManagedNodegroupsValue{}
}

var _ basetypes.ObjectValuable = ManagedNodegroupsValue{}

type ManagedNodegroupsValue struct {
	Ami                      basetypes.StringValue `tfsdk:"ami"`
	AmiFamily                basetypes.StringValue `tfsdk:"ami_family"`
	AsgSuspendProcesses      basetypes.ListValue   `tfsdk:"asg_suspend_processes"`
	AvailabilityZones        basetypes.ListValue   `tfsdk:"availability_zones"`
	BottleRocket4            basetypes.ListValue   `tfsdk:"bottle_rocket"`
	DesiredCapacity          basetypes.Int64Value  `tfsdk:"desired_capacity"`
	DisableImdsv1            basetypes.BoolValue   `tfsdk:"disable_imdsv1"`
	DisablePodsImds          basetypes.BoolValue   `tfsdk:"disable_pods_imds"`
	EbsOptimized             basetypes.BoolValue   `tfsdk:"ebs_optimized"`
	EfaEnabled               basetypes.BoolValue   `tfsdk:"efa_enabled"`
	EnableDetailedMonitoring basetypes.BoolValue   `tfsdk:"enable_detailed_monitoring"`
	Iam4                     basetypes.ListValue   `tfsdk:"iam"`
	InstanceName             basetypes.StringValue `tfsdk:"instance_name"`
	InstancePrefix           basetypes.StringValue `tfsdk:"instance_prefix"`
	InstanceSelector4        basetypes.ListValue   `tfsdk:"instance_selector"`
	InstanceType             basetypes.StringValue `tfsdk:"instance_type"`
	InstanceTypes            basetypes.ListValue   `tfsdk:"instance_types"`
	Labels                   basetypes.MapValue    `tfsdk:"labels"`
	LaunchTemplate4          basetypes.ListValue   `tfsdk:"launch_template"`
	MaxPodsPerNode           basetypes.Int64Value  `tfsdk:"max_pods_per_node"`
	MaxSize                  basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize                  basetypes.Int64Value  `tfsdk:"min_size"`
	Name                     basetypes.StringValue `tfsdk:"name"`
	NodeRepairConfig4        basetypes.ListValue   `tfsdk:"node_repair_config"`
	OverrideBootstrapCommand basetypes.StringValue `tfsdk:"override_bootstrap_command"`
	Placement4               basetypes.ListValue   `tfsdk:"placement"`
	PreBootstrapCommands     basetypes.ListValue   `tfsdk:"pre_bootstrap_commands"`
	PrivateNetworking        basetypes.BoolValue   `tfsdk:"private_networking"`
	SecurityGroups4          basetypes.ListValue   `tfsdk:"security_groups"`
	Spot                     basetypes.BoolValue   `tfsdk:"spot"`
	Ssh4                     basetypes.ListValue   `tfsdk:"ssh"`
	Subnets                  basetypes.SetValue    `tfsdk:"subnets"`
	Tags                     basetypes.MapValue    `tfsdk:"tags"`
	Taints4                  basetypes.SetValue    `tfsdk:"taints"`
	UpdateConfig4            basetypes.ListValue   `tfsdk:"update_config"`
	Version                  basetypes.StringValue `tfsdk:"version"`
	VolumeEncrypted          basetypes.BoolValue   `tfsdk:"volume_encrypted"`
	VolumeIops               basetypes.Int64Value  `tfsdk:"volume_iops"`
	VolumeKmsKeyId           basetypes.StringValue `tfsdk:"volume_kms_key_id"`
	VolumeName               basetypes.StringValue `tfsdk:"volume_name"`
	VolumeSize               basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeThroughput         basetypes.Int64Value  `tfsdk:"volume_throughput"`
	VolumeType               basetypes.StringValue `tfsdk:"volume_type"`
	state                    attr.ValueState
}

func (v ManagedNodegroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 43)

	var val tftypes.Value
	var err error

	attrTypes["ami"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ami_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["asg_suspend_processes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["availability_zones"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["bottle_rocket"] = basetypes.ListType{
		ElemType: BottleRocket4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["desired_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_imdsv1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_pods_imds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs_optimized"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_detailed_monitoring"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ListType{
		ElemType: Iam4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_selector"] = basetypes.ListType{
		ElemType: InstanceSelector4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_types"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["launch_template"] = basetypes.ListType{
		ElemType: LaunchTemplate4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["max_pods_per_node"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_repair_config"] = basetypes.ListType{
		ElemType: NodeRepairConfig4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["override_bootstrap_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["placement"] = basetypes.ListType{
		ElemType: Placement4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["pre_bootstrap_commands"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["private_networking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroups4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["spot"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ssh"] = basetypes.ListType{
		ElemType: Ssh4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["taints"] = basetypes.SetType{
		ElemType: Taints4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["update_config"] = basetypes.ListType{
		ElemType: UpdateConfig4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_encrypted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["volume_iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_kms_key_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_throughput"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 43)

		val, err = v.Ami.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami"] = val

		val, err = v.AmiFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami_family"] = val

		val, err = v.AsgSuspendProcesses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asg_suspend_processes"] = val

		val, err = v.AvailabilityZones.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["availability_zones"] = val

		val, err = v.BottleRocket4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bottle_rocket"] = val

		val, err = v.DesiredCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_capacity"] = val

		val, err = v.DisableImdsv1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_imdsv1"] = val

		val, err = v.DisablePodsImds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_pods_imds"] = val

		val, err = v.EbsOptimized.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs_optimized"] = val

		val, err = v.EfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efa_enabled"] = val

		val, err = v.EnableDetailedMonitoring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_detailed_monitoring"] = val

		val, err = v.Iam4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.InstanceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_name"] = val

		val, err = v.InstancePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_prefix"] = val

		val, err = v.InstanceSelector4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_selector"] = val

		val, err = v.InstanceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_type"] = val

		val, err = v.InstanceTypes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_types"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.LaunchTemplate4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["launch_template"] = val

		val, err = v.MaxPodsPerNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pods_per_node"] = val

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeRepairConfig4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_repair_config"] = val

		val, err = v.OverrideBootstrapCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["override_bootstrap_command"] = val

		val, err = v.Placement4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["placement"] = val

		val, err = v.PreBootstrapCommands.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pre_bootstrap_commands"] = val

		val, err = v.PrivateNetworking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_networking"] = val

		val, err = v.SecurityGroups4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Spot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spot"] = val

		val, err = v.Ssh4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Taints4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taints"] = val

		val, err = v.UpdateConfig4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["update_config"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VolumeEncrypted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_encrypted"] = val

		val, err = v.VolumeIops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_iops"] = val

		val, err = v.VolumeKmsKeyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_kms_key_id"] = val

		val, err = v.VolumeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_name"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeThroughput.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_throughput"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ManagedNodegroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ManagedNodegroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ManagedNodegroupsValue) String() string {
	return "ManagedNodegroupsValue"
}

func (v ManagedNodegroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	bottleRocket4 := types.ListValueMust(
		BottleRocket4Type{
			basetypes.ObjectType{
				AttrTypes: BottleRocket4Value{}.AttributeTypes(ctx),
			},
		},
		v.BottleRocket4.Elements(),
	)

	if v.BottleRocket4.IsNull() {
		bottleRocket4 = types.ListNull(
			BottleRocket4Type{
				basetypes.ObjectType{
					AttrTypes: BottleRocket4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BottleRocket4.IsUnknown() {
		bottleRocket4 = types.ListUnknown(
			BottleRocket4Type{
				basetypes.ObjectType{
					AttrTypes: BottleRocket4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	iam4 := types.ListValueMust(
		Iam4Type{
			basetypes.ObjectType{
				AttrTypes: Iam4Value{}.AttributeTypes(ctx),
			},
		},
		v.Iam4.Elements(),
	)

	if v.Iam4.IsNull() {
		iam4 = types.ListNull(
			Iam4Type{
				basetypes.ObjectType{
					AttrTypes: Iam4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Iam4.IsUnknown() {
		iam4 = types.ListUnknown(
			Iam4Type{
				basetypes.ObjectType{
					AttrTypes: Iam4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	instanceSelector4 := types.ListValueMust(
		InstanceSelector4Type{
			basetypes.ObjectType{
				AttrTypes: InstanceSelector4Value{}.AttributeTypes(ctx),
			},
		},
		v.InstanceSelector4.Elements(),
	)

	if v.InstanceSelector4.IsNull() {
		instanceSelector4 = types.ListNull(
			InstanceSelector4Type{
				basetypes.ObjectType{
					AttrTypes: InstanceSelector4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InstanceSelector4.IsUnknown() {
		instanceSelector4 = types.ListUnknown(
			InstanceSelector4Type{
				basetypes.ObjectType{
					AttrTypes: InstanceSelector4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	launchTemplate4 := types.ListValueMust(
		LaunchTemplate4Type{
			basetypes.ObjectType{
				AttrTypes: LaunchTemplate4Value{}.AttributeTypes(ctx),
			},
		},
		v.LaunchTemplate4.Elements(),
	)

	if v.LaunchTemplate4.IsNull() {
		launchTemplate4 = types.ListNull(
			LaunchTemplate4Type{
				basetypes.ObjectType{
					AttrTypes: LaunchTemplate4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.LaunchTemplate4.IsUnknown() {
		launchTemplate4 = types.ListUnknown(
			LaunchTemplate4Type{
				basetypes.ObjectType{
					AttrTypes: LaunchTemplate4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeRepairConfig4 := types.ListValueMust(
		NodeRepairConfig4Type{
			basetypes.ObjectType{
				AttrTypes: NodeRepairConfig4Value{}.AttributeTypes(ctx),
			},
		},
		v.NodeRepairConfig4.Elements(),
	)

	if v.NodeRepairConfig4.IsNull() {
		nodeRepairConfig4 = types.ListNull(
			NodeRepairConfig4Type{
				basetypes.ObjectType{
					AttrTypes: NodeRepairConfig4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeRepairConfig4.IsUnknown() {
		nodeRepairConfig4 = types.ListUnknown(
			NodeRepairConfig4Type{
				basetypes.ObjectType{
					AttrTypes: NodeRepairConfig4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	placement4 := types.ListValueMust(
		Placement4Type{
			basetypes.ObjectType{
				AttrTypes: Placement4Value{}.AttributeTypes(ctx),
			},
		},
		v.Placement4.Elements(),
	)

	if v.Placement4.IsNull() {
		placement4 = types.ListNull(
			Placement4Type{
				basetypes.ObjectType{
					AttrTypes: Placement4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Placement4.IsUnknown() {
		placement4 = types.ListUnknown(
			Placement4Type{
				basetypes.ObjectType{
					AttrTypes: Placement4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroups4 := types.ListValueMust(
		SecurityGroups4Type{
			basetypes.ObjectType{
				AttrTypes: SecurityGroups4Value{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups4.Elements(),
	)

	if v.SecurityGroups4.IsNull() {
		securityGroups4 = types.ListNull(
			SecurityGroups4Type{
				basetypes.ObjectType{
					AttrTypes: SecurityGroups4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups4.IsUnknown() {
		securityGroups4 = types.ListUnknown(
			SecurityGroups4Type{
				basetypes.ObjectType{
					AttrTypes: SecurityGroups4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ssh4 := types.ListValueMust(
		Ssh4Type{
			basetypes.ObjectType{
				AttrTypes: Ssh4Value{}.AttributeTypes(ctx),
			},
		},
		v.Ssh4.Elements(),
	)

	if v.Ssh4.IsNull() {
		ssh4 = types.ListNull(
			Ssh4Type{
				basetypes.ObjectType{
					AttrTypes: Ssh4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ssh4.IsUnknown() {
		ssh4 = types.ListUnknown(
			Ssh4Type{
				basetypes.ObjectType{
					AttrTypes: Ssh4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	taints4 := types.SetValueMust(
		Taints4Type{
			basetypes.ObjectType{
				AttrTypes: Taints4Value{}.AttributeTypes(ctx),
			},
		},
		v.Taints4.Elements(),
	)

	if v.Taints4.IsNull() {
		taints4 = types.SetNull(
			Taints4Type{
				basetypes.ObjectType{
					AttrTypes: Taints4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taints4.IsUnknown() {
		taints4 = types.SetUnknown(
			Taints4Type{
				basetypes.ObjectType{
					AttrTypes: Taints4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	updateConfig4 := types.ListValueMust(
		UpdateConfig4Type{
			basetypes.ObjectType{
				AttrTypes: UpdateConfig4Value{}.AttributeTypes(ctx),
			},
		},
		v.UpdateConfig4.Elements(),
	)

	if v.UpdateConfig4.IsNull() {
		updateConfig4 = types.ListNull(
			UpdateConfig4Type{
				basetypes.ObjectType{
					AttrTypes: UpdateConfig4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.UpdateConfig4.IsUnknown() {
		updateConfig4 = types.ListUnknown(
			UpdateConfig4Type{
				basetypes.ObjectType{
					AttrTypes: UpdateConfig4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var asgSuspendProcessesVal basetypes.ListValue
	switch {
	case v.AsgSuspendProcesses.IsUnknown():
		asgSuspendProcessesVal = types.ListUnknown(types.StringType)
	case v.AsgSuspendProcesses.IsNull():
		asgSuspendProcessesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		asgSuspendProcessesVal, d = types.ListValue(types.StringType, v.AsgSuspendProcesses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocket4Value{}.Type(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: Iam4Value{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelector4Value{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ListType{
				ElemType: LaunchTemplate4Value{}.Type(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"name":              basetypes.StringType{},
			"node_repair_config": basetypes.ListType{
				ElemType: NodeRepairConfig4Value{}.Type(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: Placement4Value{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroups4Value{}.Type(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ListType{
				ElemType: Ssh4Value{}.Type(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints4Value{}.Type(ctx),
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfig4Value{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var availabilityZonesVal basetypes.ListValue
	switch {
	case v.AvailabilityZones.IsUnknown():
		availabilityZonesVal = types.ListUnknown(types.StringType)
	case v.AvailabilityZones.IsNull():
		availabilityZonesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		availabilityZonesVal, d = types.ListValue(types.StringType, v.AvailabilityZones.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocket4Value{}.Type(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: Iam4Value{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelector4Value{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ListType{
				ElemType: LaunchTemplate4Value{}.Type(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"name":              basetypes.StringType{},
			"node_repair_config": basetypes.ListType{
				ElemType: NodeRepairConfig4Value{}.Type(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: Placement4Value{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroups4Value{}.Type(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ListType{
				ElemType: Ssh4Value{}.Type(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints4Value{}.Type(ctx),
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfig4Value{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var instanceTypesVal basetypes.ListValue
	switch {
	case v.InstanceTypes.IsUnknown():
		instanceTypesVal = types.ListUnknown(types.StringType)
	case v.InstanceTypes.IsNull():
		instanceTypesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		instanceTypesVal, d = types.ListValue(types.StringType, v.InstanceTypes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocket4Value{}.Type(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: Iam4Value{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelector4Value{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ListType{
				ElemType: LaunchTemplate4Value{}.Type(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"name":              basetypes.StringType{},
			"node_repair_config": basetypes.ListType{
				ElemType: NodeRepairConfig4Value{}.Type(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: Placement4Value{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroups4Value{}.Type(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ListType{
				ElemType: Ssh4Value{}.Type(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints4Value{}.Type(ctx),
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfig4Value{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocket4Value{}.Type(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: Iam4Value{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelector4Value{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ListType{
				ElemType: LaunchTemplate4Value{}.Type(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"name":              basetypes.StringType{},
			"node_repair_config": basetypes.ListType{
				ElemType: NodeRepairConfig4Value{}.Type(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: Placement4Value{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroups4Value{}.Type(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ListType{
				ElemType: Ssh4Value{}.Type(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints4Value{}.Type(ctx),
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfig4Value{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var preBootstrapCommandsVal basetypes.ListValue
	switch {
	case v.PreBootstrapCommands.IsUnknown():
		preBootstrapCommandsVal = types.ListUnknown(types.StringType)
	case v.PreBootstrapCommands.IsNull():
		preBootstrapCommandsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		preBootstrapCommandsVal, d = types.ListValue(types.StringType, v.PreBootstrapCommands.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocket4Value{}.Type(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: Iam4Value{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelector4Value{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ListType{
				ElemType: LaunchTemplate4Value{}.Type(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"name":              basetypes.StringType{},
			"node_repair_config": basetypes.ListType{
				ElemType: NodeRepairConfig4Value{}.Type(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: Placement4Value{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroups4Value{}.Type(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ListType{
				ElemType: Ssh4Value{}.Type(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints4Value{}.Type(ctx),
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfig4Value{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var subnetsVal basetypes.SetValue
	switch {
	case v.Subnets.IsUnknown():
		subnetsVal = types.SetUnknown(types.StringType)
	case v.Subnets.IsNull():
		subnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		subnetsVal, d = types.SetValue(types.StringType, v.Subnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocket4Value{}.Type(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: Iam4Value{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelector4Value{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ListType{
				ElemType: LaunchTemplate4Value{}.Type(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"name":              basetypes.StringType{},
			"node_repair_config": basetypes.ListType{
				ElemType: NodeRepairConfig4Value{}.Type(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: Placement4Value{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroups4Value{}.Type(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ListType{
				ElemType: Ssh4Value{}.Type(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints4Value{}.Type(ctx),
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfig4Value{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocket4Value{}.Type(ctx),
			},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: Iam4Value{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelector4Value{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"launch_template": basetypes.ListType{
				ElemType: LaunchTemplate4Value{}.Type(ctx),
			},
			"max_pods_per_node": basetypes.Int64Type{},
			"max_size":          basetypes.Int64Type{},
			"min_size":          basetypes.Int64Type{},
			"name":              basetypes.StringType{},
			"node_repair_config": basetypes.ListType{
				ElemType: NodeRepairConfig4Value{}.Type(ctx),
			},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: Placement4Value{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroups4Value{}.Type(ctx),
			},
			"spot": basetypes.BoolType{},
			"ssh": basetypes.ListType{
				ElemType: Ssh4Value{}.Type(ctx),
			},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: Taints4Value{}.Type(ctx),
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfig4Value{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ami":        basetypes.StringType{},
		"ami_family": basetypes.StringType{},
		"asg_suspend_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"availability_zones": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bottle_rocket": basetypes.ListType{
			ElemType: BottleRocket4Value{}.Type(ctx),
		},
		"desired_capacity":           basetypes.Int64Type{},
		"disable_imdsv1":             basetypes.BoolType{},
		"disable_pods_imds":          basetypes.BoolType{},
		"ebs_optimized":              basetypes.BoolType{},
		"efa_enabled":                basetypes.BoolType{},
		"enable_detailed_monitoring": basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: Iam4Value{}.Type(ctx),
		},
		"instance_name":   basetypes.StringType{},
		"instance_prefix": basetypes.StringType{},
		"instance_selector": basetypes.ListType{
			ElemType: InstanceSelector4Value{}.Type(ctx),
		},
		"instance_type": basetypes.StringType{},
		"instance_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"launch_template": basetypes.ListType{
			ElemType: LaunchTemplate4Value{}.Type(ctx),
		},
		"max_pods_per_node": basetypes.Int64Type{},
		"max_size":          basetypes.Int64Type{},
		"min_size":          basetypes.Int64Type{},
		"name":              basetypes.StringType{},
		"node_repair_config": basetypes.ListType{
			ElemType: NodeRepairConfig4Value{}.Type(ctx),
		},
		"override_bootstrap_command": basetypes.StringType{},
		"placement": basetypes.ListType{
			ElemType: Placement4Value{}.Type(ctx),
		},
		"pre_bootstrap_commands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_networking": basetypes.BoolType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroups4Value{}.Type(ctx),
		},
		"spot": basetypes.BoolType{},
		"ssh": basetypes.ListType{
			ElemType: Ssh4Value{}.Type(ctx),
		},
		"subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"taints": basetypes.SetType{
			ElemType: Taints4Value{}.Type(ctx),
		},
		"update_config": basetypes.ListType{
			ElemType: UpdateConfig4Value{}.Type(ctx),
		},
		"version":           basetypes.StringType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_iops":       basetypes.Int64Type{},
		"volume_kms_key_id": basetypes.StringType{},
		"volume_name":       basetypes.StringType{},
		"volume_size":       basetypes.Int64Type{},
		"volume_throughput": basetypes.Int64Type{},
		"volume_type":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ami":                        v.Ami,
			"ami_family":                 v.AmiFamily,
			"asg_suspend_processes":      asgSuspendProcessesVal,
			"availability_zones":         availabilityZonesVal,
			"bottle_rocket":              bottleRocket4,
			"desired_capacity":           v.DesiredCapacity,
			"disable_imdsv1":             v.DisableImdsv1,
			"disable_pods_imds":          v.DisablePodsImds,
			"ebs_optimized":              v.EbsOptimized,
			"efa_enabled":                v.EfaEnabled,
			"enable_detailed_monitoring": v.EnableDetailedMonitoring,
			"iam":                        iam4,
			"instance_name":              v.InstanceName,
			"instance_prefix":            v.InstancePrefix,
			"instance_selector":          instanceSelector4,
			"instance_type":              v.InstanceType,
			"instance_types":             instanceTypesVal,
			"labels":                     labelsVal,
			"launch_template":            launchTemplate4,
			"max_pods_per_node":          v.MaxPodsPerNode,
			"max_size":                   v.MaxSize,
			"min_size":                   v.MinSize,
			"name":                       v.Name,
			"node_repair_config":         nodeRepairConfig4,
			"override_bootstrap_command": v.OverrideBootstrapCommand,
			"placement":                  placement4,
			"pre_bootstrap_commands":     preBootstrapCommandsVal,
			"private_networking":         v.PrivateNetworking,
			"security_groups":            securityGroups4,
			"spot":                       v.Spot,
			"ssh":                        ssh4,
			"subnets":                    subnetsVal,
			"tags":                       tagsVal,
			"taints":                     taints4,
			"update_config":              updateConfig4,
			"version":                    v.Version,
			"volume_encrypted":           v.VolumeEncrypted,
			"volume_iops":                v.VolumeIops,
			"volume_kms_key_id":          v.VolumeKmsKeyId,
			"volume_name":                v.VolumeName,
			"volume_size":                v.VolumeSize,
			"volume_throughput":          v.VolumeThroughput,
			"volume_type":                v.VolumeType,
		})

	return objVal, diags
}

func (v ManagedNodegroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(ManagedNodegroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ami.Equal(other.Ami) {
		return false
	}

	if !v.AmiFamily.Equal(other.AmiFamily) {
		return false
	}

	if !v.AsgSuspendProcesses.Equal(other.AsgSuspendProcesses) {
		return false
	}

	if !v.AvailabilityZones.Equal(other.AvailabilityZones) {
		return false
	}

	if !v.BottleRocket4.Equal(other.BottleRocket4) {
		return false
	}

	if !v.DesiredCapacity.Equal(other.DesiredCapacity) {
		return false
	}

	if !v.DisableImdsv1.Equal(other.DisableImdsv1) {
		return false
	}

	if !v.DisablePodsImds.Equal(other.DisablePodsImds) {
		return false
	}

	if !v.EbsOptimized.Equal(other.EbsOptimized) {
		return false
	}

	if !v.EfaEnabled.Equal(other.EfaEnabled) {
		return false
	}

	if !v.EnableDetailedMonitoring.Equal(other.EnableDetailedMonitoring) {
		return false
	}

	if !v.Iam4.Equal(other.Iam4) {
		return false
	}

	if !v.InstanceName.Equal(other.InstanceName) {
		return false
	}

	if !v.InstancePrefix.Equal(other.InstancePrefix) {
		return false
	}

	if !v.InstanceSelector4.Equal(other.InstanceSelector4) {
		return false
	}

	if !v.InstanceType.Equal(other.InstanceType) {
		return false
	}

	if !v.InstanceTypes.Equal(other.InstanceTypes) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.LaunchTemplate4.Equal(other.LaunchTemplate4) {
		return false
	}

	if !v.MaxPodsPerNode.Equal(other.MaxPodsPerNode) {
		return false
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeRepairConfig4.Equal(other.NodeRepairConfig4) {
		return false
	}

	if !v.OverrideBootstrapCommand.Equal(other.OverrideBootstrapCommand) {
		return false
	}

	if !v.Placement4.Equal(other.Placement4) {
		return false
	}

	if !v.PreBootstrapCommands.Equal(other.PreBootstrapCommands) {
		return false
	}

	if !v.PrivateNetworking.Equal(other.PrivateNetworking) {
		return false
	}

	if !v.SecurityGroups4.Equal(other.SecurityGroups4) {
		return false
	}

	if !v.Spot.Equal(other.Spot) {
		return false
	}

	if !v.Ssh4.Equal(other.Ssh4) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Taints4.Equal(other.Taints4) {
		return false
	}

	if !v.UpdateConfig4.Equal(other.UpdateConfig4) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VolumeEncrypted.Equal(other.VolumeEncrypted) {
		return false
	}

	if !v.VolumeIops.Equal(other.VolumeIops) {
		return false
	}

	if !v.VolumeKmsKeyId.Equal(other.VolumeKmsKeyId) {
		return false
	}

	if !v.VolumeName.Equal(other.VolumeName) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeThroughput.Equal(other.VolumeThroughput) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v ManagedNodegroupsValue) Type(ctx context.Context) attr.Type {
	return ManagedNodegroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ManagedNodegroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami":        basetypes.StringType{},
		"ami_family": basetypes.StringType{},
		"asg_suspend_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"availability_zones": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bottle_rocket": basetypes.ListType{
			ElemType: BottleRocket4Value{}.Type(ctx),
		},
		"desired_capacity":           basetypes.Int64Type{},
		"disable_imdsv1":             basetypes.BoolType{},
		"disable_pods_imds":          basetypes.BoolType{},
		"ebs_optimized":              basetypes.BoolType{},
		"efa_enabled":                basetypes.BoolType{},
		"enable_detailed_monitoring": basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: Iam4Value{}.Type(ctx),
		},
		"instance_name":   basetypes.StringType{},
		"instance_prefix": basetypes.StringType{},
		"instance_selector": basetypes.ListType{
			ElemType: InstanceSelector4Value{}.Type(ctx),
		},
		"instance_type": basetypes.StringType{},
		"instance_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"launch_template": basetypes.ListType{
			ElemType: LaunchTemplate4Value{}.Type(ctx),
		},
		"max_pods_per_node": basetypes.Int64Type{},
		"max_size":          basetypes.Int64Type{},
		"min_size":          basetypes.Int64Type{},
		"name":              basetypes.StringType{},
		"node_repair_config": basetypes.ListType{
			ElemType: NodeRepairConfig4Value{}.Type(ctx),
		},
		"override_bootstrap_command": basetypes.StringType{},
		"placement": basetypes.ListType{
			ElemType: Placement4Value{}.Type(ctx),
		},
		"pre_bootstrap_commands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_networking": basetypes.BoolType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroups4Value{}.Type(ctx),
		},
		"spot": basetypes.BoolType{},
		"ssh": basetypes.ListType{
			ElemType: Ssh4Value{}.Type(ctx),
		},
		"subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"taints": basetypes.SetType{
			ElemType: Taints4Value{}.Type(ctx),
		},
		"update_config": basetypes.ListType{
			ElemType: UpdateConfig4Value{}.Type(ctx),
		},
		"version":           basetypes.StringType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_iops":       basetypes.Int64Type{},
		"volume_kms_key_id": basetypes.StringType{},
		"volume_name":       basetypes.StringType{},
		"volume_size":       basetypes.Int64Type{},
		"volume_throughput": basetypes.Int64Type{},
		"volume_type":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BottleRocket4Type{}

type BottleRocket4Type struct {
	basetypes.ObjectType
}

func (t BottleRocket4Type) Equal(o attr.Type) bool {
	other, ok := o.(BottleRocket4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BottleRocket4Type) String() string {
	return "BottleRocket4Type"
}

func (t BottleRocket4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableAdminContainerAttribute, ok := attributes["enable_admin_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_admin_container is missing from object`)

		return nil, diags
	}

	enableAdminContainerVal, ok := enableAdminContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_admin_container expected to be basetypes.BoolValue, was: %T`, enableAdminContainerAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.StringValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BottleRocket4Value{
		EnableAdminContainer: enableAdminContainerVal,
		Settings:             settingsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBottleRocket4ValueNull() BottleRocket4Value {
	return BottleRocket4Value{
		state: attr.ValueStateNull,
	}
}

func NewBottleRocket4ValueUnknown() BottleRocket4Value {
	return BottleRocket4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBottleRocket4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BottleRocket4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BottleRocket4Value Attribute Value",
				"While creating a BottleRocket4Value value, a missing attribute value was detected. "+
					"A BottleRocket4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BottleRocket4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BottleRocket4Value Attribute Type",
				"While creating a BottleRocket4Value value, an invalid attribute value was detected. "+
					"A BottleRocket4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BottleRocket4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BottleRocket4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BottleRocket4Value Attribute Value",
				"While creating a BottleRocket4Value value, an extra attribute value was detected. "+
					"A BottleRocket4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BottleRocket4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBottleRocket4ValueUnknown(), diags
	}

	enableAdminContainerAttribute, ok := attributes["enable_admin_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_admin_container is missing from object`)

		return NewBottleRocket4ValueUnknown(), diags
	}

	enableAdminContainerVal, ok := enableAdminContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_admin_container expected to be basetypes.BoolValue, was: %T`, enableAdminContainerAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewBottleRocket4ValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.StringValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return NewBottleRocket4ValueUnknown(), diags
	}

	return BottleRocket4Value{
		EnableAdminContainer: enableAdminContainerVal,
		Settings:             settingsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBottleRocket4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BottleRocket4Value {
	object, diags := NewBottleRocket4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBottleRocket4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BottleRocket4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBottleRocket4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBottleRocket4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBottleRocket4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBottleRocket4ValueMust(BottleRocket4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t BottleRocket4Type) ValueType(ctx context.Context) attr.Value {
	return BottleRocket4Value{}
}

var _ basetypes.ObjectValuable = BottleRocket4Value{}

type BottleRocket4Value struct {
	EnableAdminContainer basetypes.BoolValue   `tfsdk:"enable_admin_container"`
	Settings             basetypes.StringValue `tfsdk:"settings"`
	state                attr.ValueState
}

func (v BottleRocket4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enable_admin_container"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EnableAdminContainer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_admin_container"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BottleRocket4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BottleRocket4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BottleRocket4Value) String() string {
	return "BottleRocket4Value"
}

func (v BottleRocket4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enable_admin_container": basetypes.BoolType{},
		"settings":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable_admin_container": v.EnableAdminContainer,
			"settings":               v.Settings,
		})

	return objVal, diags
}

func (v BottleRocket4Value) Equal(o attr.Value) bool {
	other, ok := o.(BottleRocket4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnableAdminContainer.Equal(other.EnableAdminContainer) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	return true
}

func (v BottleRocket4Value) Type(ctx context.Context) attr.Type {
	return BottleRocket4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BottleRocket4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable_admin_container": basetypes.BoolType{},
		"settings":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Iam4Type{}

type Iam4Type struct {
	basetypes.ObjectType
}

func (t Iam4Type) Equal(o attr.Type) bool {
	other, ok := o.(Iam4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Iam4Type) String() string {
	return "Iam4Type"
}

func (t Iam4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachPolicy4Attribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy4 is missing from object`)

		return nil, diags
	}

	attachPolicy4Val, ok := attachPolicy4Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy4 expected to be basetypes.SetValue, was: %T`, attachPolicy4Attribute))
	}

	attachPolicyArnsAttribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns is missing from object`)

		return nil, diags
	}

	attachPolicyArnsVal, ok := attachPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns expected to be basetypes.SetValue, was: %T`, attachPolicyArnsAttribute))
	}

	attachPolicyV2Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2 is missing from object`)

		return nil, diags
	}

	attachPolicyV2Val, ok := attachPolicyV2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2 expected to be basetypes.StringValue, was: %T`, attachPolicyV2Attribute))
	}

	iamNodeGroupWithAddonPolicies4Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies4 is missing from object`)

		return nil, diags
	}

	iamNodeGroupWithAddonPolicies4Val, ok := iamNodeGroupWithAddonPolicies4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies4 expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPolicies4Attribute))
	}

	instanceProfileArnAttribute, ok := attributes["instance_profile_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_profile_arn is missing from object`)

		return nil, diags
	}

	instanceProfileArnVal, ok := instanceProfileArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_profile_arn expected to be basetypes.StringValue, was: %T`, instanceProfileArnAttribute))
	}

	instanceRoleArnAttribute, ok := attributes["instance_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_arn is missing from object`)

		return nil, diags
	}

	instanceRoleArnVal, ok := instanceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_arn expected to be basetypes.StringValue, was: %T`, instanceRoleArnAttribute))
	}

	instanceRoleNameAttribute, ok := attributes["instance_role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_name is missing from object`)

		return nil, diags
	}

	instanceRoleNameVal, ok := instanceRoleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_name expected to be basetypes.StringValue, was: %T`, instanceRoleNameAttribute))
	}

	instanceRolePermissionBoundaryAttribute, ok := attributes["instance_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_permission_boundary is missing from object`)

		return nil, diags
	}

	instanceRolePermissionBoundaryVal, ok := instanceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_permission_boundary expected to be basetypes.StringValue, was: %T`, instanceRolePermissionBoundaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Iam4Value{
		AttachPolicy4:                  attachPolicy4Val,
		AttachPolicyArns:               attachPolicyArnsVal,
		AttachPolicyV2:                 attachPolicyV2Val,
		IamNodeGroupWithAddonPolicies4: iamNodeGroupWithAddonPolicies4Val,
		InstanceProfileArn:             instanceProfileArnVal,
		InstanceRoleArn:                instanceRoleArnVal,
		InstanceRoleName:               instanceRoleNameVal,
		InstanceRolePermissionBoundary: instanceRolePermissionBoundaryVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam4ValueNull() Iam4Value {
	return Iam4Value{
		state: attr.ValueStateNull,
	}
}

func NewIam4ValueUnknown() Iam4Value {
	return Iam4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIam4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Iam4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Iam4Value Attribute Value",
				"While creating a Iam4Value value, a missing attribute value was detected. "+
					"A Iam4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Iam4Value Attribute Type",
				"While creating a Iam4Value value, an invalid attribute value was detected. "+
					"A Iam4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Iam4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Iam4Value Attribute Value",
				"While creating a Iam4Value value, an extra attribute value was detected. "+
					"A Iam4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Iam4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIam4ValueUnknown(), diags
	}

	attachPolicy4Attribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy4 is missing from object`)

		return NewIam4ValueUnknown(), diags
	}

	attachPolicy4Val, ok := attachPolicy4Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy4 expected to be basetypes.SetValue, was: %T`, attachPolicy4Attribute))
	}

	attachPolicyArnsAttribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns is missing from object`)

		return NewIam4ValueUnknown(), diags
	}

	attachPolicyArnsVal, ok := attachPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns expected to be basetypes.SetValue, was: %T`, attachPolicyArnsAttribute))
	}

	attachPolicyV2Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2 is missing from object`)

		return NewIam4ValueUnknown(), diags
	}

	attachPolicyV2Val, ok := attachPolicyV2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2 expected to be basetypes.StringValue, was: %T`, attachPolicyV2Attribute))
	}

	iamNodeGroupWithAddonPolicies4Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies4 is missing from object`)

		return NewIam4ValueUnknown(), diags
	}

	iamNodeGroupWithAddonPolicies4Val, ok := iamNodeGroupWithAddonPolicies4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies4 expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPolicies4Attribute))
	}

	instanceProfileArnAttribute, ok := attributes["instance_profile_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_profile_arn is missing from object`)

		return NewIam4ValueUnknown(), diags
	}

	instanceProfileArnVal, ok := instanceProfileArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_profile_arn expected to be basetypes.StringValue, was: %T`, instanceProfileArnAttribute))
	}

	instanceRoleArnAttribute, ok := attributes["instance_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_arn is missing from object`)

		return NewIam4ValueUnknown(), diags
	}

	instanceRoleArnVal, ok := instanceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_arn expected to be basetypes.StringValue, was: %T`, instanceRoleArnAttribute))
	}

	instanceRoleNameAttribute, ok := attributes["instance_role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_name is missing from object`)

		return NewIam4ValueUnknown(), diags
	}

	instanceRoleNameVal, ok := instanceRoleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_name expected to be basetypes.StringValue, was: %T`, instanceRoleNameAttribute))
	}

	instanceRolePermissionBoundaryAttribute, ok := attributes["instance_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_permission_boundary is missing from object`)

		return NewIam4ValueUnknown(), diags
	}

	instanceRolePermissionBoundaryVal, ok := instanceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_permission_boundary expected to be basetypes.StringValue, was: %T`, instanceRolePermissionBoundaryAttribute))
	}

	if diags.HasError() {
		return NewIam4ValueUnknown(), diags
	}

	return Iam4Value{
		AttachPolicy4:                  attachPolicy4Val,
		AttachPolicyArns:               attachPolicyArnsVal,
		AttachPolicyV2:                 attachPolicyV2Val,
		IamNodeGroupWithAddonPolicies4: iamNodeGroupWithAddonPolicies4Val,
		InstanceProfileArn:             instanceProfileArnVal,
		InstanceRoleArn:                instanceRoleArnVal,
		InstanceRoleName:               instanceRoleNameVal,
		InstanceRolePermissionBoundary: instanceRolePermissionBoundaryVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Iam4Value {
	object, diags := NewIam4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIam4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Iam4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIam4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIam4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIam4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIam4ValueMust(Iam4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Iam4Type) ValueType(ctx context.Context) attr.Value {
	return Iam4Value{}
}

var _ basetypes.ObjectValuable = Iam4Value{}

type Iam4Value struct {
	AttachPolicy4                  basetypes.SetValue    `tfsdk:"attach_policy"`
	AttachPolicyArns               basetypes.SetValue    `tfsdk:"attach_policy_arns"`
	AttachPolicyV2                 basetypes.StringValue `tfsdk:"attach_policy_v2"`
	IamNodeGroupWithAddonPolicies4 basetypes.ListValue   `tfsdk:"iam_node_group_with_addon_policies"`
	InstanceProfileArn             basetypes.StringValue `tfsdk:"instance_profile_arn"`
	InstanceRoleArn                basetypes.StringValue `tfsdk:"instance_role_arn"`
	InstanceRoleName               basetypes.StringValue `tfsdk:"instance_role_name"`
	InstanceRolePermissionBoundary basetypes.StringValue `tfsdk:"instance_role_permission_boundary"`
	state                          attr.ValueState
}

func (v Iam4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["attach_policy"] = basetypes.SetType{
		ElemType: AttachPolicy4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["attach_policy_arns"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["attach_policy_v2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["iam_node_group_with_addon_policies"] = basetypes.ListType{
		ElemType: IamNodeGroupWithAddonPolicies4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_profile_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_permission_boundary"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AttachPolicy4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy"] = val

		val, err = v.AttachPolicyArns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_arns"] = val

		val, err = v.AttachPolicyV2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_v2"] = val

		val, err = v.IamNodeGroupWithAddonPolicies4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_node_group_with_addon_policies"] = val

		val, err = v.InstanceProfileArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_profile_arn"] = val

		val, err = v.InstanceRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_arn"] = val

		val, err = v.InstanceRoleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_name"] = val

		val, err = v.InstanceRolePermissionBoundary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_permission_boundary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Iam4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Iam4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Iam4Value) String() string {
	return "Iam4Value"
}

func (v Iam4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attachPolicy4 := types.SetValueMust(
		AttachPolicy4Type{
			basetypes.ObjectType{
				AttrTypes: AttachPolicy4Value{}.AttributeTypes(ctx),
			},
		},
		v.AttachPolicy4.Elements(),
	)

	if v.AttachPolicy4.IsNull() {
		attachPolicy4 = types.SetNull(
			AttachPolicy4Type{
				basetypes.ObjectType{
					AttrTypes: AttachPolicy4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AttachPolicy4.IsUnknown() {
		attachPolicy4 = types.SetUnknown(
			AttachPolicy4Type{
				basetypes.ObjectType{
					AttrTypes: AttachPolicy4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	iamNodeGroupWithAddonPolicies4 := types.ListValueMust(
		IamNodeGroupWithAddonPolicies4Type{
			basetypes.ObjectType{
				AttrTypes: IamNodeGroupWithAddonPolicies4Value{}.AttributeTypes(ctx),
			},
		},
		v.IamNodeGroupWithAddonPolicies4.Elements(),
	)

	if v.IamNodeGroupWithAddonPolicies4.IsNull() {
		iamNodeGroupWithAddonPolicies4 = types.ListNull(
			IamNodeGroupWithAddonPolicies4Type{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPolicies4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IamNodeGroupWithAddonPolicies4.IsUnknown() {
		iamNodeGroupWithAddonPolicies4 = types.ListUnknown(
			IamNodeGroupWithAddonPolicies4Type{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPolicies4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var attachPolicyArnsVal basetypes.SetValue
	switch {
	case v.AttachPolicyArns.IsUnknown():
		attachPolicyArnsVal = types.SetUnknown(types.StringType)
	case v.AttachPolicyArns.IsNull():
		attachPolicyArnsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachPolicyArnsVal, d = types.SetValue(types.StringType, v.AttachPolicyArns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_policy": basetypes.SetType{
				ElemType: AttachPolicy4Value{}.Type(ctx),
			},
			"attach_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"attach_policy_v2": basetypes.StringType{},
			"iam_node_group_with_addon_policies": basetypes.ListType{
				ElemType: IamNodeGroupWithAddonPolicies4Value{}.Type(ctx),
			},
			"instance_profile_arn":              basetypes.StringType{},
			"instance_role_arn":                 basetypes.StringType{},
			"instance_role_name":                basetypes.StringType{},
			"instance_role_permission_boundary": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_policy": basetypes.SetType{
			ElemType: AttachPolicy4Value{}.Type(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2": basetypes.StringType{},
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPolicies4Value{}.Type(ctx),
		},
		"instance_profile_arn":              basetypes.StringType{},
		"instance_role_arn":                 basetypes.StringType{},
		"instance_role_name":                basetypes.StringType{},
		"instance_role_permission_boundary": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_policy":                      attachPolicy4,
			"attach_policy_arns":                 attachPolicyArnsVal,
			"attach_policy_v2":                   v.AttachPolicyV2,
			"iam_node_group_with_addon_policies": iamNodeGroupWithAddonPolicies4,
			"instance_profile_arn":               v.InstanceProfileArn,
			"instance_role_arn":                  v.InstanceRoleArn,
			"instance_role_name":                 v.InstanceRoleName,
			"instance_role_permission_boundary":  v.InstanceRolePermissionBoundary,
		})

	return objVal, diags
}

func (v Iam4Value) Equal(o attr.Value) bool {
	other, ok := o.(Iam4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachPolicy4.Equal(other.AttachPolicy4) {
		return false
	}

	if !v.AttachPolicyArns.Equal(other.AttachPolicyArns) {
		return false
	}

	if !v.AttachPolicyV2.Equal(other.AttachPolicyV2) {
		return false
	}

	if !v.IamNodeGroupWithAddonPolicies4.Equal(other.IamNodeGroupWithAddonPolicies4) {
		return false
	}

	if !v.InstanceProfileArn.Equal(other.InstanceProfileArn) {
		return false
	}

	if !v.InstanceRoleArn.Equal(other.InstanceRoleArn) {
		return false
	}

	if !v.InstanceRoleName.Equal(other.InstanceRoleName) {
		return false
	}

	if !v.InstanceRolePermissionBoundary.Equal(other.InstanceRolePermissionBoundary) {
		return false
	}

	return true
}

func (v Iam4Value) Type(ctx context.Context) attr.Type {
	return Iam4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Iam4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_policy": basetypes.SetType{
			ElemType: AttachPolicy4Value{}.Type(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2": basetypes.StringType{},
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPolicies4Value{}.Type(ctx),
		},
		"instance_profile_arn":              basetypes.StringType{},
		"instance_role_arn":                 basetypes.StringType{},
		"instance_role_name":                basetypes.StringType{},
		"instance_role_permission_boundary": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttachPolicy4Type{}

type AttachPolicy4Type struct {
	basetypes.ObjectType
}

func (t AttachPolicy4Type) Equal(o attr.Type) bool {
	other, ok := o.(AttachPolicy4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachPolicy4Type) String() string {
	return "AttachPolicy4Type"
}

func (t AttachPolicy4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statement4Attribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement4 is missing from object`)

		return nil, diags
	}

	statement4Val, ok := statement4Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement4 expected to be basetypes.SetValue, was: %T`, statement4Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachPolicy4Value{
		Id:         idVal,
		Statement4: statement4Val,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicy4ValueNull() AttachPolicy4Value {
	return AttachPolicy4Value{
		state: attr.ValueStateNull,
	}
}

func NewAttachPolicy4ValueUnknown() AttachPolicy4Value {
	return AttachPolicy4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachPolicy4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachPolicy4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachPolicy4Value Attribute Value",
				"While creating a AttachPolicy4Value value, a missing attribute value was detected. "+
					"A AttachPolicy4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicy4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachPolicy4Value Attribute Type",
				"While creating a AttachPolicy4Value value, an invalid attribute value was detected. "+
					"A AttachPolicy4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicy4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachPolicy4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachPolicy4Value Attribute Value",
				"While creating a AttachPolicy4Value value, an extra attribute value was detected. "+
					"A AttachPolicy4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachPolicy4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachPolicy4ValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewAttachPolicy4ValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statement4Attribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement4 is missing from object`)

		return NewAttachPolicy4ValueUnknown(), diags
	}

	statement4Val, ok := statement4Attribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement4 expected to be basetypes.SetValue, was: %T`, statement4Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewAttachPolicy4ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewAttachPolicy4ValueUnknown(), diags
	}

	return AttachPolicy4Value{
		Id:         idVal,
		Statement4: statement4Val,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicy4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachPolicy4Value {
	object, diags := NewAttachPolicy4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachPolicy4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachPolicy4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachPolicy4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachPolicy4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachPolicy4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachPolicy4ValueMust(AttachPolicy4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t AttachPolicy4Type) ValueType(ctx context.Context) attr.Value {
	return AttachPolicy4Value{}
}

var _ basetypes.ObjectValuable = AttachPolicy4Value{}

type AttachPolicy4Value struct {
	Id         basetypes.StringValue `tfsdk:"id"`
	Statement4 basetypes.SetValue    `tfsdk:"statement"`
	Version    basetypes.StringValue `tfsdk:"version"`
	state      attr.ValueState
}

func (v AttachPolicy4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["statement"] = basetypes.SetType{
		ElemType: Statement4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Statement4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statement"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachPolicy4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachPolicy4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachPolicy4Value) String() string {
	return "AttachPolicy4Value"
}

func (v AttachPolicy4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	statement4 := types.SetValueMust(
		Statement4Type{
			basetypes.ObjectType{
				AttrTypes: Statement4Value{}.AttributeTypes(ctx),
			},
		},
		v.Statement4.Elements(),
	)

	if v.Statement4.IsNull() {
		statement4 = types.SetNull(
			Statement4Type{
				basetypes.ObjectType{
					AttrTypes: Statement4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Statement4.IsUnknown() {
		statement4 = types.SetUnknown(
			Statement4Type{
				basetypes.ObjectType{
					AttrTypes: Statement4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: Statement4Value{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":        v.Id,
			"statement": statement4,
			"version":   v.Version,
		})

	return objVal, diags
}

func (v AttachPolicy4Value) Equal(o attr.Value) bool {
	other, ok := o.(AttachPolicy4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Statement4.Equal(other.Statement4) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v AttachPolicy4Value) Type(ctx context.Context) attr.Type {
	return AttachPolicy4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachPolicy4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: Statement4Value{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Statement4Type{}

type Statement4Type struct {
	basetypes.ObjectType
}

func (t Statement4Type) Equal(o attr.Type) bool {
	other, ok := o.(Statement4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Statement4Type) String() string {
	return "Statement4Type"
}

func (t Statement4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return nil, diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return nil, diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return nil, diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return nil, diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return nil, diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Statement4Value{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatement4ValueNull() Statement4Value {
	return Statement4Value{
		state: attr.ValueStateNull,
	}
}

func NewStatement4ValueUnknown() Statement4Value {
	return Statement4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewStatement4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Statement4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Statement4Value Attribute Value",
				"While creating a Statement4Value value, a missing attribute value was detected. "+
					"A Statement4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Statement4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Statement4Value Attribute Type",
				"While creating a Statement4Value value, an invalid attribute value was detected. "+
					"A Statement4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Statement4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Statement4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Statement4Value Attribute Value",
				"While creating a Statement4Value value, an extra attribute value was detected. "+
					"A Statement4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Statement4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatement4ValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return NewStatement4ValueUnknown(), diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return NewStatement4ValueUnknown(), diags
	}

	return Statement4Value{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatement4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Statement4Value {
	object, diags := NewStatement4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatement4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Statement4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatement4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatement4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatement4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatement4ValueMust(Statement4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Statement4Type) ValueType(ctx context.Context) attr.Value {
	return Statement4Value{}
}

var _ basetypes.ObjectValuable = Statement4Value{}

type Statement4Value struct {
	Action       basetypes.SetValue    `tfsdk:"action"`
	Condition    basetypes.StringValue `tfsdk:"condition"`
	Effect       basetypes.StringValue `tfsdk:"effect"`
	NotAction    basetypes.SetValue    `tfsdk:"not_action"`
	NotPrincipal basetypes.StringValue `tfsdk:"not_principal"`
	NotResource  basetypes.SetValue    `tfsdk:"not_resource"`
	Principal    basetypes.StringValue `tfsdk:"principal"`
	Resource     basetypes.StringValue `tfsdk:"resource"`
	Sid          basetypes.StringValue `tfsdk:"sid"`
	state        attr.ValueState
}

func (v Statement4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["not_principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_resource"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.NotAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_action"] = val

		val, err = v.NotPrincipal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_principal"] = val

		val, err = v.NotResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_resource"] = val

		val, err = v.Principal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["principal"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Sid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Statement4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Statement4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Statement4Value) String() string {
	return "Statement4Value"
}

func (v Statement4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var actionVal basetypes.SetValue
	switch {
	case v.Action.IsUnknown():
		actionVal = types.SetUnknown(types.StringType)
	case v.Action.IsNull():
		actionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		actionVal, d = types.SetValue(types.StringType, v.Action.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notActionVal basetypes.SetValue
	switch {
	case v.NotAction.IsUnknown():
		notActionVal = types.SetUnknown(types.StringType)
	case v.NotAction.IsNull():
		notActionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notActionVal, d = types.SetValue(types.StringType, v.NotAction.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notResourceVal basetypes.SetValue
	switch {
	case v.NotResource.IsUnknown():
		notResourceVal = types.SetUnknown(types.StringType)
	case v.NotResource.IsNull():
		notResourceVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notResourceVal, d = types.SetValue(types.StringType, v.NotResource.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":        actionVal,
			"condition":     v.Condition,
			"effect":        v.Effect,
			"not_action":    notActionVal,
			"not_principal": v.NotPrincipal,
			"not_resource":  notResourceVal,
			"principal":     v.Principal,
			"resource":      v.Resource,
			"sid":           v.Sid,
		})

	return objVal, diags
}

func (v Statement4Value) Equal(o attr.Value) bool {
	other, ok := o.(Statement4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.NotAction.Equal(other.NotAction) {
		return false
	}

	if !v.NotPrincipal.Equal(other.NotPrincipal) {
		return false
	}

	if !v.NotResource.Equal(other.NotResource) {
		return false
	}

	if !v.Principal.Equal(other.Principal) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Sid.Equal(other.Sid) {
		return false
	}

	return true
}

func (v Statement4Value) Type(ctx context.Context) attr.Type {
	return Statement4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Statement4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IamNodeGroupWithAddonPolicies4Type{}

type IamNodeGroupWithAddonPolicies4Type struct {
	basetypes.ObjectType
}

func (t IamNodeGroupWithAddonPolicies4Type) Equal(o attr.Type) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamNodeGroupWithAddonPolicies4Type) String() string {
	return "IamNodeGroupWithAddonPolicies4Type"
}

func (t IamNodeGroupWithAddonPolicies4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return nil, diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return nil, diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return nil, diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return nil, diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return nil, diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return nil, diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return nil, diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamNodeGroupWithAddonPolicies4Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies4ValueNull() IamNodeGroupWithAddonPolicies4Value {
	return IamNodeGroupWithAddonPolicies4Value{
		state: attr.ValueStateNull,
	}
}

func NewIamNodeGroupWithAddonPolicies4ValueUnknown() IamNodeGroupWithAddonPolicies4Value {
	return IamNodeGroupWithAddonPolicies4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIamNodeGroupWithAddonPolicies4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamNodeGroupWithAddonPolicies4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamNodeGroupWithAddonPolicies4Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies4Value value, a missing attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamNodeGroupWithAddonPolicies4Value Attribute Type",
				"While creating a IamNodeGroupWithAddonPolicies4Value value, an invalid attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamNodeGroupWithAddonPolicies4Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies4Value value, an extra attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamNodeGroupWithAddonPolicies4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), diags
	}

	return IamNodeGroupWithAddonPolicies4Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamNodeGroupWithAddonPolicies4Value {
	object, diags := NewIamNodeGroupWithAddonPolicies4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamNodeGroupWithAddonPolicies4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamNodeGroupWithAddonPolicies4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamNodeGroupWithAddonPolicies4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamNodeGroupWithAddonPolicies4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamNodeGroupWithAddonPolicies4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamNodeGroupWithAddonPolicies4ValueMust(IamNodeGroupWithAddonPolicies4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t IamNodeGroupWithAddonPolicies4Type) ValueType(ctx context.Context) attr.Value {
	return IamNodeGroupWithAddonPolicies4Value{}
}

var _ basetypes.ObjectValuable = IamNodeGroupWithAddonPolicies4Value{}

type IamNodeGroupWithAddonPolicies4Value struct {
	AlbIngress    basetypes.BoolValue `tfsdk:"alb_ingress"`
	AppMesh       basetypes.BoolValue `tfsdk:"app_mesh"`
	AppMeshReview basetypes.BoolValue `tfsdk:"app_mesh_review"`
	AutoScaler    basetypes.BoolValue `tfsdk:"auto_scaler"`
	CertManager   basetypes.BoolValue `tfsdk:"cert_manager"`
	CloudWatch    basetypes.BoolValue `tfsdk:"cloud_watch"`
	Ebs           basetypes.BoolValue `tfsdk:"ebs"`
	Efs           basetypes.BoolValue `tfsdk:"efs"`
	ExternalDns   basetypes.BoolValue `tfsdk:"external_dns"`
	Fsx           basetypes.BoolValue `tfsdk:"fsx"`
	ImageBuilder  basetypes.BoolValue `tfsdk:"image_builder"`
	Xray          basetypes.BoolValue `tfsdk:"xray"`
	state         attr.ValueState
}

func (v IamNodeGroupWithAddonPolicies4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alb_ingress"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh_review"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fsx"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xray"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AlbIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alb_ingress"] = val

		val, err = v.AppMesh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh"] = val

		val, err = v.AppMeshReview.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh_review"] = val

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.Ebs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs"] = val

		val, err = v.Efs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.Fsx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fsx"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		val, err = v.Xray.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xray"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamNodeGroupWithAddonPolicies4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamNodeGroupWithAddonPolicies4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamNodeGroupWithAddonPolicies4Value) String() string {
	return "IamNodeGroupWithAddonPolicies4Value"
}

func (v IamNodeGroupWithAddonPolicies4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alb_ingress":     v.AlbIngress,
			"app_mesh":        v.AppMesh,
			"app_mesh_review": v.AppMeshReview,
			"auto_scaler":     v.AutoScaler,
			"cert_manager":    v.CertManager,
			"cloud_watch":     v.CloudWatch,
			"ebs":             v.Ebs,
			"efs":             v.Efs,
			"external_dns":    v.ExternalDns,
			"fsx":             v.Fsx,
			"image_builder":   v.ImageBuilder,
			"xray":            v.Xray,
		})

	return objVal, diags
}

func (v IamNodeGroupWithAddonPolicies4Value) Equal(o attr.Value) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlbIngress.Equal(other.AlbIngress) {
		return false
	}

	if !v.AppMesh.Equal(other.AppMesh) {
		return false
	}

	if !v.AppMeshReview.Equal(other.AppMeshReview) {
		return false
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.Ebs.Equal(other.Ebs) {
		return false
	}

	if !v.Efs.Equal(other.Efs) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.Fsx.Equal(other.Fsx) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	if !v.Xray.Equal(other.Xray) {
		return false
	}

	return true
}

func (v IamNodeGroupWithAddonPolicies4Value) Type(ctx context.Context) attr.Type {
	return IamNodeGroupWithAddonPolicies4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamNodeGroupWithAddonPolicies4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InstanceSelector4Type{}

type InstanceSelector4Type struct {
	basetypes.ObjectType
}

func (t InstanceSelector4Type) Equal(o attr.Type) bool {
	other, ok := o.(InstanceSelector4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstanceSelector4Type) String() string {
	return "InstanceSelector4Type"
}

func (t InstanceSelector4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuArchitectureAttribute, ok := attributes["cpu_architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_architecture is missing from object`)

		return nil, diags
	}

	cpuArchitectureVal, ok := cpuArchitectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_architecture expected to be basetypes.StringValue, was: %T`, cpuArchitectureAttribute))
	}

	gpusAttribute, ok := attributes["gpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpus is missing from object`)

		return nil, diags
	}

	gpusVal, ok := gpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpus expected to be basetypes.Int64Value, was: %T`, gpusAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return nil, diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstanceSelector4Value{
		CpuArchitecture: cpuArchitectureVal,
		Gpus:            gpusVal,
		Memory:          memoryVal,
		Vcpus:           vcpusVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstanceSelector4ValueNull() InstanceSelector4Value {
	return InstanceSelector4Value{
		state: attr.ValueStateNull,
	}
}

func NewInstanceSelector4ValueUnknown() InstanceSelector4Value {
	return InstanceSelector4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewInstanceSelector4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstanceSelector4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstanceSelector4Value Attribute Value",
				"While creating a InstanceSelector4Value value, a missing attribute value was detected. "+
					"A InstanceSelector4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSelector4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstanceSelector4Value Attribute Type",
				"While creating a InstanceSelector4Value value, an invalid attribute value was detected. "+
					"A InstanceSelector4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSelector4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstanceSelector4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstanceSelector4Value Attribute Value",
				"While creating a InstanceSelector4Value value, an extra attribute value was detected. "+
					"A InstanceSelector4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstanceSelector4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstanceSelector4ValueUnknown(), diags
	}

	cpuArchitectureAttribute, ok := attributes["cpu_architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_architecture is missing from object`)

		return NewInstanceSelector4ValueUnknown(), diags
	}

	cpuArchitectureVal, ok := cpuArchitectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_architecture expected to be basetypes.StringValue, was: %T`, cpuArchitectureAttribute))
	}

	gpusAttribute, ok := attributes["gpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpus is missing from object`)

		return NewInstanceSelector4ValueUnknown(), diags
	}

	gpusVal, ok := gpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpus expected to be basetypes.Int64Value, was: %T`, gpusAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewInstanceSelector4ValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return NewInstanceSelector4ValueUnknown(), diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return NewInstanceSelector4ValueUnknown(), diags
	}

	return InstanceSelector4Value{
		CpuArchitecture: cpuArchitectureVal,
		Gpus:            gpusVal,
		Memory:          memoryVal,
		Vcpus:           vcpusVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstanceSelector4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstanceSelector4Value {
	object, diags := NewInstanceSelector4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstanceSelector4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstanceSelector4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstanceSelector4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstanceSelector4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstanceSelector4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstanceSelector4ValueMust(InstanceSelector4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t InstanceSelector4Type) ValueType(ctx context.Context) attr.Value {
	return InstanceSelector4Value{}
}

var _ basetypes.ObjectValuable = InstanceSelector4Value{}

type InstanceSelector4Value struct {
	CpuArchitecture basetypes.StringValue `tfsdk:"cpu_architecture"`
	Gpus            basetypes.Int64Value  `tfsdk:"gpus"`
	Memory          basetypes.StringValue `tfsdk:"memory"`
	Vcpus           basetypes.Int64Value  `tfsdk:"vcpus"`
	state           attr.ValueState
}

func (v InstanceSelector4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cpu_architecture"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpus"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpuArchitecture.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_architecture"] = val

		val, err = v.Gpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpus"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.Vcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpus"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstanceSelector4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstanceSelector4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstanceSelector4Value) String() string {
	return "InstanceSelector4Value"
}

func (v InstanceSelector4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_architecture": basetypes.StringType{},
		"gpus":             basetypes.Int64Type{},
		"memory":           basetypes.StringType{},
		"vcpus":            basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_architecture": v.CpuArchitecture,
			"gpus":             v.Gpus,
			"memory":           v.Memory,
			"vcpus":            v.Vcpus,
		})

	return objVal, diags
}

func (v InstanceSelector4Value) Equal(o attr.Value) bool {
	other, ok := o.(InstanceSelector4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuArchitecture.Equal(other.CpuArchitecture) {
		return false
	}

	if !v.Gpus.Equal(other.Gpus) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.Vcpus.Equal(other.Vcpus) {
		return false
	}

	return true
}

func (v InstanceSelector4Value) Type(ctx context.Context) attr.Type {
	return InstanceSelector4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstanceSelector4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_architecture": basetypes.StringType{},
		"gpus":             basetypes.Int64Type{},
		"memory":           basetypes.StringType{},
		"vcpus":            basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LaunchTemplate4Type{}

type LaunchTemplate4Type struct {
	basetypes.ObjectType
}

func (t LaunchTemplate4Type) Equal(o attr.Type) bool {
	other, ok := o.(LaunchTemplate4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LaunchTemplate4Type) String() string {
	return "LaunchTemplate4Type"
}

func (t LaunchTemplate4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LaunchTemplate4Value{
		Id:      idVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLaunchTemplate4ValueNull() LaunchTemplate4Value {
	return LaunchTemplate4Value{
		state: attr.ValueStateNull,
	}
}

func NewLaunchTemplate4ValueUnknown() LaunchTemplate4Value {
	return LaunchTemplate4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewLaunchTemplate4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LaunchTemplate4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LaunchTemplate4Value Attribute Value",
				"While creating a LaunchTemplate4Value value, a missing attribute value was detected. "+
					"A LaunchTemplate4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LaunchTemplate4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LaunchTemplate4Value Attribute Type",
				"While creating a LaunchTemplate4Value value, an invalid attribute value was detected. "+
					"A LaunchTemplate4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LaunchTemplate4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LaunchTemplate4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LaunchTemplate4Value Attribute Value",
				"While creating a LaunchTemplate4Value value, an extra attribute value was detected. "+
					"A LaunchTemplate4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LaunchTemplate4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLaunchTemplate4ValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewLaunchTemplate4ValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewLaunchTemplate4ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewLaunchTemplate4ValueUnknown(), diags
	}

	return LaunchTemplate4Value{
		Id:      idVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLaunchTemplate4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LaunchTemplate4Value {
	object, diags := NewLaunchTemplate4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLaunchTemplate4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LaunchTemplate4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLaunchTemplate4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLaunchTemplate4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLaunchTemplate4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLaunchTemplate4ValueMust(LaunchTemplate4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t LaunchTemplate4Type) ValueType(ctx context.Context) attr.Value {
	return LaunchTemplate4Value{}
}

var _ basetypes.ObjectValuable = LaunchTemplate4Value{}

type LaunchTemplate4Value struct {
	Id      basetypes.StringValue `tfsdk:"id"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v LaunchTemplate4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LaunchTemplate4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LaunchTemplate4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LaunchTemplate4Value) String() string {
	return "LaunchTemplate4Value"
}

func (v LaunchTemplate4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":      basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":      v.Id,
			"version": v.Version,
		})

	return objVal, diags
}

func (v LaunchTemplate4Value) Equal(o attr.Value) bool {
	other, ok := o.(LaunchTemplate4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v LaunchTemplate4Value) Type(ctx context.Context) attr.Type {
	return LaunchTemplate4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LaunchTemplate4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":      basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodeRepairConfig4Type{}

type NodeRepairConfig4Type struct {
	basetypes.ObjectType
}

func (t NodeRepairConfig4Type) Equal(o attr.Type) bool {
	other, ok := o.(NodeRepairConfig4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeRepairConfig4Type) String() string {
	return "NodeRepairConfig4Type"
}

func (t NodeRepairConfig4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeRepairConfig4Value{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNodeRepairConfig4ValueNull() NodeRepairConfig4Value {
	return NodeRepairConfig4Value{
		state: attr.ValueStateNull,
	}
}

func NewNodeRepairConfig4ValueUnknown() NodeRepairConfig4Value {
	return NodeRepairConfig4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeRepairConfig4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeRepairConfig4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeRepairConfig4Value Attribute Value",
				"While creating a NodeRepairConfig4Value value, a missing attribute value was detected. "+
					"A NodeRepairConfig4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeRepairConfig4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeRepairConfig4Value Attribute Type",
				"While creating a NodeRepairConfig4Value value, an invalid attribute value was detected. "+
					"A NodeRepairConfig4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeRepairConfig4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeRepairConfig4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeRepairConfig4Value Attribute Value",
				"While creating a NodeRepairConfig4Value value, an extra attribute value was detected. "+
					"A NodeRepairConfig4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeRepairConfig4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeRepairConfig4ValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewNodeRepairConfig4ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewNodeRepairConfig4ValueUnknown(), diags
	}

	return NodeRepairConfig4Value{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNodeRepairConfig4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeRepairConfig4Value {
	object, diags := NewNodeRepairConfig4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeRepairConfig4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeRepairConfig4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeRepairConfig4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeRepairConfig4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeRepairConfig4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeRepairConfig4ValueMust(NodeRepairConfig4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeRepairConfig4Type) ValueType(ctx context.Context) attr.Value {
	return NodeRepairConfig4Value{}
}

var _ basetypes.ObjectValuable = NodeRepairConfig4Value{}

type NodeRepairConfig4Value struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v NodeRepairConfig4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeRepairConfig4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeRepairConfig4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeRepairConfig4Value) String() string {
	return "NodeRepairConfig4Value"
}

func (v NodeRepairConfig4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v NodeRepairConfig4Value) Equal(o attr.Value) bool {
	other, ok := o.(NodeRepairConfig4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v NodeRepairConfig4Value) Type(ctx context.Context) attr.Type {
	return NodeRepairConfig4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeRepairConfig4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Placement4Type{}

type Placement4Type struct {
	basetypes.ObjectType
}

func (t Placement4Type) Equal(o attr.Type) bool {
	other, ok := o.(Placement4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Placement4Type) String() string {
	return "Placement4Type"
}

func (t Placement4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Placement4Value{
		Group: groupVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlacement4ValueNull() Placement4Value {
	return Placement4Value{
		state: attr.ValueStateNull,
	}
}

func NewPlacement4ValueUnknown() Placement4Value {
	return Placement4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPlacement4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Placement4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Placement4Value Attribute Value",
				"While creating a Placement4Value value, a missing attribute value was detected. "+
					"A Placement4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Placement4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Placement4Value Attribute Type",
				"While creating a Placement4Value value, an invalid attribute value was detected. "+
					"A Placement4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Placement4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Placement4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Placement4Value Attribute Value",
				"While creating a Placement4Value value, an extra attribute value was detected. "+
					"A Placement4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Placement4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlacement4ValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewPlacement4ValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	if diags.HasError() {
		return NewPlacement4ValueUnknown(), diags
	}

	return Placement4Value{
		Group: groupVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlacement4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Placement4Value {
	object, diags := NewPlacement4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlacement4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Placement4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlacement4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlacement4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlacement4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlacement4ValueMust(Placement4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Placement4Type) ValueType(ctx context.Context) attr.Value {
	return Placement4Value{}
}

var _ basetypes.ObjectValuable = Placement4Value{}

type Placement4Value struct {
	Group basetypes.StringValue `tfsdk:"group"`
	state attr.ValueState
}

func (v Placement4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Placement4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Placement4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Placement4Value) String() string {
	return "Placement4Value"
}

func (v Placement4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group": v.Group,
		})

	return objVal, diags
}

func (v Placement4Value) Equal(o attr.Value) bool {
	other, ok := o.(Placement4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	return true
}

func (v Placement4Value) Type(ctx context.Context) attr.Type {
	return Placement4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Placement4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroups4Type{}

type SecurityGroups4Type struct {
	basetypes.ObjectType
}

func (t SecurityGroups4Type) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroups4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroups4Type) String() string {
	return "SecurityGroups4Type"
}

func (t SecurityGroups4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachIdsAttribute, ok := attributes["attach_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_ids is missing from object`)

		return nil, diags
	}

	attachIdsVal, ok := attachIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_ids expected to be basetypes.ListValue, was: %T`, attachIdsAttribute))
	}

	withLocalAttribute, ok := attributes["with_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_local is missing from object`)

		return nil, diags
	}

	withLocalVal, ok := withLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_local expected to be basetypes.BoolValue, was: %T`, withLocalAttribute))
	}

	withSharedAttribute, ok := attributes["with_shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_shared is missing from object`)

		return nil, diags
	}

	withSharedVal, ok := withSharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_shared expected to be basetypes.BoolValue, was: %T`, withSharedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroups4Value{
		AttachIds:  attachIdsVal,
		WithLocal:  withLocalVal,
		WithShared: withSharedVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroups4ValueNull() SecurityGroups4Value {
	return SecurityGroups4Value{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroups4ValueUnknown() SecurityGroups4Value {
	return SecurityGroups4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroups4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroups4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroups4Value Attribute Value",
				"While creating a SecurityGroups4Value value, a missing attribute value was detected. "+
					"A SecurityGroups4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroups4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroups4Value Attribute Type",
				"While creating a SecurityGroups4Value value, an invalid attribute value was detected. "+
					"A SecurityGroups4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroups4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroups4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroups4Value Attribute Value",
				"While creating a SecurityGroups4Value value, an extra attribute value was detected. "+
					"A SecurityGroups4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroups4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroups4ValueUnknown(), diags
	}

	attachIdsAttribute, ok := attributes["attach_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_ids is missing from object`)

		return NewSecurityGroups4ValueUnknown(), diags
	}

	attachIdsVal, ok := attachIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_ids expected to be basetypes.ListValue, was: %T`, attachIdsAttribute))
	}

	withLocalAttribute, ok := attributes["with_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_local is missing from object`)

		return NewSecurityGroups4ValueUnknown(), diags
	}

	withLocalVal, ok := withLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_local expected to be basetypes.BoolValue, was: %T`, withLocalAttribute))
	}

	withSharedAttribute, ok := attributes["with_shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_shared is missing from object`)

		return NewSecurityGroups4ValueUnknown(), diags
	}

	withSharedVal, ok := withSharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_shared expected to be basetypes.BoolValue, was: %T`, withSharedAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroups4ValueUnknown(), diags
	}

	return SecurityGroups4Value{
		AttachIds:  attachIdsVal,
		WithLocal:  withLocalVal,
		WithShared: withSharedVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroups4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroups4Value {
	object, diags := NewSecurityGroups4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroups4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroups4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroups4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroups4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroups4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroups4ValueMust(SecurityGroups4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroups4Type) ValueType(ctx context.Context) attr.Value {
	return SecurityGroups4Value{}
}

var _ basetypes.ObjectValuable = SecurityGroups4Value{}

type SecurityGroups4Value struct {
	AttachIds  basetypes.ListValue `tfsdk:"attach_ids"`
	WithLocal  basetypes.BoolValue `tfsdk:"with_local"`
	WithShared basetypes.BoolValue `tfsdk:"with_shared"`
	state      attr.ValueState
}

func (v SecurityGroups4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["attach_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["with_local"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["with_shared"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AttachIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_ids"] = val

		val, err = v.WithLocal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_local"] = val

		val, err = v.WithShared.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_shared"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroups4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroups4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroups4Value) String() string {
	return "SecurityGroups4Value"
}

func (v SecurityGroups4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attachIdsVal basetypes.ListValue
	switch {
	case v.AttachIds.IsUnknown():
		attachIdsVal = types.ListUnknown(types.StringType)
	case v.AttachIds.IsNull():
		attachIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachIdsVal, d = types.ListValue(types.StringType, v.AttachIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"with_local":  basetypes.BoolType{},
			"with_shared": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"with_local":  basetypes.BoolType{},
		"with_shared": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_ids":  attachIdsVal,
			"with_local":  v.WithLocal,
			"with_shared": v.WithShared,
		})

	return objVal, diags
}

func (v SecurityGroups4Value) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroups4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachIds.Equal(other.AttachIds) {
		return false
	}

	if !v.WithLocal.Equal(other.WithLocal) {
		return false
	}

	if !v.WithShared.Equal(other.WithShared) {
		return false
	}

	return true
}

func (v SecurityGroups4Value) Type(ctx context.Context) attr.Type {
	return SecurityGroups4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroups4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"with_local":  basetypes.BoolType{},
		"with_shared": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ssh4Type{}

type Ssh4Type struct {
	basetypes.ObjectType
}

func (t Ssh4Type) Equal(o attr.Type) bool {
	other, ok := o.(Ssh4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ssh4Type) String() string {
	return "Ssh4Type"
}

func (t Ssh4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return nil, diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	enableSsmAttribute, ok := attributes["enable_ssm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ssm is missing from object`)

		return nil, diags
	}

	enableSsmVal, ok := enableSsmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ssm expected to be basetypes.BoolValue, was: %T`, enableSsmAttribute))
	}

	publicKeyAttribute, ok := attributes["public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key is missing from object`)

		return nil, diags
	}

	publicKeyVal, ok := publicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key expected to be basetypes.StringValue, was: %T`, publicKeyAttribute))
	}

	publicKeyNameAttribute, ok := attributes["public_key_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key_name is missing from object`)

		return nil, diags
	}

	publicKeyNameVal, ok := publicKeyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key_name expected to be basetypes.StringValue, was: %T`, publicKeyNameAttribute))
	}

	sourceSecurityGroupIdsAttribute, ok := attributes["source_security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_security_group_ids is missing from object`)

		return nil, diags
	}

	sourceSecurityGroupIdsVal, ok := sourceSecurityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_security_group_ids expected to be basetypes.ListValue, was: %T`, sourceSecurityGroupIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ssh4Value{
		Allow:                  allowVal,
		EnableSsm:              enableSsmVal,
		PublicKey:              publicKeyVal,
		PublicKeyName:          publicKeyNameVal,
		SourceSecurityGroupIds: sourceSecurityGroupIdsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSsh4ValueNull() Ssh4Value {
	return Ssh4Value{
		state: attr.ValueStateNull,
	}
}

func NewSsh4ValueUnknown() Ssh4Value {
	return Ssh4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSsh4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ssh4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ssh4Value Attribute Value",
				"While creating a Ssh4Value value, a missing attribute value was detected. "+
					"A Ssh4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ssh4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ssh4Value Attribute Type",
				"While creating a Ssh4Value value, an invalid attribute value was detected. "+
					"A Ssh4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ssh4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ssh4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ssh4Value Attribute Value",
				"While creating a Ssh4Value value, an extra attribute value was detected. "+
					"A Ssh4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ssh4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSsh4ValueUnknown(), diags
	}

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return NewSsh4ValueUnknown(), diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	enableSsmAttribute, ok := attributes["enable_ssm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ssm is missing from object`)

		return NewSsh4ValueUnknown(), diags
	}

	enableSsmVal, ok := enableSsmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ssm expected to be basetypes.BoolValue, was: %T`, enableSsmAttribute))
	}

	publicKeyAttribute, ok := attributes["public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key is missing from object`)

		return NewSsh4ValueUnknown(), diags
	}

	publicKeyVal, ok := publicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key expected to be basetypes.StringValue, was: %T`, publicKeyAttribute))
	}

	publicKeyNameAttribute, ok := attributes["public_key_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key_name is missing from object`)

		return NewSsh4ValueUnknown(), diags
	}

	publicKeyNameVal, ok := publicKeyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key_name expected to be basetypes.StringValue, was: %T`, publicKeyNameAttribute))
	}

	sourceSecurityGroupIdsAttribute, ok := attributes["source_security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_security_group_ids is missing from object`)

		return NewSsh4ValueUnknown(), diags
	}

	sourceSecurityGroupIdsVal, ok := sourceSecurityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_security_group_ids expected to be basetypes.ListValue, was: %T`, sourceSecurityGroupIdsAttribute))
	}

	if diags.HasError() {
		return NewSsh4ValueUnknown(), diags
	}

	return Ssh4Value{
		Allow:                  allowVal,
		EnableSsm:              enableSsmVal,
		PublicKey:              publicKeyVal,
		PublicKeyName:          publicKeyNameVal,
		SourceSecurityGroupIds: sourceSecurityGroupIdsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSsh4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ssh4Value {
	object, diags := NewSsh4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSsh4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ssh4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSsh4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSsh4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSsh4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSsh4ValueMust(Ssh4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ssh4Type) ValueType(ctx context.Context) attr.Value {
	return Ssh4Value{}
}

var _ basetypes.ObjectValuable = Ssh4Value{}

type Ssh4Value struct {
	Allow                  basetypes.BoolValue   `tfsdk:"allow"`
	EnableSsm              basetypes.BoolValue   `tfsdk:"enable_ssm"`
	PublicKey              basetypes.StringValue `tfsdk:"public_key"`
	PublicKeyName          basetypes.StringValue `tfsdk:"public_key_name"`
	SourceSecurityGroupIds basetypes.ListValue   `tfsdk:"source_security_group_ids"`
	state                  attr.ValueState
}

func (v Ssh4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["allow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_ssm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["public_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["public_key_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_security_group_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Allow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow"] = val

		val, err = v.EnableSsm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ssm"] = val

		val, err = v.PublicKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_key"] = val

		val, err = v.PublicKeyName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_key_name"] = val

		val, err = v.SourceSecurityGroupIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_security_group_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ssh4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ssh4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ssh4Value) String() string {
	return "Ssh4Value"
}

func (v Ssh4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceSecurityGroupIdsVal basetypes.ListValue
	switch {
	case v.SourceSecurityGroupIds.IsUnknown():
		sourceSecurityGroupIdsVal = types.ListUnknown(types.StringType)
	case v.SourceSecurityGroupIds.IsNull():
		sourceSecurityGroupIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		sourceSecurityGroupIdsVal, d = types.ListValue(types.StringType, v.SourceSecurityGroupIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow":           basetypes.BoolType{},
			"enable_ssm":      basetypes.BoolType{},
			"public_key":      basetypes.StringType{},
			"public_key_name": basetypes.StringType{},
			"source_security_group_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow":           basetypes.BoolType{},
		"enable_ssm":      basetypes.BoolType{},
		"public_key":      basetypes.StringType{},
		"public_key_name": basetypes.StringType{},
		"source_security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow":                     v.Allow,
			"enable_ssm":                v.EnableSsm,
			"public_key":                v.PublicKey,
			"public_key_name":           v.PublicKeyName,
			"source_security_group_ids": sourceSecurityGroupIdsVal,
		})

	return objVal, diags
}

func (v Ssh4Value) Equal(o attr.Value) bool {
	other, ok := o.(Ssh4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Allow.Equal(other.Allow) {
		return false
	}

	if !v.EnableSsm.Equal(other.EnableSsm) {
		return false
	}

	if !v.PublicKey.Equal(other.PublicKey) {
		return false
	}

	if !v.PublicKeyName.Equal(other.PublicKeyName) {
		return false
	}

	if !v.SourceSecurityGroupIds.Equal(other.SourceSecurityGroupIds) {
		return false
	}

	return true
}

func (v Ssh4Value) Type(ctx context.Context) attr.Type {
	return Ssh4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ssh4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow":           basetypes.BoolType{},
		"enable_ssm":      basetypes.BoolType{},
		"public_key":      basetypes.StringType{},
		"public_key_name": basetypes.StringType{},
		"source_security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Taints4Type{}

type Taints4Type struct {
	basetypes.ObjectType
}

func (t Taints4Type) Equal(o attr.Type) bool {
	other, ok := o.(Taints4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Taints4Type) String() string {
	return "Taints4Type"
}

func (t Taints4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Taints4Value{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaints4ValueNull() Taints4Value {
	return Taints4Value{
		state: attr.ValueStateNull,
	}
}

func NewTaints4ValueUnknown() Taints4Value {
	return Taints4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTaints4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Taints4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Taints4Value Attribute Value",
				"While creating a Taints4Value value, a missing attribute value was detected. "+
					"A Taints4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Taints4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Taints4Value Attribute Type",
				"While creating a Taints4Value value, an invalid attribute value was detected. "+
					"A Taints4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Taints4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Taints4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Taints4Value Attribute Value",
				"While creating a Taints4Value value, an extra attribute value was detected. "+
					"A Taints4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Taints4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaints4ValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTaints4ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTaints4ValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTaints4ValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTaints4ValueUnknown(), diags
	}

	return Taints4Value{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaints4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Taints4Value {
	object, diags := NewTaints4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaints4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Taints4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaints4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaints4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaints4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaints4ValueMust(Taints4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Taints4Type) ValueType(ctx context.Context) attr.Value {
	return Taints4Value{}
}

var _ basetypes.ObjectValuable = Taints4Value{}

type Taints4Value struct {
	Effect basetypes.StringValue `tfsdk:"effect"`
	Key    basetypes.StringValue `tfsdk:"key"`
	Value  basetypes.StringValue `tfsdk:"value"`
	state  attr.ValueState
}

func (v Taints4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Taints4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Taints4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Taints4Value) String() string {
	return "Taints4Value"
}

func (v Taints4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect": v.Effect,
			"key":    v.Key,
			"value":  v.Value,
		})

	return objVal, diags
}

func (v Taints4Value) Equal(o attr.Value) bool {
	other, ok := o.(Taints4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v Taints4Value) Type(ctx context.Context) attr.Type {
	return Taints4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Taints4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = UpdateConfig4Type{}

type UpdateConfig4Type struct {
	basetypes.ObjectType
}

func (t UpdateConfig4Type) Equal(o attr.Type) bool {
	other, ok := o.(UpdateConfig4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UpdateConfig4Type) String() string {
	return "UpdateConfig4Type"
}

func (t UpdateConfig4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxUnavailableAttribute, ok := attributes["max_unavailable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable is missing from object`)

		return nil, diags
	}

	maxUnavailableVal, ok := maxUnavailableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable expected to be basetypes.Int64Value, was: %T`, maxUnavailableAttribute))
	}

	maxUnavailablePercentageAttribute, ok := attributes["max_unavailable_percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable_percentage is missing from object`)

		return nil, diags
	}

	maxUnavailablePercentageVal, ok := maxUnavailablePercentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable_percentage expected to be basetypes.Int64Value, was: %T`, maxUnavailablePercentageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UpdateConfig4Value{
		MaxUnavailable:           maxUnavailableVal,
		MaxUnavailablePercentage: maxUnavailablePercentageVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewUpdateConfig4ValueNull() UpdateConfig4Value {
	return UpdateConfig4Value{
		state: attr.ValueStateNull,
	}
}

func NewUpdateConfig4ValueUnknown() UpdateConfig4Value {
	return UpdateConfig4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewUpdateConfig4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UpdateConfig4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UpdateConfig4Value Attribute Value",
				"While creating a UpdateConfig4Value value, a missing attribute value was detected. "+
					"A UpdateConfig4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UpdateConfig4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UpdateConfig4Value Attribute Type",
				"While creating a UpdateConfig4Value value, an invalid attribute value was detected. "+
					"A UpdateConfig4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UpdateConfig4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UpdateConfig4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UpdateConfig4Value Attribute Value",
				"While creating a UpdateConfig4Value value, an extra attribute value was detected. "+
					"A UpdateConfig4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UpdateConfig4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUpdateConfig4ValueUnknown(), diags
	}

	maxUnavailableAttribute, ok := attributes["max_unavailable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable is missing from object`)

		return NewUpdateConfig4ValueUnknown(), diags
	}

	maxUnavailableVal, ok := maxUnavailableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable expected to be basetypes.Int64Value, was: %T`, maxUnavailableAttribute))
	}

	maxUnavailablePercentageAttribute, ok := attributes["max_unavailable_percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable_percentage is missing from object`)

		return NewUpdateConfig4ValueUnknown(), diags
	}

	maxUnavailablePercentageVal, ok := maxUnavailablePercentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable_percentage expected to be basetypes.Int64Value, was: %T`, maxUnavailablePercentageAttribute))
	}

	if diags.HasError() {
		return NewUpdateConfig4ValueUnknown(), diags
	}

	return UpdateConfig4Value{
		MaxUnavailable:           maxUnavailableVal,
		MaxUnavailablePercentage: maxUnavailablePercentageVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewUpdateConfig4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UpdateConfig4Value {
	object, diags := NewUpdateConfig4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUpdateConfig4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UpdateConfig4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUpdateConfig4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUpdateConfig4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUpdateConfig4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUpdateConfig4ValueMust(UpdateConfig4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t UpdateConfig4Type) ValueType(ctx context.Context) attr.Value {
	return UpdateConfig4Value{}
}

var _ basetypes.ObjectValuable = UpdateConfig4Value{}

type UpdateConfig4Value struct {
	MaxUnavailable           basetypes.Int64Value `tfsdk:"max_unavailable"`
	MaxUnavailablePercentage basetypes.Int64Value `tfsdk:"max_unavailable_percentage"`
	state                    attr.ValueState
}

func (v UpdateConfig4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["max_unavailable"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_unavailable_percentage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MaxUnavailable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavailable"] = val

		val, err = v.MaxUnavailablePercentage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavailable_percentage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UpdateConfig4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UpdateConfig4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UpdateConfig4Value) String() string {
	return "UpdateConfig4Value"
}

func (v UpdateConfig4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_unavailable":            basetypes.Int64Type{},
		"max_unavailable_percentage": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_unavailable":            v.MaxUnavailable,
			"max_unavailable_percentage": v.MaxUnavailablePercentage,
		})

	return objVal, diags
}

func (v UpdateConfig4Value) Equal(o attr.Value) bool {
	other, ok := o.(UpdateConfig4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxUnavailable.Equal(other.MaxUnavailable) {
		return false
	}

	if !v.MaxUnavailablePercentage.Equal(other.MaxUnavailablePercentage) {
		return false
	}

	return true
}

func (v UpdateConfig4Value) Type(ctx context.Context) attr.Type {
	return UpdateConfig4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UpdateConfig4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_unavailable":            basetypes.Int64Type{},
		"max_unavailable_percentage": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Metadata2Type{}

type Metadata2Type struct {
	basetypes.ObjectType
}

func (t Metadata2Type) Equal(o attr.Type) bool {
	other, ok := o.(Metadata2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Metadata2Type) String() string {
	return "Metadata2Type"
}

func (t Metadata2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Metadata2Value{
		Annotations: annotationsVal,
		Name:        nameVal,
		Region:      regionVal,
		Tags:        tagsVal,
		Version:     versionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadata2ValueNull() Metadata2Value {
	return Metadata2Value{
		state: attr.ValueStateNull,
	}
}

func NewMetadata2ValueUnknown() Metadata2Value {
	return Metadata2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadata2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Metadata2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Metadata2Value Attribute Value",
				"While creating a Metadata2Value value, a missing attribute value was detected. "+
					"A Metadata2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Metadata2Value Attribute Type",
				"While creating a Metadata2Value value, an invalid attribute value was detected. "+
					"A Metadata2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Metadata2Value Attribute Value",
				"While creating a Metadata2Value value, an extra attribute value was detected. "+
					"A Metadata2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Metadata2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadata2ValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewMetadata2ValueUnknown(), diags
	}

	return Metadata2Value{
		Annotations: annotationsVal,
		Name:        nameVal,
		Region:      regionVal,
		Tags:        tagsVal,
		Version:     versionVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadata2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Metadata2Value {
	object, diags := NewMetadata2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadata2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Metadata2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadata2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadata2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadata2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadata2ValueMust(Metadata2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Metadata2Type) ValueType(ctx context.Context) attr.Value {
	return Metadata2Value{}
}

var _ basetypes.ObjectValuable = Metadata2Value{}

type Metadata2Value struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Region      basetypes.StringValue `tfsdk:"region"`
	Tags        basetypes.MapValue    `tfsdk:"tags"`
	Version     basetypes.StringValue `tfsdk:"version"`
	state       attr.ValueState
}

func (v Metadata2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Metadata2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Metadata2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Metadata2Value) String() string {
	return "Metadata2Value"
}

func (v Metadata2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":   basetypes.StringType{},
			"region": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"version": basetypes.StringType{},
		}), diags
	}

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":   basetypes.StringType{},
			"region": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"version": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":   basetypes.StringType{},
		"region": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"name":        v.Name,
			"region":      v.Region,
			"tags":        tagsVal,
			"version":     v.Version,
		})

	return objVal, diags
}

func (v Metadata2Value) Equal(o attr.Value) bool {
	other, ok := o.(Metadata2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v Metadata2Value) Type(ctx context.Context) attr.Type {
	return Metadata2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Metadata2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":   basetypes.StringType{},
		"region": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodeGroupsType{}

type NodeGroupsType struct {
	basetypes.ObjectType
}

func (t NodeGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(NodeGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeGroupsType) String() string {
	return "NodeGroupsType"
}

func (t NodeGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return nil, diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return nil, diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	asgMetricsCollectionAttribute, ok := attributes["asg_metrics_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_metrics_collection is missing from object`)

		return nil, diags
	}

	asgMetricsCollectionVal, ok := asgMetricsCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_metrics_collection expected to be basetypes.ListValue, was: %T`, asgMetricsCollectionAttribute))
	}

	asgSuspendProcessesAttribute, ok := attributes["asg_suspend_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_suspend_processes is missing from object`)

		return nil, diags
	}

	asgSuspendProcessesVal, ok := asgSuspendProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_suspend_processes expected to be basetypes.ListValue, was: %T`, asgSuspendProcessesAttribute))
	}

	availabilityZonesAttribute, ok := attributes["availability_zones"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones is missing from object`)

		return nil, diags
	}

	availabilityZonesVal, ok := availabilityZonesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones expected to be basetypes.ListValue, was: %T`, availabilityZonesAttribute))
	}

	bottleRocketAttribute, ok := attributes["bottle_rocket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bottle_rocket is missing from object`)

		return nil, diags
	}

	bottleRocketVal, ok := bottleRocketAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bottle_rocket expected to be basetypes.ListValue, was: %T`, bottleRocketAttribute))
	}

	classicLoadBalancerNamesAttribute, ok := attributes["classic_load_balancer_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`classic_load_balancer_names is missing from object`)

		return nil, diags
	}

	classicLoadBalancerNamesVal, ok := classicLoadBalancerNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`classic_load_balancer_names expected to be basetypes.ListValue, was: %T`, classicLoadBalancerNamesAttribute))
	}

	clusterDnsAttribute, ok := attributes["cluster_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_dns is missing from object`)

		return nil, diags
	}

	clusterDnsVal, ok := clusterDnsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_dns expected to be basetypes.StringValue, was: %T`, clusterDnsAttribute))
	}

	cpuCreditsAttribute, ok := attributes["cpu_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_credits is missing from object`)

		return nil, diags
	}

	cpuCreditsVal, ok := cpuCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_credits expected to be basetypes.StringValue, was: %T`, cpuCreditsAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return nil, diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return nil, diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return nil, diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	ebsOptimizedAttribute, ok := attributes["ebs_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_optimized is missing from object`)

		return nil, diags
	}

	ebsOptimizedVal, ok := ebsOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_optimized expected to be basetypes.BoolValue, was: %T`, ebsOptimizedAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return nil, diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	enableDetailedMonitoringAttribute, ok := attributes["enable_detailed_monitoring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_detailed_monitoring is missing from object`)

		return nil, diags
	}

	enableDetailedMonitoringVal, ok := enableDetailedMonitoringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_detailed_monitoring expected to be basetypes.BoolValue, was: %T`, enableDetailedMonitoringAttribute))
	}

	iamAttribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam is missing from object`)

		return nil, diags
	}

	iamVal, ok := iamAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam expected to be basetypes.ListValue, was: %T`, iamAttribute))
	}

	instanceNameAttribute, ok := attributes["instance_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_name is missing from object`)

		return nil, diags
	}

	instanceNameVal, ok := instanceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_name expected to be basetypes.StringValue, was: %T`, instanceNameAttribute))
	}

	instancePrefixAttribute, ok := attributes["instance_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_prefix is missing from object`)

		return nil, diags
	}

	instancePrefixVal, ok := instancePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_prefix expected to be basetypes.StringValue, was: %T`, instancePrefixAttribute))
	}

	instanceSelectorAttribute, ok := attributes["instance_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_selector is missing from object`)

		return nil, diags
	}

	instanceSelectorVal, ok := instanceSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_selector expected to be basetypes.ListValue, was: %T`, instanceSelectorAttribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return nil, diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	instancesDistributionAttribute, ok := attributes["instances_distribution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instances_distribution is missing from object`)

		return nil, diags
	}

	instancesDistributionVal, ok := instancesDistributionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instances_distribution expected to be basetypes.ListValue, was: %T`, instancesDistributionAttribute))
	}

	kubeletExtraConfigAttribute, ok := attributes["kubelet_extra_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubelet_extra_config is missing from object`)

		return nil, diags
	}

	kubeletExtraConfigVal, ok := kubeletExtraConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubelet_extra_config expected to be basetypes.ListValue, was: %T`, kubeletExtraConfigAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return nil, diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	overrideBootstrapCommandAttribute, ok := attributes["override_bootstrap_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_bootstrap_command is missing from object`)

		return nil, diags
	}

	overrideBootstrapCommandVal, ok := overrideBootstrapCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_bootstrap_command expected to be basetypes.StringValue, was: %T`, overrideBootstrapCommandAttribute))
	}

	placementAttribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement is missing from object`)

		return nil, diags
	}

	placementVal, ok := placementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement expected to be basetypes.ListValue, was: %T`, placementAttribute))
	}

	preBootstrapCommandsAttribute, ok := attributes["pre_bootstrap_commands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_bootstrap_commands is missing from object`)

		return nil, diags
	}

	preBootstrapCommandsVal, ok := preBootstrapCommandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_bootstrap_commands expected to be basetypes.ListValue, was: %T`, preBootstrapCommandsAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return nil, diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	sshAttribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh is missing from object`)

		return nil, diags
	}

	sshVal, ok := sshAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh expected to be basetypes.ListValue, was: %T`, sshAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.SetValue, was: %T`, subnetsAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	taintsAttribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints is missing from object`)

		return nil, diags
	}

	taintsVal, ok := taintsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints expected to be basetypes.SetValue, was: %T`, taintsAttribute))
	}

	targetGroupArnsAttribute, ok := attributes["target_group_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_group_arns is missing from object`)

		return nil, diags
	}

	targetGroupArnsVal, ok := targetGroupArnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_group_arns expected to be basetypes.ListValue, was: %T`, targetGroupArnsAttribute))
	}

	updateConfigAttribute, ok := attributes["update_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update_config is missing from object`)

		return nil, diags
	}

	updateConfigVal, ok := updateConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update_config expected to be basetypes.ListValue, was: %T`, updateConfigAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return nil, diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return nil, diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeKmsKeyIdAttribute, ok := attributes["volume_kms_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_kms_key_id is missing from object`)

		return nil, diags
	}

	volumeKmsKeyIdVal, ok := volumeKmsKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_kms_key_id expected to be basetypes.StringValue, was: %T`, volumeKmsKeyIdAttribute))
	}

	volumeNameAttribute, ok := attributes["volume_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_name is missing from object`)

		return nil, diags
	}

	volumeNameVal, ok := volumeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_name expected to be basetypes.StringValue, was: %T`, volumeNameAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return nil, diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeGroupsValue{
		Ami:                      amiVal,
		AmiFamily:                amiFamilyVal,
		AsgMetricsCollection:     asgMetricsCollectionVal,
		AsgSuspendProcesses:      asgSuspendProcessesVal,
		AvailabilityZones:        availabilityZonesVal,
		BottleRocket:             bottleRocketVal,
		ClassicLoadBalancerNames: classicLoadBalancerNamesVal,
		ClusterDns:               clusterDnsVal,
		CpuCredits:               cpuCreditsVal,
		DesiredCapacity:          desiredCapacityVal,
		DisableImdsv1:            disableImdsv1Val,
		DisablePodsImds:          disablePodsImdsVal,
		EbsOptimized:             ebsOptimizedVal,
		EfaEnabled:               efaEnabledVal,
		EnableDetailedMonitoring: enableDetailedMonitoringVal,
		Iam:                      iamVal,
		InstanceName:             instanceNameVal,
		InstancePrefix:           instancePrefixVal,
		InstanceSelector:         instanceSelectorVal,
		InstanceType:             instanceTypeVal,
		InstancesDistribution:    instancesDistributionVal,
		KubeletExtraConfig:       kubeletExtraConfigVal,
		Labels:                   labelsVal,
		MaxPodsPerNode:           maxPodsPerNodeVal,
		MaxSize:                  maxSizeVal,
		MinSize:                  minSizeVal,
		Name:                     nameVal,
		OverrideBootstrapCommand: overrideBootstrapCommandVal,
		Placement:                placementVal,
		PreBootstrapCommands:     preBootstrapCommandsVal,
		PrivateNetworking:        privateNetworkingVal,
		SecurityGroups:           securityGroupsVal,
		Ssh:                      sshVal,
		SubnetCidr:               subnetCidrVal,
		Subnets:                  subnetsVal,
		Tags:                     tagsVal,
		Taints:                   taintsVal,
		TargetGroupArns:          targetGroupArnsVal,
		UpdateConfig:             updateConfigVal,
		Version:                  versionVal,
		VolumeEncrypted:          volumeEncryptedVal,
		VolumeIops:               volumeIopsVal,
		VolumeKmsKeyId:           volumeKmsKeyIdVal,
		VolumeName:               volumeNameVal,
		VolumeSize:               volumeSizeVal,
		VolumeThroughput:         volumeThroughputVal,
		VolumeType:               volumeTypeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsValueNull() NodeGroupsValue {
	return NodeGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeGroupsValueUnknown() NodeGroupsValue {
	return NodeGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeGroupsValue Attribute Value",
				"While creating a NodeGroupsValue value, a missing attribute value was detected. "+
					"A NodeGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeGroupsValue Attribute Type",
				"While creating a NodeGroupsValue value, an invalid attribute value was detected. "+
					"A NodeGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeGroupsValue Attribute Value",
				"While creating a NodeGroupsValue value, an extra attribute value was detected. "+
					"A NodeGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeGroupsValueUnknown(), diags
	}

	amiAttribute, ok := attributes["ami"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	amiVal, ok := amiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami expected to be basetypes.StringValue, was: %T`, amiAttribute))
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	asgMetricsCollectionAttribute, ok := attributes["asg_metrics_collection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_metrics_collection is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	asgMetricsCollectionVal, ok := asgMetricsCollectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_metrics_collection expected to be basetypes.ListValue, was: %T`, asgMetricsCollectionAttribute))
	}

	asgSuspendProcessesAttribute, ok := attributes["asg_suspend_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asg_suspend_processes is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	asgSuspendProcessesVal, ok := asgSuspendProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asg_suspend_processes expected to be basetypes.ListValue, was: %T`, asgSuspendProcessesAttribute))
	}

	availabilityZonesAttribute, ok := attributes["availability_zones"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zones is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	availabilityZonesVal, ok := availabilityZonesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zones expected to be basetypes.ListValue, was: %T`, availabilityZonesAttribute))
	}

	bottleRocketAttribute, ok := attributes["bottle_rocket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bottle_rocket is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	bottleRocketVal, ok := bottleRocketAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bottle_rocket expected to be basetypes.ListValue, was: %T`, bottleRocketAttribute))
	}

	classicLoadBalancerNamesAttribute, ok := attributes["classic_load_balancer_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`classic_load_balancer_names is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	classicLoadBalancerNamesVal, ok := classicLoadBalancerNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`classic_load_balancer_names expected to be basetypes.ListValue, was: %T`, classicLoadBalancerNamesAttribute))
	}

	clusterDnsAttribute, ok := attributes["cluster_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_dns is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	clusterDnsVal, ok := clusterDnsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_dns expected to be basetypes.StringValue, was: %T`, clusterDnsAttribute))
	}

	cpuCreditsAttribute, ok := attributes["cpu_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_credits is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	cpuCreditsVal, ok := cpuCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_credits expected to be basetypes.StringValue, was: %T`, cpuCreditsAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	ebsOptimizedAttribute, ok := attributes["ebs_optimized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs_optimized is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	ebsOptimizedVal, ok := ebsOptimizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs_optimized expected to be basetypes.BoolValue, was: %T`, ebsOptimizedAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	enableDetailedMonitoringAttribute, ok := attributes["enable_detailed_monitoring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_detailed_monitoring is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	enableDetailedMonitoringVal, ok := enableDetailedMonitoringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_detailed_monitoring expected to be basetypes.BoolValue, was: %T`, enableDetailedMonitoringAttribute))
	}

	iamAttribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	iamVal, ok := iamAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam expected to be basetypes.ListValue, was: %T`, iamAttribute))
	}

	instanceNameAttribute, ok := attributes["instance_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_name is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	instanceNameVal, ok := instanceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_name expected to be basetypes.StringValue, was: %T`, instanceNameAttribute))
	}

	instancePrefixAttribute, ok := attributes["instance_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_prefix is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	instancePrefixVal, ok := instancePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_prefix expected to be basetypes.StringValue, was: %T`, instancePrefixAttribute))
	}

	instanceSelectorAttribute, ok := attributes["instance_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_selector is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	instanceSelectorVal, ok := instanceSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_selector expected to be basetypes.ListValue, was: %T`, instanceSelectorAttribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	instancesDistributionAttribute, ok := attributes["instances_distribution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instances_distribution is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	instancesDistributionVal, ok := instancesDistributionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instances_distribution expected to be basetypes.ListValue, was: %T`, instancesDistributionAttribute))
	}

	kubeletExtraConfigAttribute, ok := attributes["kubelet_extra_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubelet_extra_config is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	kubeletExtraConfigVal, ok := kubeletExtraConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubelet_extra_config expected to be basetypes.ListValue, was: %T`, kubeletExtraConfigAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	overrideBootstrapCommandAttribute, ok := attributes["override_bootstrap_command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`override_bootstrap_command is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	overrideBootstrapCommandVal, ok := overrideBootstrapCommandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`override_bootstrap_command expected to be basetypes.StringValue, was: %T`, overrideBootstrapCommandAttribute))
	}

	placementAttribute, ok := attributes["placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`placement is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	placementVal, ok := placementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`placement expected to be basetypes.ListValue, was: %T`, placementAttribute))
	}

	preBootstrapCommandsAttribute, ok := attributes["pre_bootstrap_commands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_bootstrap_commands is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	preBootstrapCommandsVal, ok := preBootstrapCommandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_bootstrap_commands expected to be basetypes.ListValue, was: %T`, preBootstrapCommandsAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	sshAttribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	sshVal, ok := sshAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh expected to be basetypes.ListValue, was: %T`, sshAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.SetValue, was: %T`, subnetsAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	taintsAttribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	taintsVal, ok := taintsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints expected to be basetypes.SetValue, was: %T`, taintsAttribute))
	}

	targetGroupArnsAttribute, ok := attributes["target_group_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_group_arns is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	targetGroupArnsVal, ok := targetGroupArnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_group_arns expected to be basetypes.ListValue, was: %T`, targetGroupArnsAttribute))
	}

	updateConfigAttribute, ok := attributes["update_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update_config is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	updateConfigVal, ok := updateConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update_config expected to be basetypes.ListValue, was: %T`, updateConfigAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeKmsKeyIdAttribute, ok := attributes["volume_kms_key_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_kms_key_id is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeKmsKeyIdVal, ok := volumeKmsKeyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_kms_key_id expected to be basetypes.StringValue, was: %T`, volumeKmsKeyIdAttribute))
	}

	volumeNameAttribute, ok := attributes["volume_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_name is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeNameVal, ok := volumeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_name expected to be basetypes.StringValue, was: %T`, volumeNameAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewNodeGroupsValueUnknown(), diags
	}

	return NodeGroupsValue{
		Ami:                      amiVal,
		AmiFamily:                amiFamilyVal,
		AsgMetricsCollection:     asgMetricsCollectionVal,
		AsgSuspendProcesses:      asgSuspendProcessesVal,
		AvailabilityZones:        availabilityZonesVal,
		BottleRocket:             bottleRocketVal,
		ClassicLoadBalancerNames: classicLoadBalancerNamesVal,
		ClusterDns:               clusterDnsVal,
		CpuCredits:               cpuCreditsVal,
		DesiredCapacity:          desiredCapacityVal,
		DisableImdsv1:            disableImdsv1Val,
		DisablePodsImds:          disablePodsImdsVal,
		EbsOptimized:             ebsOptimizedVal,
		EfaEnabled:               efaEnabledVal,
		EnableDetailedMonitoring: enableDetailedMonitoringVal,
		Iam:                      iamVal,
		InstanceName:             instanceNameVal,
		InstancePrefix:           instancePrefixVal,
		InstanceSelector:         instanceSelectorVal,
		InstanceType:             instanceTypeVal,
		InstancesDistribution:    instancesDistributionVal,
		KubeletExtraConfig:       kubeletExtraConfigVal,
		Labels:                   labelsVal,
		MaxPodsPerNode:           maxPodsPerNodeVal,
		MaxSize:                  maxSizeVal,
		MinSize:                  minSizeVal,
		Name:                     nameVal,
		OverrideBootstrapCommand: overrideBootstrapCommandVal,
		Placement:                placementVal,
		PreBootstrapCommands:     preBootstrapCommandsVal,
		PrivateNetworking:        privateNetworkingVal,
		SecurityGroups:           securityGroupsVal,
		Ssh:                      sshVal,
		SubnetCidr:               subnetCidrVal,
		Subnets:                  subnetsVal,
		Tags:                     tagsVal,
		Taints:                   taintsVal,
		TargetGroupArns:          targetGroupArnsVal,
		UpdateConfig:             updateConfigVal,
		Version:                  versionVal,
		VolumeEncrypted:          volumeEncryptedVal,
		VolumeIops:               volumeIopsVal,
		VolumeKmsKeyId:           volumeKmsKeyIdVal,
		VolumeName:               volumeNameVal,
		VolumeSize:               volumeSizeVal,
		VolumeThroughput:         volumeThroughputVal,
		VolumeType:               volumeTypeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeGroupsValue {
	object, diags := NewNodeGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeGroupsValueMust(NodeGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeGroupsType) ValueType(ctx context.Context) attr.Value {
	return NodeGroupsValue{}
}

var _ basetypes.ObjectValuable = NodeGroupsValue{}

type NodeGroupsValue struct {
	Ami                      basetypes.StringValue `tfsdk:"ami"`
	AmiFamily                basetypes.StringValue `tfsdk:"ami_family"`
	AsgMetricsCollection     basetypes.ListValue   `tfsdk:"asg_metrics_collection"`
	AsgSuspendProcesses      basetypes.ListValue   `tfsdk:"asg_suspend_processes"`
	AvailabilityZones        basetypes.ListValue   `tfsdk:"availability_zones"`
	BottleRocket             basetypes.ListValue   `tfsdk:"bottle_rocket"`
	ClassicLoadBalancerNames basetypes.ListValue   `tfsdk:"classic_load_balancer_names"`
	ClusterDns               basetypes.StringValue `tfsdk:"cluster_dns"`
	CpuCredits               basetypes.StringValue `tfsdk:"cpu_credits"`
	DesiredCapacity          basetypes.Int64Value  `tfsdk:"desired_capacity"`
	DisableImdsv1            basetypes.BoolValue   `tfsdk:"disable_imdsv1"`
	DisablePodsImds          basetypes.BoolValue   `tfsdk:"disable_pods_imds"`
	EbsOptimized             basetypes.BoolValue   `tfsdk:"ebs_optimized"`
	EfaEnabled               basetypes.BoolValue   `tfsdk:"efa_enabled"`
	EnableDetailedMonitoring basetypes.BoolValue   `tfsdk:"enable_detailed_monitoring"`
	Iam                      basetypes.ListValue   `tfsdk:"iam"`
	InstanceName             basetypes.StringValue `tfsdk:"instance_name"`
	InstancePrefix           basetypes.StringValue `tfsdk:"instance_prefix"`
	InstanceSelector         basetypes.ListValue   `tfsdk:"instance_selector"`
	InstanceType             basetypes.StringValue `tfsdk:"instance_type"`
	InstancesDistribution    basetypes.ListValue   `tfsdk:"instances_distribution"`
	KubeletExtraConfig       basetypes.ListValue   `tfsdk:"kubelet_extra_config"`
	Labels                   basetypes.MapValue    `tfsdk:"labels"`
	MaxPodsPerNode           basetypes.Int64Value  `tfsdk:"max_pods_per_node"`
	MaxSize                  basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize                  basetypes.Int64Value  `tfsdk:"min_size"`
	Name                     basetypes.StringValue `tfsdk:"name"`
	OverrideBootstrapCommand basetypes.StringValue `tfsdk:"override_bootstrap_command"`
	Placement                basetypes.ListValue   `tfsdk:"placement"`
	PreBootstrapCommands     basetypes.ListValue   `tfsdk:"pre_bootstrap_commands"`
	PrivateNetworking        basetypes.BoolValue   `tfsdk:"private_networking"`
	SecurityGroups           basetypes.ListValue   `tfsdk:"security_groups"`
	Ssh                      basetypes.ListValue   `tfsdk:"ssh"`
	SubnetCidr               basetypes.StringValue `tfsdk:"subnet_cidr"`
	Subnets                  basetypes.SetValue    `tfsdk:"subnets"`
	Tags                     basetypes.MapValue    `tfsdk:"tags"`
	Taints                   basetypes.SetValue    `tfsdk:"taints"`
	TargetGroupArns          basetypes.ListValue   `tfsdk:"target_group_arns"`
	UpdateConfig             basetypes.ListValue   `tfsdk:"update_config"`
	Version                  basetypes.StringValue `tfsdk:"version"`
	VolumeEncrypted          basetypes.BoolValue   `tfsdk:"volume_encrypted"`
	VolumeIops               basetypes.Int64Value  `tfsdk:"volume_iops"`
	VolumeKmsKeyId           basetypes.StringValue `tfsdk:"volume_kms_key_id"`
	VolumeName               basetypes.StringValue `tfsdk:"volume_name"`
	VolumeSize               basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeThroughput         basetypes.Int64Value  `tfsdk:"volume_throughput"`
	VolumeType               basetypes.StringValue `tfsdk:"volume_type"`
	state                    attr.ValueState
}

func (v NodeGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 47)

	var val tftypes.Value
	var err error

	attrTypes["ami"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ami_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["asg_metrics_collection"] = basetypes.ListType{
		ElemType: AsgMetricsCollectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["asg_suspend_processes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["availability_zones"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["bottle_rocket"] = basetypes.ListType{
		ElemType: BottleRocketValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["classic_load_balancer_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["cluster_dns"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpu_credits"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["desired_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_imdsv1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_pods_imds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs_optimized"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_detailed_monitoring"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ListType{
		ElemType: IamValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_selector"] = basetypes.ListType{
		ElemType: InstanceSelectorValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instances_distribution"] = basetypes.ListType{
		ElemType: InstancesDistributionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["kubelet_extra_config"] = basetypes.ListType{
		ElemType: KubeletExtraConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["max_pods_per_node"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["override_bootstrap_command"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["placement"] = basetypes.ListType{
		ElemType: PlacementValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["pre_bootstrap_commands"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["private_networking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ssh"] = basetypes.ListType{
		ElemType: SshValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["taints"] = basetypes.SetType{
		ElemType: TaintsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["target_group_arns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["update_config"] = basetypes.ListType{
		ElemType: UpdateConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_encrypted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["volume_iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_kms_key_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_throughput"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 47)

		val, err = v.Ami.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami"] = val

		val, err = v.AmiFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami_family"] = val

		val, err = v.AsgMetricsCollection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asg_metrics_collection"] = val

		val, err = v.AsgSuspendProcesses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asg_suspend_processes"] = val

		val, err = v.AvailabilityZones.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["availability_zones"] = val

		val, err = v.BottleRocket.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bottle_rocket"] = val

		val, err = v.ClassicLoadBalancerNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["classic_load_balancer_names"] = val

		val, err = v.ClusterDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_dns"] = val

		val, err = v.CpuCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_credits"] = val

		val, err = v.DesiredCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_capacity"] = val

		val, err = v.DisableImdsv1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_imdsv1"] = val

		val, err = v.DisablePodsImds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_pods_imds"] = val

		val, err = v.EbsOptimized.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs_optimized"] = val

		val, err = v.EfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efa_enabled"] = val

		val, err = v.EnableDetailedMonitoring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_detailed_monitoring"] = val

		val, err = v.Iam.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.InstanceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_name"] = val

		val, err = v.InstancePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_prefix"] = val

		val, err = v.InstanceSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_selector"] = val

		val, err = v.InstanceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_type"] = val

		val, err = v.InstancesDistribution.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instances_distribution"] = val

		val, err = v.KubeletExtraConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubelet_extra_config"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.MaxPodsPerNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pods_per_node"] = val

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OverrideBootstrapCommand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["override_bootstrap_command"] = val

		val, err = v.Placement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["placement"] = val

		val, err = v.PreBootstrapCommands.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pre_bootstrap_commands"] = val

		val, err = v.PrivateNetworking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_networking"] = val

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Ssh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Taints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taints"] = val

		val, err = v.TargetGroupArns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_group_arns"] = val

		val, err = v.UpdateConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["update_config"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VolumeEncrypted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_encrypted"] = val

		val, err = v.VolumeIops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_iops"] = val

		val, err = v.VolumeKmsKeyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_kms_key_id"] = val

		val, err = v.VolumeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_name"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeThroughput.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_throughput"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeGroupsValue) String() string {
	return "NodeGroupsValue"
}

func (v NodeGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	asgMetricsCollection := types.ListValueMust(
		AsgMetricsCollectionType{
			basetypes.ObjectType{
				AttrTypes: AsgMetricsCollectionValue{}.AttributeTypes(ctx),
			},
		},
		v.AsgMetricsCollection.Elements(),
	)

	if v.AsgMetricsCollection.IsNull() {
		asgMetricsCollection = types.ListNull(
			AsgMetricsCollectionType{
				basetypes.ObjectType{
					AttrTypes: AsgMetricsCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AsgMetricsCollection.IsUnknown() {
		asgMetricsCollection = types.ListUnknown(
			AsgMetricsCollectionType{
				basetypes.ObjectType{
					AttrTypes: AsgMetricsCollectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	bottleRocket := types.ListValueMust(
		BottleRocketType{
			basetypes.ObjectType{
				AttrTypes: BottleRocketValue{}.AttributeTypes(ctx),
			},
		},
		v.BottleRocket.Elements(),
	)

	if v.BottleRocket.IsNull() {
		bottleRocket = types.ListNull(
			BottleRocketType{
				basetypes.ObjectType{
					AttrTypes: BottleRocketValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BottleRocket.IsUnknown() {
		bottleRocket = types.ListUnknown(
			BottleRocketType{
				basetypes.ObjectType{
					AttrTypes: BottleRocketValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	iam := types.ListValueMust(
		IamType{
			basetypes.ObjectType{
				AttrTypes: IamValue{}.AttributeTypes(ctx),
			},
		},
		v.Iam.Elements(),
	)

	if v.Iam.IsNull() {
		iam = types.ListNull(
			IamType{
				basetypes.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Iam.IsUnknown() {
		iam = types.ListUnknown(
			IamType{
				basetypes.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	instanceSelector := types.ListValueMust(
		InstanceSelectorType{
			basetypes.ObjectType{
				AttrTypes: InstanceSelectorValue{}.AttributeTypes(ctx),
			},
		},
		v.InstanceSelector.Elements(),
	)

	if v.InstanceSelector.IsNull() {
		instanceSelector = types.ListNull(
			InstanceSelectorType{
				basetypes.ObjectType{
					AttrTypes: InstanceSelectorValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InstanceSelector.IsUnknown() {
		instanceSelector = types.ListUnknown(
			InstanceSelectorType{
				basetypes.ObjectType{
					AttrTypes: InstanceSelectorValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	instancesDistribution := types.ListValueMust(
		InstancesDistributionType{
			basetypes.ObjectType{
				AttrTypes: InstancesDistributionValue{}.AttributeTypes(ctx),
			},
		},
		v.InstancesDistribution.Elements(),
	)

	if v.InstancesDistribution.IsNull() {
		instancesDistribution = types.ListNull(
			InstancesDistributionType{
				basetypes.ObjectType{
					AttrTypes: InstancesDistributionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InstancesDistribution.IsUnknown() {
		instancesDistribution = types.ListUnknown(
			InstancesDistributionType{
				basetypes.ObjectType{
					AttrTypes: InstancesDistributionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	kubeletExtraConfig := types.ListValueMust(
		KubeletExtraConfigType{
			basetypes.ObjectType{
				AttrTypes: KubeletExtraConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.KubeletExtraConfig.Elements(),
	)

	if v.KubeletExtraConfig.IsNull() {
		kubeletExtraConfig = types.ListNull(
			KubeletExtraConfigType{
				basetypes.ObjectType{
					AttrTypes: KubeletExtraConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.KubeletExtraConfig.IsUnknown() {
		kubeletExtraConfig = types.ListUnknown(
			KubeletExtraConfigType{
				basetypes.ObjectType{
					AttrTypes: KubeletExtraConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	placement := types.ListValueMust(
		PlacementType{
			basetypes.ObjectType{
				AttrTypes: PlacementValue{}.AttributeTypes(ctx),
			},
		},
		v.Placement.Elements(),
	)

	if v.Placement.IsNull() {
		placement = types.ListNull(
			PlacementType{
				basetypes.ObjectType{
					AttrTypes: PlacementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Placement.IsUnknown() {
		placement = types.ListUnknown(
			PlacementType{
				basetypes.ObjectType{
					AttrTypes: PlacementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroups := types.ListValueMust(
		SecurityGroupsType{
			basetypes.ObjectType{
				AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups.Elements(),
	)

	if v.SecurityGroups.IsNull() {
		securityGroups = types.ListNull(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups.IsUnknown() {
		securityGroups = types.ListUnknown(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ssh := types.ListValueMust(
		SshType{
			basetypes.ObjectType{
				AttrTypes: SshValue{}.AttributeTypes(ctx),
			},
		},
		v.Ssh.Elements(),
	)

	if v.Ssh.IsNull() {
		ssh = types.ListNull(
			SshType{
				basetypes.ObjectType{
					AttrTypes: SshValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ssh.IsUnknown() {
		ssh = types.ListUnknown(
			SshType{
				basetypes.ObjectType{
					AttrTypes: SshValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	taints := types.SetValueMust(
		TaintsType{
			basetypes.ObjectType{
				AttrTypes: TaintsValue{}.AttributeTypes(ctx),
			},
		},
		v.Taints.Elements(),
	)

	if v.Taints.IsNull() {
		taints = types.SetNull(
			TaintsType{
				basetypes.ObjectType{
					AttrTypes: TaintsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taints.IsUnknown() {
		taints = types.SetUnknown(
			TaintsType{
				basetypes.ObjectType{
					AttrTypes: TaintsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	updateConfig := types.ListValueMust(
		UpdateConfigType{
			basetypes.ObjectType{
				AttrTypes: UpdateConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.UpdateConfig.Elements(),
	)

	if v.UpdateConfig.IsNull() {
		updateConfig = types.ListNull(
			UpdateConfigType{
				basetypes.ObjectType{
					AttrTypes: UpdateConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.UpdateConfig.IsUnknown() {
		updateConfig = types.ListUnknown(
			UpdateConfigType{
				basetypes.ObjectType{
					AttrTypes: UpdateConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var asgSuspendProcessesVal basetypes.ListValue
	switch {
	case v.AsgSuspendProcesses.IsUnknown():
		asgSuspendProcessesVal = types.ListUnknown(types.StringType)
	case v.AsgSuspendProcesses.IsNull():
		asgSuspendProcessesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		asgSuspendProcessesVal, d = types.ListValue(types.StringType, v.AsgSuspendProcesses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection": basetypes.ListType{
				ElemType: AsgMetricsCollectionValue{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocketValue{}.Type(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: IamValue{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelectorValue{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ListType{
				ElemType: InstancesDistributionValue{}.Type(ctx),
			},
			"kubelet_extra_config": basetypes.ListType{
				ElemType: KubeletExtraConfigValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"name":                       basetypes.StringType{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: PlacementValue{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"ssh": basetypes.ListType{
				ElemType: SshValue{}.Type(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfigValue{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var availabilityZonesVal basetypes.ListValue
	switch {
	case v.AvailabilityZones.IsUnknown():
		availabilityZonesVal = types.ListUnknown(types.StringType)
	case v.AvailabilityZones.IsNull():
		availabilityZonesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		availabilityZonesVal, d = types.ListValue(types.StringType, v.AvailabilityZones.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection": basetypes.ListType{
				ElemType: AsgMetricsCollectionValue{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocketValue{}.Type(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: IamValue{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelectorValue{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ListType{
				ElemType: InstancesDistributionValue{}.Type(ctx),
			},
			"kubelet_extra_config": basetypes.ListType{
				ElemType: KubeletExtraConfigValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"name":                       basetypes.StringType{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: PlacementValue{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"ssh": basetypes.ListType{
				ElemType: SshValue{}.Type(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfigValue{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var classicLoadBalancerNamesVal basetypes.ListValue
	switch {
	case v.ClassicLoadBalancerNames.IsUnknown():
		classicLoadBalancerNamesVal = types.ListUnknown(types.StringType)
	case v.ClassicLoadBalancerNames.IsNull():
		classicLoadBalancerNamesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		classicLoadBalancerNamesVal, d = types.ListValue(types.StringType, v.ClassicLoadBalancerNames.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection": basetypes.ListType{
				ElemType: AsgMetricsCollectionValue{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocketValue{}.Type(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: IamValue{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelectorValue{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ListType{
				ElemType: InstancesDistributionValue{}.Type(ctx),
			},
			"kubelet_extra_config": basetypes.ListType{
				ElemType: KubeletExtraConfigValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"name":                       basetypes.StringType{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: PlacementValue{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"ssh": basetypes.ListType{
				ElemType: SshValue{}.Type(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfigValue{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection": basetypes.ListType{
				ElemType: AsgMetricsCollectionValue{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocketValue{}.Type(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: IamValue{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelectorValue{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ListType{
				ElemType: InstancesDistributionValue{}.Type(ctx),
			},
			"kubelet_extra_config": basetypes.ListType{
				ElemType: KubeletExtraConfigValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"name":                       basetypes.StringType{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: PlacementValue{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"ssh": basetypes.ListType{
				ElemType: SshValue{}.Type(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfigValue{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var preBootstrapCommandsVal basetypes.ListValue
	switch {
	case v.PreBootstrapCommands.IsUnknown():
		preBootstrapCommandsVal = types.ListUnknown(types.StringType)
	case v.PreBootstrapCommands.IsNull():
		preBootstrapCommandsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		preBootstrapCommandsVal, d = types.ListValue(types.StringType, v.PreBootstrapCommands.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection": basetypes.ListType{
				ElemType: AsgMetricsCollectionValue{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocketValue{}.Type(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: IamValue{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelectorValue{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ListType{
				ElemType: InstancesDistributionValue{}.Type(ctx),
			},
			"kubelet_extra_config": basetypes.ListType{
				ElemType: KubeletExtraConfigValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"name":                       basetypes.StringType{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: PlacementValue{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"ssh": basetypes.ListType{
				ElemType: SshValue{}.Type(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfigValue{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var subnetsVal basetypes.SetValue
	switch {
	case v.Subnets.IsUnknown():
		subnetsVal = types.SetUnknown(types.StringType)
	case v.Subnets.IsNull():
		subnetsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		subnetsVal, d = types.SetValue(types.StringType, v.Subnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection": basetypes.ListType{
				ElemType: AsgMetricsCollectionValue{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocketValue{}.Type(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: IamValue{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelectorValue{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ListType{
				ElemType: InstancesDistributionValue{}.Type(ctx),
			},
			"kubelet_extra_config": basetypes.ListType{
				ElemType: KubeletExtraConfigValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"name":                       basetypes.StringType{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: PlacementValue{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"ssh": basetypes.ListType{
				ElemType: SshValue{}.Type(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfigValue{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection": basetypes.ListType{
				ElemType: AsgMetricsCollectionValue{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocketValue{}.Type(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: IamValue{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelectorValue{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ListType{
				ElemType: InstancesDistributionValue{}.Type(ctx),
			},
			"kubelet_extra_config": basetypes.ListType{
				ElemType: KubeletExtraConfigValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"name":                       basetypes.StringType{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: PlacementValue{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"ssh": basetypes.ListType{
				ElemType: SshValue{}.Type(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfigValue{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	var targetGroupArnsVal basetypes.ListValue
	switch {
	case v.TargetGroupArns.IsUnknown():
		targetGroupArnsVal = types.ListUnknown(types.StringType)
	case v.TargetGroupArns.IsNull():
		targetGroupArnsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		targetGroupArnsVal, d = types.ListValue(types.StringType, v.TargetGroupArns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ami":        basetypes.StringType{},
			"ami_family": basetypes.StringType{},
			"asg_metrics_collection": basetypes.ListType{
				ElemType: AsgMetricsCollectionValue{}.Type(ctx),
			},
			"asg_suspend_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"availability_zones": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bottle_rocket": basetypes.ListType{
				ElemType: BottleRocketValue{}.Type(ctx),
			},
			"classic_load_balancer_names": basetypes.ListType{
				ElemType: types.StringType,
			},
			"cluster_dns":                basetypes.StringType{},
			"cpu_credits":                basetypes.StringType{},
			"desired_capacity":           basetypes.Int64Type{},
			"disable_imdsv1":             basetypes.BoolType{},
			"disable_pods_imds":          basetypes.BoolType{},
			"ebs_optimized":              basetypes.BoolType{},
			"efa_enabled":                basetypes.BoolType{},
			"enable_detailed_monitoring": basetypes.BoolType{},
			"iam": basetypes.ListType{
				ElemType: IamValue{}.Type(ctx),
			},
			"instance_name":   basetypes.StringType{},
			"instance_prefix": basetypes.StringType{},
			"instance_selector": basetypes.ListType{
				ElemType: InstanceSelectorValue{}.Type(ctx),
			},
			"instance_type": basetypes.StringType{},
			"instances_distribution": basetypes.ListType{
				ElemType: InstancesDistributionValue{}.Type(ctx),
			},
			"kubelet_extra_config": basetypes.ListType{
				ElemType: KubeletExtraConfigValue{}.Type(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"max_pods_per_node":          basetypes.Int64Type{},
			"max_size":                   basetypes.Int64Type{},
			"min_size":                   basetypes.Int64Type{},
			"name":                       basetypes.StringType{},
			"override_bootstrap_command": basetypes.StringType{},
			"placement": basetypes.ListType{
				ElemType: PlacementValue{}.Type(ctx),
			},
			"pre_bootstrap_commands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_networking": basetypes.BoolType{},
			"security_groups": basetypes.ListType{
				ElemType: SecurityGroupsValue{}.Type(ctx),
			},
			"ssh": basetypes.ListType{
				ElemType: SshValue{}.Type(ctx),
			},
			"subnet_cidr": basetypes.StringType{},
			"subnets": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
			"target_group_arns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"update_config": basetypes.ListType{
				ElemType: UpdateConfigValue{}.Type(ctx),
			},
			"version":           basetypes.StringType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_iops":       basetypes.Int64Type{},
			"volume_kms_key_id": basetypes.StringType{},
			"volume_name":       basetypes.StringType{},
			"volume_size":       basetypes.Int64Type{},
			"volume_throughput": basetypes.Int64Type{},
			"volume_type":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ami":        basetypes.StringType{},
		"ami_family": basetypes.StringType{},
		"asg_metrics_collection": basetypes.ListType{
			ElemType: AsgMetricsCollectionValue{}.Type(ctx),
		},
		"asg_suspend_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"availability_zones": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bottle_rocket": basetypes.ListType{
			ElemType: BottleRocketValue{}.Type(ctx),
		},
		"classic_load_balancer_names": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cluster_dns":                basetypes.StringType{},
		"cpu_credits":                basetypes.StringType{},
		"desired_capacity":           basetypes.Int64Type{},
		"disable_imdsv1":             basetypes.BoolType{},
		"disable_pods_imds":          basetypes.BoolType{},
		"ebs_optimized":              basetypes.BoolType{},
		"efa_enabled":                basetypes.BoolType{},
		"enable_detailed_monitoring": basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: IamValue{}.Type(ctx),
		},
		"instance_name":   basetypes.StringType{},
		"instance_prefix": basetypes.StringType{},
		"instance_selector": basetypes.ListType{
			ElemType: InstanceSelectorValue{}.Type(ctx),
		},
		"instance_type": basetypes.StringType{},
		"instances_distribution": basetypes.ListType{
			ElemType: InstancesDistributionValue{}.Type(ctx),
		},
		"kubelet_extra_config": basetypes.ListType{
			ElemType: KubeletExtraConfigValue{}.Type(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"max_pods_per_node":          basetypes.Int64Type{},
		"max_size":                   basetypes.Int64Type{},
		"min_size":                   basetypes.Int64Type{},
		"name":                       basetypes.StringType{},
		"override_bootstrap_command": basetypes.StringType{},
		"placement": basetypes.ListType{
			ElemType: PlacementValue{}.Type(ctx),
		},
		"pre_bootstrap_commands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_networking": basetypes.BoolType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"ssh": basetypes.ListType{
			ElemType: SshValue{}.Type(ctx),
		},
		"subnet_cidr": basetypes.StringType{},
		"subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"taints": basetypes.SetType{
			ElemType: TaintsValue{}.Type(ctx),
		},
		"target_group_arns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"update_config": basetypes.ListType{
			ElemType: UpdateConfigValue{}.Type(ctx),
		},
		"version":           basetypes.StringType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_iops":       basetypes.Int64Type{},
		"volume_kms_key_id": basetypes.StringType{},
		"volume_name":       basetypes.StringType{},
		"volume_size":       basetypes.Int64Type{},
		"volume_throughput": basetypes.Int64Type{},
		"volume_type":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ami":                         v.Ami,
			"ami_family":                  v.AmiFamily,
			"asg_metrics_collection":      asgMetricsCollection,
			"asg_suspend_processes":       asgSuspendProcessesVal,
			"availability_zones":          availabilityZonesVal,
			"bottle_rocket":               bottleRocket,
			"classic_load_balancer_names": classicLoadBalancerNamesVal,
			"cluster_dns":                 v.ClusterDns,
			"cpu_credits":                 v.CpuCredits,
			"desired_capacity":            v.DesiredCapacity,
			"disable_imdsv1":              v.DisableImdsv1,
			"disable_pods_imds":           v.DisablePodsImds,
			"ebs_optimized":               v.EbsOptimized,
			"efa_enabled":                 v.EfaEnabled,
			"enable_detailed_monitoring":  v.EnableDetailedMonitoring,
			"iam":                         iam,
			"instance_name":               v.InstanceName,
			"instance_prefix":             v.InstancePrefix,
			"instance_selector":           instanceSelector,
			"instance_type":               v.InstanceType,
			"instances_distribution":      instancesDistribution,
			"kubelet_extra_config":        kubeletExtraConfig,
			"labels":                      labelsVal,
			"max_pods_per_node":           v.MaxPodsPerNode,
			"max_size":                    v.MaxSize,
			"min_size":                    v.MinSize,
			"name":                        v.Name,
			"override_bootstrap_command":  v.OverrideBootstrapCommand,
			"placement":                   placement,
			"pre_bootstrap_commands":      preBootstrapCommandsVal,
			"private_networking":          v.PrivateNetworking,
			"security_groups":             securityGroups,
			"ssh":                         ssh,
			"subnet_cidr":                 v.SubnetCidr,
			"subnets":                     subnetsVal,
			"tags":                        tagsVal,
			"taints":                      taints,
			"target_group_arns":           targetGroupArnsVal,
			"update_config":               updateConfig,
			"version":                     v.Version,
			"volume_encrypted":            v.VolumeEncrypted,
			"volume_iops":                 v.VolumeIops,
			"volume_kms_key_id":           v.VolumeKmsKeyId,
			"volume_name":                 v.VolumeName,
			"volume_size":                 v.VolumeSize,
			"volume_throughput":           v.VolumeThroughput,
			"volume_type":                 v.VolumeType,
		})

	return objVal, diags
}

func (v NodeGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ami.Equal(other.Ami) {
		return false
	}

	if !v.AmiFamily.Equal(other.AmiFamily) {
		return false
	}

	if !v.AsgMetricsCollection.Equal(other.AsgMetricsCollection) {
		return false
	}

	if !v.AsgSuspendProcesses.Equal(other.AsgSuspendProcesses) {
		return false
	}

	if !v.AvailabilityZones.Equal(other.AvailabilityZones) {
		return false
	}

	if !v.BottleRocket.Equal(other.BottleRocket) {
		return false
	}

	if !v.ClassicLoadBalancerNames.Equal(other.ClassicLoadBalancerNames) {
		return false
	}

	if !v.ClusterDns.Equal(other.ClusterDns) {
		return false
	}

	if !v.CpuCredits.Equal(other.CpuCredits) {
		return false
	}

	if !v.DesiredCapacity.Equal(other.DesiredCapacity) {
		return false
	}

	if !v.DisableImdsv1.Equal(other.DisableImdsv1) {
		return false
	}

	if !v.DisablePodsImds.Equal(other.DisablePodsImds) {
		return false
	}

	if !v.EbsOptimized.Equal(other.EbsOptimized) {
		return false
	}

	if !v.EfaEnabled.Equal(other.EfaEnabled) {
		return false
	}

	if !v.EnableDetailedMonitoring.Equal(other.EnableDetailedMonitoring) {
		return false
	}

	if !v.Iam.Equal(other.Iam) {
		return false
	}

	if !v.InstanceName.Equal(other.InstanceName) {
		return false
	}

	if !v.InstancePrefix.Equal(other.InstancePrefix) {
		return false
	}

	if !v.InstanceSelector.Equal(other.InstanceSelector) {
		return false
	}

	if !v.InstanceType.Equal(other.InstanceType) {
		return false
	}

	if !v.InstancesDistribution.Equal(other.InstancesDistribution) {
		return false
	}

	if !v.KubeletExtraConfig.Equal(other.KubeletExtraConfig) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.MaxPodsPerNode.Equal(other.MaxPodsPerNode) {
		return false
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OverrideBootstrapCommand.Equal(other.OverrideBootstrapCommand) {
		return false
	}

	if !v.Placement.Equal(other.Placement) {
		return false
	}

	if !v.PreBootstrapCommands.Equal(other.PreBootstrapCommands) {
		return false
	}

	if !v.PrivateNetworking.Equal(other.PrivateNetworking) {
		return false
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.Ssh.Equal(other.Ssh) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Taints.Equal(other.Taints) {
		return false
	}

	if !v.TargetGroupArns.Equal(other.TargetGroupArns) {
		return false
	}

	if !v.UpdateConfig.Equal(other.UpdateConfig) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VolumeEncrypted.Equal(other.VolumeEncrypted) {
		return false
	}

	if !v.VolumeIops.Equal(other.VolumeIops) {
		return false
	}

	if !v.VolumeKmsKeyId.Equal(other.VolumeKmsKeyId) {
		return false
	}

	if !v.VolumeName.Equal(other.VolumeName) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeThroughput.Equal(other.VolumeThroughput) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v NodeGroupsValue) Type(ctx context.Context) attr.Type {
	return NodeGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami":        basetypes.StringType{},
		"ami_family": basetypes.StringType{},
		"asg_metrics_collection": basetypes.ListType{
			ElemType: AsgMetricsCollectionValue{}.Type(ctx),
		},
		"asg_suspend_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"availability_zones": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bottle_rocket": basetypes.ListType{
			ElemType: BottleRocketValue{}.Type(ctx),
		},
		"classic_load_balancer_names": basetypes.ListType{
			ElemType: types.StringType,
		},
		"cluster_dns":                basetypes.StringType{},
		"cpu_credits":                basetypes.StringType{},
		"desired_capacity":           basetypes.Int64Type{},
		"disable_imdsv1":             basetypes.BoolType{},
		"disable_pods_imds":          basetypes.BoolType{},
		"ebs_optimized":              basetypes.BoolType{},
		"efa_enabled":                basetypes.BoolType{},
		"enable_detailed_monitoring": basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: IamValue{}.Type(ctx),
		},
		"instance_name":   basetypes.StringType{},
		"instance_prefix": basetypes.StringType{},
		"instance_selector": basetypes.ListType{
			ElemType: InstanceSelectorValue{}.Type(ctx),
		},
		"instance_type": basetypes.StringType{},
		"instances_distribution": basetypes.ListType{
			ElemType: InstancesDistributionValue{}.Type(ctx),
		},
		"kubelet_extra_config": basetypes.ListType{
			ElemType: KubeletExtraConfigValue{}.Type(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"max_pods_per_node":          basetypes.Int64Type{},
		"max_size":                   basetypes.Int64Type{},
		"min_size":                   basetypes.Int64Type{},
		"name":                       basetypes.StringType{},
		"override_bootstrap_command": basetypes.StringType{},
		"placement": basetypes.ListType{
			ElemType: PlacementValue{}.Type(ctx),
		},
		"pre_bootstrap_commands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_networking": basetypes.BoolType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"ssh": basetypes.ListType{
			ElemType: SshValue{}.Type(ctx),
		},
		"subnet_cidr": basetypes.StringType{},
		"subnets": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"taints": basetypes.SetType{
			ElemType: TaintsValue{}.Type(ctx),
		},
		"target_group_arns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"update_config": basetypes.ListType{
			ElemType: UpdateConfigValue{}.Type(ctx),
		},
		"version":           basetypes.StringType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_iops":       basetypes.Int64Type{},
		"volume_kms_key_id": basetypes.StringType{},
		"volume_name":       basetypes.StringType{},
		"volume_size":       basetypes.Int64Type{},
		"volume_throughput": basetypes.Int64Type{},
		"volume_type":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AsgMetricsCollectionType{}

type AsgMetricsCollectionType struct {
	basetypes.ObjectType
}

func (t AsgMetricsCollectionType) Equal(o attr.Type) bool {
	other, ok := o.(AsgMetricsCollectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AsgMetricsCollectionType) String() string {
	return "AsgMetricsCollectionType"
}

func (t AsgMetricsCollectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	granularityAttribute, ok := attributes["granularity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`granularity is missing from object`)

		return nil, diags
	}

	granularityVal, ok := granularityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`granularity expected to be basetypes.StringValue, was: %T`, granularityAttribute))
	}

	metricsAttribute, ok := attributes["metrics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metrics is missing from object`)

		return nil, diags
	}

	metricsVal, ok := metricsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metrics expected to be basetypes.ListValue, was: %T`, metricsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AsgMetricsCollectionValue{
		Granularity: granularityVal,
		Metrics:     metricsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAsgMetricsCollectionValueNull() AsgMetricsCollectionValue {
	return AsgMetricsCollectionValue{
		state: attr.ValueStateNull,
	}
}

func NewAsgMetricsCollectionValueUnknown() AsgMetricsCollectionValue {
	return AsgMetricsCollectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAsgMetricsCollectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AsgMetricsCollectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AsgMetricsCollectionValue Attribute Value",
				"While creating a AsgMetricsCollectionValue value, a missing attribute value was detected. "+
					"A AsgMetricsCollectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsgMetricsCollectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AsgMetricsCollectionValue Attribute Type",
				"While creating a AsgMetricsCollectionValue value, an invalid attribute value was detected. "+
					"A AsgMetricsCollectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsgMetricsCollectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AsgMetricsCollectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AsgMetricsCollectionValue Attribute Value",
				"While creating a AsgMetricsCollectionValue value, an extra attribute value was detected. "+
					"A AsgMetricsCollectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AsgMetricsCollectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAsgMetricsCollectionValueUnknown(), diags
	}

	granularityAttribute, ok := attributes["granularity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`granularity is missing from object`)

		return NewAsgMetricsCollectionValueUnknown(), diags
	}

	granularityVal, ok := granularityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`granularity expected to be basetypes.StringValue, was: %T`, granularityAttribute))
	}

	metricsAttribute, ok := attributes["metrics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metrics is missing from object`)

		return NewAsgMetricsCollectionValueUnknown(), diags
	}

	metricsVal, ok := metricsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metrics expected to be basetypes.ListValue, was: %T`, metricsAttribute))
	}

	if diags.HasError() {
		return NewAsgMetricsCollectionValueUnknown(), diags
	}

	return AsgMetricsCollectionValue{
		Granularity: granularityVal,
		Metrics:     metricsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAsgMetricsCollectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AsgMetricsCollectionValue {
	object, diags := NewAsgMetricsCollectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAsgMetricsCollectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AsgMetricsCollectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAsgMetricsCollectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAsgMetricsCollectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAsgMetricsCollectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAsgMetricsCollectionValueMust(AsgMetricsCollectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AsgMetricsCollectionType) ValueType(ctx context.Context) attr.Value {
	return AsgMetricsCollectionValue{}
}

var _ basetypes.ObjectValuable = AsgMetricsCollectionValue{}

type AsgMetricsCollectionValue struct {
	Granularity basetypes.StringValue `tfsdk:"granularity"`
	Metrics     basetypes.ListValue   `tfsdk:"metrics"`
	state       attr.ValueState
}

func (v AsgMetricsCollectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["granularity"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metrics"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Granularity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["granularity"] = val

		val, err = v.Metrics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metrics"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AsgMetricsCollectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AsgMetricsCollectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AsgMetricsCollectionValue) String() string {
	return "AsgMetricsCollectionValue"
}

func (v AsgMetricsCollectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metricsVal basetypes.ListValue
	switch {
	case v.Metrics.IsUnknown():
		metricsVal = types.ListUnknown(types.StringType)
	case v.Metrics.IsNull():
		metricsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		metricsVal, d = types.ListValue(types.StringType, v.Metrics.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"granularity": basetypes.StringType{},
			"metrics": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"granularity": basetypes.StringType{},
		"metrics": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"granularity": v.Granularity,
			"metrics":     metricsVal,
		})

	return objVal, diags
}

func (v AsgMetricsCollectionValue) Equal(o attr.Value) bool {
	other, ok := o.(AsgMetricsCollectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Granularity.Equal(other.Granularity) {
		return false
	}

	if !v.Metrics.Equal(other.Metrics) {
		return false
	}

	return true
}

func (v AsgMetricsCollectionValue) Type(ctx context.Context) attr.Type {
	return AsgMetricsCollectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AsgMetricsCollectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"granularity": basetypes.StringType{},
		"metrics": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = BottleRocketType{}

type BottleRocketType struct {
	basetypes.ObjectType
}

func (t BottleRocketType) Equal(o attr.Type) bool {
	other, ok := o.(BottleRocketType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BottleRocketType) String() string {
	return "BottleRocketType"
}

func (t BottleRocketType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableAdminContainerAttribute, ok := attributes["enable_admin_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_admin_container is missing from object`)

		return nil, diags
	}

	enableAdminContainerVal, ok := enableAdminContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_admin_container expected to be basetypes.BoolValue, was: %T`, enableAdminContainerAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.StringValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BottleRocketValue{
		EnableAdminContainer: enableAdminContainerVal,
		Settings:             settingsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBottleRocketValueNull() BottleRocketValue {
	return BottleRocketValue{
		state: attr.ValueStateNull,
	}
}

func NewBottleRocketValueUnknown() BottleRocketValue {
	return BottleRocketValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBottleRocketValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BottleRocketValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BottleRocketValue Attribute Value",
				"While creating a BottleRocketValue value, a missing attribute value was detected. "+
					"A BottleRocketValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BottleRocketValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BottleRocketValue Attribute Type",
				"While creating a BottleRocketValue value, an invalid attribute value was detected. "+
					"A BottleRocketValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BottleRocketValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BottleRocketValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BottleRocketValue Attribute Value",
				"While creating a BottleRocketValue value, an extra attribute value was detected. "+
					"A BottleRocketValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BottleRocketValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBottleRocketValueUnknown(), diags
	}

	enableAdminContainerAttribute, ok := attributes["enable_admin_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_admin_container is missing from object`)

		return NewBottleRocketValueUnknown(), diags
	}

	enableAdminContainerVal, ok := enableAdminContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_admin_container expected to be basetypes.BoolValue, was: %T`, enableAdminContainerAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewBottleRocketValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.StringValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return NewBottleRocketValueUnknown(), diags
	}

	return BottleRocketValue{
		EnableAdminContainer: enableAdminContainerVal,
		Settings:             settingsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewBottleRocketValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BottleRocketValue {
	object, diags := NewBottleRocketValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBottleRocketValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BottleRocketType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBottleRocketValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBottleRocketValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBottleRocketValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBottleRocketValueMust(BottleRocketValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BottleRocketType) ValueType(ctx context.Context) attr.Value {
	return BottleRocketValue{}
}

var _ basetypes.ObjectValuable = BottleRocketValue{}

type BottleRocketValue struct {
	EnableAdminContainer basetypes.BoolValue   `tfsdk:"enable_admin_container"`
	Settings             basetypes.StringValue `tfsdk:"settings"`
	state                attr.ValueState
}

func (v BottleRocketValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enable_admin_container"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EnableAdminContainer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_admin_container"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BottleRocketValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BottleRocketValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BottleRocketValue) String() string {
	return "BottleRocketValue"
}

func (v BottleRocketValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enable_admin_container": basetypes.BoolType{},
		"settings":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable_admin_container": v.EnableAdminContainer,
			"settings":               v.Settings,
		})

	return objVal, diags
}

func (v BottleRocketValue) Equal(o attr.Value) bool {
	other, ok := o.(BottleRocketValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnableAdminContainer.Equal(other.EnableAdminContainer) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	return true
}

func (v BottleRocketValue) Type(ctx context.Context) attr.Type {
	return BottleRocketType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BottleRocketValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable_admin_container": basetypes.BoolType{},
		"settings":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IamType{}

type IamType struct {
	basetypes.ObjectType
}

func (t IamType) Equal(o attr.Type) bool {
	other, ok := o.(IamType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamType) String() string {
	return "IamType"
}

func (t IamType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachPolicyAttribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy is missing from object`)

		return nil, diags
	}

	attachPolicyVal, ok := attachPolicyAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy expected to be basetypes.SetValue, was: %T`, attachPolicyAttribute))
	}

	attachPolicyArnsAttribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns is missing from object`)

		return nil, diags
	}

	attachPolicyArnsVal, ok := attachPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns expected to be basetypes.SetValue, was: %T`, attachPolicyArnsAttribute))
	}

	attachPolicyV2Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2 is missing from object`)

		return nil, diags
	}

	attachPolicyV2Val, ok := attachPolicyV2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2 expected to be basetypes.StringValue, was: %T`, attachPolicyV2Attribute))
	}

	iamNodeGroupWithAddonPoliciesAttribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies is missing from object`)

		return nil, diags
	}

	iamNodeGroupWithAddonPoliciesVal, ok := iamNodeGroupWithAddonPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPoliciesAttribute))
	}

	instanceProfileArnAttribute, ok := attributes["instance_profile_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_profile_arn is missing from object`)

		return nil, diags
	}

	instanceProfileArnVal, ok := instanceProfileArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_profile_arn expected to be basetypes.StringValue, was: %T`, instanceProfileArnAttribute))
	}

	instanceRoleArnAttribute, ok := attributes["instance_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_arn is missing from object`)

		return nil, diags
	}

	instanceRoleArnVal, ok := instanceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_arn expected to be basetypes.StringValue, was: %T`, instanceRoleArnAttribute))
	}

	instanceRoleNameAttribute, ok := attributes["instance_role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_name is missing from object`)

		return nil, diags
	}

	instanceRoleNameVal, ok := instanceRoleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_name expected to be basetypes.StringValue, was: %T`, instanceRoleNameAttribute))
	}

	instanceRolePermissionBoundaryAttribute, ok := attributes["instance_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_permission_boundary is missing from object`)

		return nil, diags
	}

	instanceRolePermissionBoundaryVal, ok := instanceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_permission_boundary expected to be basetypes.StringValue, was: %T`, instanceRolePermissionBoundaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamValue{
		AttachPolicy:                   attachPolicyVal,
		AttachPolicyArns:               attachPolicyArnsVal,
		AttachPolicyV2:                 attachPolicyV2Val,
		IamNodeGroupWithAddonPolicies:  iamNodeGroupWithAddonPoliciesVal,
		InstanceProfileArn:             instanceProfileArnVal,
		InstanceRoleArn:                instanceRoleArnVal,
		InstanceRoleName:               instanceRoleNameVal,
		InstanceRolePermissionBoundary: instanceRolePermissionBoundaryVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIamValueNull() IamValue {
	return IamValue{
		state: attr.ValueStateNull,
	}
}

func NewIamValueUnknown() IamValue {
	return IamValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIamValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamValue Attribute Value",
				"While creating a IamValue value, a missing attribute value was detected. "+
					"A IamValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamValue Attribute Type",
				"While creating a IamValue value, an invalid attribute value was detected. "+
					"A IamValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamValue Attribute Value",
				"While creating a IamValue value, an extra attribute value was detected. "+
					"A IamValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamValueUnknown(), diags
	}

	attachPolicyAttribute, ok := attributes["attach_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy is missing from object`)

		return NewIamValueUnknown(), diags
	}

	attachPolicyVal, ok := attachPolicyAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy expected to be basetypes.SetValue, was: %T`, attachPolicyAttribute))
	}

	attachPolicyArnsAttribute, ok := attributes["attach_policy_arns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_arns is missing from object`)

		return NewIamValueUnknown(), diags
	}

	attachPolicyArnsVal, ok := attachPolicyArnsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_arns expected to be basetypes.SetValue, was: %T`, attachPolicyArnsAttribute))
	}

	attachPolicyV2Attribute, ok := attributes["attach_policy_v2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_policy_v2 is missing from object`)

		return NewIamValueUnknown(), diags
	}

	attachPolicyV2Val, ok := attachPolicyV2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_policy_v2 expected to be basetypes.StringValue, was: %T`, attachPolicyV2Attribute))
	}

	iamNodeGroupWithAddonPoliciesAttribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies is missing from object`)

		return NewIamValueUnknown(), diags
	}

	iamNodeGroupWithAddonPoliciesVal, ok := iamNodeGroupWithAddonPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPoliciesAttribute))
	}

	instanceProfileArnAttribute, ok := attributes["instance_profile_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_profile_arn is missing from object`)

		return NewIamValueUnknown(), diags
	}

	instanceProfileArnVal, ok := instanceProfileArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_profile_arn expected to be basetypes.StringValue, was: %T`, instanceProfileArnAttribute))
	}

	instanceRoleArnAttribute, ok := attributes["instance_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_arn is missing from object`)

		return NewIamValueUnknown(), diags
	}

	instanceRoleArnVal, ok := instanceRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_arn expected to be basetypes.StringValue, was: %T`, instanceRoleArnAttribute))
	}

	instanceRoleNameAttribute, ok := attributes["instance_role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_name is missing from object`)

		return NewIamValueUnknown(), diags
	}

	instanceRoleNameVal, ok := instanceRoleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_name expected to be basetypes.StringValue, was: %T`, instanceRoleNameAttribute))
	}

	instanceRolePermissionBoundaryAttribute, ok := attributes["instance_role_permission_boundary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_role_permission_boundary is missing from object`)

		return NewIamValueUnknown(), diags
	}

	instanceRolePermissionBoundaryVal, ok := instanceRolePermissionBoundaryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_role_permission_boundary expected to be basetypes.StringValue, was: %T`, instanceRolePermissionBoundaryAttribute))
	}

	if diags.HasError() {
		return NewIamValueUnknown(), diags
	}

	return IamValue{
		AttachPolicy:                   attachPolicyVal,
		AttachPolicyArns:               attachPolicyArnsVal,
		AttachPolicyV2:                 attachPolicyV2Val,
		IamNodeGroupWithAddonPolicies:  iamNodeGroupWithAddonPoliciesVal,
		InstanceProfileArn:             instanceProfileArnVal,
		InstanceRoleArn:                instanceRoleArnVal,
		InstanceRoleName:               instanceRoleNameVal,
		InstanceRolePermissionBoundary: instanceRolePermissionBoundaryVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIamValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamValue {
	object, diags := NewIamValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamValueMust(IamValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IamType) ValueType(ctx context.Context) attr.Value {
	return IamValue{}
}

var _ basetypes.ObjectValuable = IamValue{}

type IamValue struct {
	AttachPolicy                   basetypes.SetValue    `tfsdk:"attach_policy"`
	AttachPolicyArns               basetypes.SetValue    `tfsdk:"attach_policy_arns"`
	AttachPolicyV2                 basetypes.StringValue `tfsdk:"attach_policy_v2"`
	IamNodeGroupWithAddonPolicies  basetypes.ListValue   `tfsdk:"iam_node_group_with_addon_policies"`
	InstanceProfileArn             basetypes.StringValue `tfsdk:"instance_profile_arn"`
	InstanceRoleArn                basetypes.StringValue `tfsdk:"instance_role_arn"`
	InstanceRoleName               basetypes.StringValue `tfsdk:"instance_role_name"`
	InstanceRolePermissionBoundary basetypes.StringValue `tfsdk:"instance_role_permission_boundary"`
	state                          attr.ValueState
}

func (v IamValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["attach_policy"] = basetypes.SetType{
		ElemType: AttachPolicyValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["attach_policy_arns"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["attach_policy_v2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["iam_node_group_with_addon_policies"] = basetypes.ListType{
		ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_profile_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_role_permission_boundary"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AttachPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy"] = val

		val, err = v.AttachPolicyArns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_arns"] = val

		val, err = v.AttachPolicyV2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_policy_v2"] = val

		val, err = v.IamNodeGroupWithAddonPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_node_group_with_addon_policies"] = val

		val, err = v.InstanceProfileArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_profile_arn"] = val

		val, err = v.InstanceRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_arn"] = val

		val, err = v.InstanceRoleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_name"] = val

		val, err = v.InstanceRolePermissionBoundary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_role_permission_boundary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamValue) String() string {
	return "IamValue"
}

func (v IamValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attachPolicy := types.SetValueMust(
		AttachPolicyType{
			basetypes.ObjectType{
				AttrTypes: AttachPolicyValue{}.AttributeTypes(ctx),
			},
		},
		v.AttachPolicy.Elements(),
	)

	if v.AttachPolicy.IsNull() {
		attachPolicy = types.SetNull(
			AttachPolicyType{
				basetypes.ObjectType{
					AttrTypes: AttachPolicyValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AttachPolicy.IsUnknown() {
		attachPolicy = types.SetUnknown(
			AttachPolicyType{
				basetypes.ObjectType{
					AttrTypes: AttachPolicyValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	iamNodeGroupWithAddonPolicies := types.ListValueMust(
		IamNodeGroupWithAddonPoliciesType{
			basetypes.ObjectType{
				AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.IamNodeGroupWithAddonPolicies.Elements(),
	)

	if v.IamNodeGroupWithAddonPolicies.IsNull() {
		iamNodeGroupWithAddonPolicies = types.ListNull(
			IamNodeGroupWithAddonPoliciesType{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IamNodeGroupWithAddonPolicies.IsUnknown() {
		iamNodeGroupWithAddonPolicies = types.ListUnknown(
			IamNodeGroupWithAddonPoliciesType{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var attachPolicyArnsVal basetypes.SetValue
	switch {
	case v.AttachPolicyArns.IsUnknown():
		attachPolicyArnsVal = types.SetUnknown(types.StringType)
	case v.AttachPolicyArns.IsNull():
		attachPolicyArnsVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachPolicyArnsVal, d = types.SetValue(types.StringType, v.AttachPolicyArns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_policy": basetypes.SetType{
				ElemType: AttachPolicyValue{}.Type(ctx),
			},
			"attach_policy_arns": basetypes.SetType{
				ElemType: types.StringType,
			},
			"attach_policy_v2": basetypes.StringType{},
			"iam_node_group_with_addon_policies": basetypes.ListType{
				ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
			},
			"instance_profile_arn":              basetypes.StringType{},
			"instance_role_arn":                 basetypes.StringType{},
			"instance_role_name":                basetypes.StringType{},
			"instance_role_permission_boundary": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_policy": basetypes.SetType{
			ElemType: AttachPolicyValue{}.Type(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2": basetypes.StringType{},
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
		},
		"instance_profile_arn":              basetypes.StringType{},
		"instance_role_arn":                 basetypes.StringType{},
		"instance_role_name":                basetypes.StringType{},
		"instance_role_permission_boundary": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_policy":                      attachPolicy,
			"attach_policy_arns":                 attachPolicyArnsVal,
			"attach_policy_v2":                   v.AttachPolicyV2,
			"iam_node_group_with_addon_policies": iamNodeGroupWithAddonPolicies,
			"instance_profile_arn":               v.InstanceProfileArn,
			"instance_role_arn":                  v.InstanceRoleArn,
			"instance_role_name":                 v.InstanceRoleName,
			"instance_role_permission_boundary":  v.InstanceRolePermissionBoundary,
		})

	return objVal, diags
}

func (v IamValue) Equal(o attr.Value) bool {
	other, ok := o.(IamValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachPolicy.Equal(other.AttachPolicy) {
		return false
	}

	if !v.AttachPolicyArns.Equal(other.AttachPolicyArns) {
		return false
	}

	if !v.AttachPolicyV2.Equal(other.AttachPolicyV2) {
		return false
	}

	if !v.IamNodeGroupWithAddonPolicies.Equal(other.IamNodeGroupWithAddonPolicies) {
		return false
	}

	if !v.InstanceProfileArn.Equal(other.InstanceProfileArn) {
		return false
	}

	if !v.InstanceRoleArn.Equal(other.InstanceRoleArn) {
		return false
	}

	if !v.InstanceRoleName.Equal(other.InstanceRoleName) {
		return false
	}

	if !v.InstanceRolePermissionBoundary.Equal(other.InstanceRolePermissionBoundary) {
		return false
	}

	return true
}

func (v IamValue) Type(ctx context.Context) attr.Type {
	return IamType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_policy": basetypes.SetType{
			ElemType: AttachPolicyValue{}.Type(ctx),
		},
		"attach_policy_arns": basetypes.SetType{
			ElemType: types.StringType,
		},
		"attach_policy_v2": basetypes.StringType{},
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
		},
		"instance_profile_arn":              basetypes.StringType{},
		"instance_role_arn":                 basetypes.StringType{},
		"instance_role_name":                basetypes.StringType{},
		"instance_role_permission_boundary": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttachPolicyType{}

type AttachPolicyType struct {
	basetypes.ObjectType
}

func (t AttachPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(AttachPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachPolicyType) String() string {
	return "AttachPolicyType"
}

func (t AttachPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statementAttribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement is missing from object`)

		return nil, diags
	}

	statementVal, ok := statementAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement expected to be basetypes.SetValue, was: %T`, statementAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachPolicyValue{
		Id:        idVal,
		Statement: statementVal,
		Version:   versionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicyValueNull() AttachPolicyValue {
	return AttachPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewAttachPolicyValueUnknown() AttachPolicyValue {
	return AttachPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachPolicyValue Attribute Value",
				"While creating a AttachPolicyValue value, a missing attribute value was detected. "+
					"A AttachPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachPolicyValue Attribute Type",
				"While creating a AttachPolicyValue value, an invalid attribute value was detected. "+
					"A AttachPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachPolicyValue Attribute Value",
				"While creating a AttachPolicyValue value, an extra attribute value was detected. "+
					"A AttachPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachPolicyValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewAttachPolicyValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	statementAttribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement is missing from object`)

		return NewAttachPolicyValueUnknown(), diags
	}

	statementVal, ok := statementAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement expected to be basetypes.SetValue, was: %T`, statementAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewAttachPolicyValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewAttachPolicyValueUnknown(), diags
	}

	return AttachPolicyValue{
		Id:        idVal,
		Statement: statementVal,
		Version:   versionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAttachPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachPolicyValue {
	object, diags := NewAttachPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachPolicyValueMust(AttachPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttachPolicyType) ValueType(ctx context.Context) attr.Value {
	return AttachPolicyValue{}
}

var _ basetypes.ObjectValuable = AttachPolicyValue{}

type AttachPolicyValue struct {
	Id        basetypes.StringValue `tfsdk:"id"`
	Statement basetypes.SetValue    `tfsdk:"statement"`
	Version   basetypes.StringValue `tfsdk:"version"`
	state     attr.ValueState
}

func (v AttachPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["statement"] = basetypes.SetType{
		ElemType: StatementValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Statement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statement"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachPolicyValue) String() string {
	return "AttachPolicyValue"
}

func (v AttachPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	statement := types.SetValueMust(
		StatementType{
			basetypes.ObjectType{
				AttrTypes: StatementValue{}.AttributeTypes(ctx),
			},
		},
		v.Statement.Elements(),
	)

	if v.Statement.IsNull() {
		statement = types.SetNull(
			StatementType{
				basetypes.ObjectType{
					AttrTypes: StatementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Statement.IsUnknown() {
		statement = types.SetUnknown(
			StatementType{
				basetypes.ObjectType{
					AttrTypes: StatementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: StatementValue{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":        v.Id,
			"statement": statement,
			"version":   v.Version,
		})

	return objVal, diags
}

func (v AttachPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(AttachPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Statement.Equal(other.Statement) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v AttachPolicyValue) Type(ctx context.Context) attr.Type {
	return AttachPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": basetypes.StringType{},
		"statement": basetypes.SetType{
			ElemType: StatementValue{}.Type(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatementType{}

type StatementType struct {
	basetypes.ObjectType
}

func (t StatementType) Equal(o attr.Type) bool {
	other, ok := o.(StatementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatementType) String() string {
	return "StatementType"
}

func (t StatementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return nil, diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return nil, diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return nil, diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return nil, diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return nil, diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatementValue{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatementValueNull() StatementValue {
	return StatementValue{
		state: attr.ValueStateNull,
	}
}

func NewStatementValueUnknown() StatementValue {
	return StatementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatementValue Attribute Value",
				"While creating a StatementValue value, a missing attribute value was detected. "+
					"A StatementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatementValue Attribute Type",
				"While creating a StatementValue value, an invalid attribute value was detected. "+
					"A StatementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatementValue Attribute Value",
				"While creating a StatementValue value, an extra attribute value was detected. "+
					"A StatementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatementValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.SetValue, was: %T`, actionAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	notActionAttribute, ok := attributes["not_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_action is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	notActionVal, ok := notActionAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_action expected to be basetypes.SetValue, was: %T`, notActionAttribute))
	}

	notPrincipalAttribute, ok := attributes["not_principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_principal is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	notPrincipalVal, ok := notPrincipalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_principal expected to be basetypes.StringValue, was: %T`, notPrincipalAttribute))
	}

	notResourceAttribute, ok := attributes["not_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`not_resource is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	notResourceVal, ok := notResourceAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`not_resource expected to be basetypes.SetValue, was: %T`, notResourceAttribute))
	}

	principalAttribute, ok := attributes["principal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`principal is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	principalVal, ok := principalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`principal expected to be basetypes.StringValue, was: %T`, principalAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.StringValue, was: %T`, resourceAttribute))
	}

	sidAttribute, ok := attributes["sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sid is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	sidVal, ok := sidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sid expected to be basetypes.StringValue, was: %T`, sidAttribute))
	}

	if diags.HasError() {
		return NewStatementValueUnknown(), diags
	}

	return StatementValue{
		Action:       actionVal,
		Condition:    conditionVal,
		Effect:       effectVal,
		NotAction:    notActionVal,
		NotPrincipal: notPrincipalVal,
		NotResource:  notResourceVal,
		Principal:    principalVal,
		Resource:     resourceVal,
		Sid:          sidVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatementValue {
	object, diags := NewStatementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatementValueMust(StatementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatementType) ValueType(ctx context.Context) attr.Value {
	return StatementValue{}
}

var _ basetypes.ObjectValuable = StatementValue{}

type StatementValue struct {
	Action       basetypes.SetValue    `tfsdk:"action"`
	Condition    basetypes.StringValue `tfsdk:"condition"`
	Effect       basetypes.StringValue `tfsdk:"effect"`
	NotAction    basetypes.SetValue    `tfsdk:"not_action"`
	NotPrincipal basetypes.StringValue `tfsdk:"not_principal"`
	NotResource  basetypes.SetValue    `tfsdk:"not_resource"`
	Principal    basetypes.StringValue `tfsdk:"principal"`
	Resource     basetypes.StringValue `tfsdk:"resource"`
	Sid          basetypes.StringValue `tfsdk:"sid"`
	state        attr.ValueState
}

func (v StatementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_action"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["not_principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["not_resource"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["principal"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.NotAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_action"] = val

		val, err = v.NotPrincipal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_principal"] = val

		val, err = v.NotResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["not_resource"] = val

		val, err = v.Principal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["principal"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Sid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatementValue) String() string {
	return "StatementValue"
}

func (v StatementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var actionVal basetypes.SetValue
	switch {
	case v.Action.IsUnknown():
		actionVal = types.SetUnknown(types.StringType)
	case v.Action.IsNull():
		actionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		actionVal, d = types.SetValue(types.StringType, v.Action.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notActionVal basetypes.SetValue
	switch {
	case v.NotAction.IsUnknown():
		notActionVal = types.SetUnknown(types.StringType)
	case v.NotAction.IsNull():
		notActionVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notActionVal, d = types.SetValue(types.StringType, v.NotAction.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	var notResourceVal basetypes.SetValue
	switch {
	case v.NotResource.IsUnknown():
		notResourceVal = types.SetUnknown(types.StringType)
	case v.NotResource.IsNull():
		notResourceVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		notResourceVal, d = types.SetValue(types.StringType, v.NotResource.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"condition": basetypes.StringType{},
			"effect":    basetypes.StringType{},
			"not_action": basetypes.SetType{
				ElemType: types.StringType,
			},
			"not_principal": basetypes.StringType{},
			"not_resource": basetypes.SetType{
				ElemType: types.StringType,
			},
			"principal": basetypes.StringType{},
			"resource":  basetypes.StringType{},
			"sid":       basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":        actionVal,
			"condition":     v.Condition,
			"effect":        v.Effect,
			"not_action":    notActionVal,
			"not_principal": v.NotPrincipal,
			"not_resource":  notResourceVal,
			"principal":     v.Principal,
			"resource":      v.Resource,
			"sid":           v.Sid,
		})

	return objVal, diags
}

func (v StatementValue) Equal(o attr.Value) bool {
	other, ok := o.(StatementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.NotAction.Equal(other.NotAction) {
		return false
	}

	if !v.NotPrincipal.Equal(other.NotPrincipal) {
		return false
	}

	if !v.NotResource.Equal(other.NotResource) {
		return false
	}

	if !v.Principal.Equal(other.Principal) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Sid.Equal(other.Sid) {
		return false
	}

	return true
}

func (v StatementValue) Type(ctx context.Context) attr.Type {
	return StatementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"condition": basetypes.StringType{},
		"effect":    basetypes.StringType{},
		"not_action": basetypes.SetType{
			ElemType: types.StringType,
		},
		"not_principal": basetypes.StringType{},
		"not_resource": basetypes.SetType{
			ElemType: types.StringType,
		},
		"principal": basetypes.StringType{},
		"resource":  basetypes.StringType{},
		"sid":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IamNodeGroupWithAddonPoliciesType{}

type IamNodeGroupWithAddonPoliciesType struct {
	basetypes.ObjectType
}

func (t IamNodeGroupWithAddonPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(IamNodeGroupWithAddonPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamNodeGroupWithAddonPoliciesType) String() string {
	return "IamNodeGroupWithAddonPoliciesType"
}

func (t IamNodeGroupWithAddonPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return nil, diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return nil, diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return nil, diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return nil, diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return nil, diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return nil, diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return nil, diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamNodeGroupWithAddonPoliciesValue{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPoliciesValueNull() IamNodeGroupWithAddonPoliciesValue {
	return IamNodeGroupWithAddonPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewIamNodeGroupWithAddonPoliciesValueUnknown() IamNodeGroupWithAddonPoliciesValue {
	return IamNodeGroupWithAddonPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIamNodeGroupWithAddonPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamNodeGroupWithAddonPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamNodeGroupWithAddonPoliciesValue Attribute Value",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, a missing attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamNodeGroupWithAddonPoliciesValue Attribute Type",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, an invalid attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamNodeGroupWithAddonPoliciesValue Attribute Value",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, an extra attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamNodeGroupWithAddonPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	return IamNodeGroupWithAddonPoliciesValue{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamNodeGroupWithAddonPoliciesValue {
	object, diags := NewIamNodeGroupWithAddonPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamNodeGroupWithAddonPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamNodeGroupWithAddonPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamNodeGroupWithAddonPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamNodeGroupWithAddonPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamNodeGroupWithAddonPoliciesValueMust(IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IamNodeGroupWithAddonPoliciesType) ValueType(ctx context.Context) attr.Value {
	return IamNodeGroupWithAddonPoliciesValue{}
}

var _ basetypes.ObjectValuable = IamNodeGroupWithAddonPoliciesValue{}

type IamNodeGroupWithAddonPoliciesValue struct {
	AlbIngress    basetypes.BoolValue `tfsdk:"alb_ingress"`
	AppMesh       basetypes.BoolValue `tfsdk:"app_mesh"`
	AppMeshReview basetypes.BoolValue `tfsdk:"app_mesh_review"`
	AutoScaler    basetypes.BoolValue `tfsdk:"auto_scaler"`
	CertManager   basetypes.BoolValue `tfsdk:"cert_manager"`
	CloudWatch    basetypes.BoolValue `tfsdk:"cloud_watch"`
	Ebs           basetypes.BoolValue `tfsdk:"ebs"`
	Efs           basetypes.BoolValue `tfsdk:"efs"`
	ExternalDns   basetypes.BoolValue `tfsdk:"external_dns"`
	Fsx           basetypes.BoolValue `tfsdk:"fsx"`
	ImageBuilder  basetypes.BoolValue `tfsdk:"image_builder"`
	Xray          basetypes.BoolValue `tfsdk:"xray"`
	state         attr.ValueState
}

func (v IamNodeGroupWithAddonPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alb_ingress"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh_review"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fsx"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xray"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AlbIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alb_ingress"] = val

		val, err = v.AppMesh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh"] = val

		val, err = v.AppMeshReview.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh_review"] = val

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.Ebs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs"] = val

		val, err = v.Efs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.Fsx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fsx"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		val, err = v.Xray.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xray"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamNodeGroupWithAddonPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamNodeGroupWithAddonPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamNodeGroupWithAddonPoliciesValue) String() string {
	return "IamNodeGroupWithAddonPoliciesValue"
}

func (v IamNodeGroupWithAddonPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alb_ingress":     v.AlbIngress,
			"app_mesh":        v.AppMesh,
			"app_mesh_review": v.AppMeshReview,
			"auto_scaler":     v.AutoScaler,
			"cert_manager":    v.CertManager,
			"cloud_watch":     v.CloudWatch,
			"ebs":             v.Ebs,
			"efs":             v.Efs,
			"external_dns":    v.ExternalDns,
			"fsx":             v.Fsx,
			"image_builder":   v.ImageBuilder,
			"xray":            v.Xray,
		})

	return objVal, diags
}

func (v IamNodeGroupWithAddonPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(IamNodeGroupWithAddonPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlbIngress.Equal(other.AlbIngress) {
		return false
	}

	if !v.AppMesh.Equal(other.AppMesh) {
		return false
	}

	if !v.AppMeshReview.Equal(other.AppMeshReview) {
		return false
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.Ebs.Equal(other.Ebs) {
		return false
	}

	if !v.Efs.Equal(other.Efs) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.Fsx.Equal(other.Fsx) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	if !v.Xray.Equal(other.Xray) {
		return false
	}

	return true
}

func (v IamNodeGroupWithAddonPoliciesValue) Type(ctx context.Context) attr.Type {
	return IamNodeGroupWithAddonPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamNodeGroupWithAddonPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InstanceSelectorType{}

type InstanceSelectorType struct {
	basetypes.ObjectType
}

func (t InstanceSelectorType) Equal(o attr.Type) bool {
	other, ok := o.(InstanceSelectorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstanceSelectorType) String() string {
	return "InstanceSelectorType"
}

func (t InstanceSelectorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuArchitectureAttribute, ok := attributes["cpu_architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_architecture is missing from object`)

		return nil, diags
	}

	cpuArchitectureVal, ok := cpuArchitectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_architecture expected to be basetypes.StringValue, was: %T`, cpuArchitectureAttribute))
	}

	gpusAttribute, ok := attributes["gpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpus is missing from object`)

		return nil, diags
	}

	gpusVal, ok := gpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpus expected to be basetypes.Int64Value, was: %T`, gpusAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return nil, diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstanceSelectorValue{
		CpuArchitecture: cpuArchitectureVal,
		Gpus:            gpusVal,
		Memory:          memoryVal,
		Vcpus:           vcpusVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstanceSelectorValueNull() InstanceSelectorValue {
	return InstanceSelectorValue{
		state: attr.ValueStateNull,
	}
}

func NewInstanceSelectorValueUnknown() InstanceSelectorValue {
	return InstanceSelectorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstanceSelectorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstanceSelectorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstanceSelectorValue Attribute Value",
				"While creating a InstanceSelectorValue value, a missing attribute value was detected. "+
					"A InstanceSelectorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSelectorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstanceSelectorValue Attribute Type",
				"While creating a InstanceSelectorValue value, an invalid attribute value was detected. "+
					"A InstanceSelectorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSelectorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstanceSelectorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstanceSelectorValue Attribute Value",
				"While creating a InstanceSelectorValue value, an extra attribute value was detected. "+
					"A InstanceSelectorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstanceSelectorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstanceSelectorValueUnknown(), diags
	}

	cpuArchitectureAttribute, ok := attributes["cpu_architecture"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_architecture is missing from object`)

		return NewInstanceSelectorValueUnknown(), diags
	}

	cpuArchitectureVal, ok := cpuArchitectureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_architecture expected to be basetypes.StringValue, was: %T`, cpuArchitectureAttribute))
	}

	gpusAttribute, ok := attributes["gpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpus is missing from object`)

		return NewInstanceSelectorValueUnknown(), diags
	}

	gpusVal, ok := gpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpus expected to be basetypes.Int64Value, was: %T`, gpusAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewInstanceSelectorValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return NewInstanceSelectorValueUnknown(), diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return NewInstanceSelectorValueUnknown(), diags
	}

	return InstanceSelectorValue{
		CpuArchitecture: cpuArchitectureVal,
		Gpus:            gpusVal,
		Memory:          memoryVal,
		Vcpus:           vcpusVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstanceSelectorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstanceSelectorValue {
	object, diags := NewInstanceSelectorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstanceSelectorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstanceSelectorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstanceSelectorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstanceSelectorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstanceSelectorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstanceSelectorValueMust(InstanceSelectorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstanceSelectorType) ValueType(ctx context.Context) attr.Value {
	return InstanceSelectorValue{}
}

var _ basetypes.ObjectValuable = InstanceSelectorValue{}

type InstanceSelectorValue struct {
	CpuArchitecture basetypes.StringValue `tfsdk:"cpu_architecture"`
	Gpus            basetypes.Int64Value  `tfsdk:"gpus"`
	Memory          basetypes.StringValue `tfsdk:"memory"`
	Vcpus           basetypes.Int64Value  `tfsdk:"vcpus"`
	state           attr.ValueState
}

func (v InstanceSelectorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cpu_architecture"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpus"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpuArchitecture.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_architecture"] = val

		val, err = v.Gpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpus"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.Vcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpus"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstanceSelectorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstanceSelectorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstanceSelectorValue) String() string {
	return "InstanceSelectorValue"
}

func (v InstanceSelectorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_architecture": basetypes.StringType{},
		"gpus":             basetypes.Int64Type{},
		"memory":           basetypes.StringType{},
		"vcpus":            basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_architecture": v.CpuArchitecture,
			"gpus":             v.Gpus,
			"memory":           v.Memory,
			"vcpus":            v.Vcpus,
		})

	return objVal, diags
}

func (v InstanceSelectorValue) Equal(o attr.Value) bool {
	other, ok := o.(InstanceSelectorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuArchitecture.Equal(other.CpuArchitecture) {
		return false
	}

	if !v.Gpus.Equal(other.Gpus) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.Vcpus.Equal(other.Vcpus) {
		return false
	}

	return true
}

func (v InstanceSelectorValue) Type(ctx context.Context) attr.Type {
	return InstanceSelectorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstanceSelectorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_architecture": basetypes.StringType{},
		"gpus":             basetypes.Int64Type{},
		"memory":           basetypes.StringType{},
		"vcpus":            basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = InstancesDistributionType{}

type InstancesDistributionType struct {
	basetypes.ObjectType
}

func (t InstancesDistributionType) Equal(o attr.Type) bool {
	other, ok := o.(InstancesDistributionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstancesDistributionType) String() string {
	return "InstancesDistributionType"
}

func (t InstancesDistributionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	capacityRebalanceAttribute, ok := attributes["capacity_rebalance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`capacity_rebalance is missing from object`)

		return nil, diags
	}

	capacityRebalanceVal, ok := capacityRebalanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`capacity_rebalance expected to be basetypes.BoolValue, was: %T`, capacityRebalanceAttribute))
	}

	instanceTypesAttribute, ok := attributes["instance_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_types is missing from object`)

		return nil, diags
	}

	instanceTypesVal, ok := instanceTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_types expected to be basetypes.ListValue, was: %T`, instanceTypesAttribute))
	}

	maxPriceAttribute, ok := attributes["max_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_price is missing from object`)

		return nil, diags
	}

	maxPriceVal, ok := maxPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_price expected to be basetypes.Float64Value, was: %T`, maxPriceAttribute))
	}

	onDemandBaseCapacityAttribute, ok := attributes["on_demand_base_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_demand_base_capacity is missing from object`)

		return nil, diags
	}

	onDemandBaseCapacityVal, ok := onDemandBaseCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_demand_base_capacity expected to be basetypes.Int64Value, was: %T`, onDemandBaseCapacityAttribute))
	}

	onDemandPercentageAboveBaseCapacityAttribute, ok := attributes["on_demand_percentage_above_base_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_demand_percentage_above_base_capacity is missing from object`)

		return nil, diags
	}

	onDemandPercentageAboveBaseCapacityVal, ok := onDemandPercentageAboveBaseCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_demand_percentage_above_base_capacity expected to be basetypes.Int64Value, was: %T`, onDemandPercentageAboveBaseCapacityAttribute))
	}

	spotAllocationStrategyAttribute, ok := attributes["spot_allocation_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_allocation_strategy is missing from object`)

		return nil, diags
	}

	spotAllocationStrategyVal, ok := spotAllocationStrategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_allocation_strategy expected to be basetypes.StringValue, was: %T`, spotAllocationStrategyAttribute))
	}

	spotInstancePoolsAttribute, ok := attributes["spot_instance_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_instance_pools is missing from object`)

		return nil, diags
	}

	spotInstancePoolsVal, ok := spotInstancePoolsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_instance_pools expected to be basetypes.Int64Value, was: %T`, spotInstancePoolsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstancesDistributionValue{
		CapacityRebalance:                   capacityRebalanceVal,
		InstanceTypes:                       instanceTypesVal,
		MaxPrice:                            maxPriceVal,
		OnDemandBaseCapacity:                onDemandBaseCapacityVal,
		OnDemandPercentageAboveBaseCapacity: onDemandPercentageAboveBaseCapacityVal,
		SpotAllocationStrategy:              spotAllocationStrategyVal,
		SpotInstancePools:                   spotInstancePoolsVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewInstancesDistributionValueNull() InstancesDistributionValue {
	return InstancesDistributionValue{
		state: attr.ValueStateNull,
	}
}

func NewInstancesDistributionValueUnknown() InstancesDistributionValue {
	return InstancesDistributionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstancesDistributionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstancesDistributionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstancesDistributionValue Attribute Value",
				"While creating a InstancesDistributionValue value, a missing attribute value was detected. "+
					"A InstancesDistributionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancesDistributionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstancesDistributionValue Attribute Type",
				"While creating a InstancesDistributionValue value, an invalid attribute value was detected. "+
					"A InstancesDistributionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancesDistributionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstancesDistributionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstancesDistributionValue Attribute Value",
				"While creating a InstancesDistributionValue value, an extra attribute value was detected. "+
					"A InstancesDistributionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstancesDistributionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstancesDistributionValueUnknown(), diags
	}

	capacityRebalanceAttribute, ok := attributes["capacity_rebalance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`capacity_rebalance is missing from object`)

		return NewInstancesDistributionValueUnknown(), diags
	}

	capacityRebalanceVal, ok := capacityRebalanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`capacity_rebalance expected to be basetypes.BoolValue, was: %T`, capacityRebalanceAttribute))
	}

	instanceTypesAttribute, ok := attributes["instance_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_types is missing from object`)

		return NewInstancesDistributionValueUnknown(), diags
	}

	instanceTypesVal, ok := instanceTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_types expected to be basetypes.ListValue, was: %T`, instanceTypesAttribute))
	}

	maxPriceAttribute, ok := attributes["max_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_price is missing from object`)

		return NewInstancesDistributionValueUnknown(), diags
	}

	maxPriceVal, ok := maxPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_price expected to be basetypes.Float64Value, was: %T`, maxPriceAttribute))
	}

	onDemandBaseCapacityAttribute, ok := attributes["on_demand_base_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_demand_base_capacity is missing from object`)

		return NewInstancesDistributionValueUnknown(), diags
	}

	onDemandBaseCapacityVal, ok := onDemandBaseCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_demand_base_capacity expected to be basetypes.Int64Value, was: %T`, onDemandBaseCapacityAttribute))
	}

	onDemandPercentageAboveBaseCapacityAttribute, ok := attributes["on_demand_percentage_above_base_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_demand_percentage_above_base_capacity is missing from object`)

		return NewInstancesDistributionValueUnknown(), diags
	}

	onDemandPercentageAboveBaseCapacityVal, ok := onDemandPercentageAboveBaseCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_demand_percentage_above_base_capacity expected to be basetypes.Int64Value, was: %T`, onDemandPercentageAboveBaseCapacityAttribute))
	}

	spotAllocationStrategyAttribute, ok := attributes["spot_allocation_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_allocation_strategy is missing from object`)

		return NewInstancesDistributionValueUnknown(), diags
	}

	spotAllocationStrategyVal, ok := spotAllocationStrategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_allocation_strategy expected to be basetypes.StringValue, was: %T`, spotAllocationStrategyAttribute))
	}

	spotInstancePoolsAttribute, ok := attributes["spot_instance_pools"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_instance_pools is missing from object`)

		return NewInstancesDistributionValueUnknown(), diags
	}

	spotInstancePoolsVal, ok := spotInstancePoolsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_instance_pools expected to be basetypes.Int64Value, was: %T`, spotInstancePoolsAttribute))
	}

	if diags.HasError() {
		return NewInstancesDistributionValueUnknown(), diags
	}

	return InstancesDistributionValue{
		CapacityRebalance:                   capacityRebalanceVal,
		InstanceTypes:                       instanceTypesVal,
		MaxPrice:                            maxPriceVal,
		OnDemandBaseCapacity:                onDemandBaseCapacityVal,
		OnDemandPercentageAboveBaseCapacity: onDemandPercentageAboveBaseCapacityVal,
		SpotAllocationStrategy:              spotAllocationStrategyVal,
		SpotInstancePools:                   spotInstancePoolsVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewInstancesDistributionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstancesDistributionValue {
	object, diags := NewInstancesDistributionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstancesDistributionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstancesDistributionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstancesDistributionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstancesDistributionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstancesDistributionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstancesDistributionValueMust(InstancesDistributionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstancesDistributionType) ValueType(ctx context.Context) attr.Value {
	return InstancesDistributionValue{}
}

var _ basetypes.ObjectValuable = InstancesDistributionValue{}

type InstancesDistributionValue struct {
	CapacityRebalance                   basetypes.BoolValue    `tfsdk:"capacity_rebalance"`
	InstanceTypes                       basetypes.ListValue    `tfsdk:"instance_types"`
	MaxPrice                            basetypes.Float64Value `tfsdk:"max_price"`
	OnDemandBaseCapacity                basetypes.Int64Value   `tfsdk:"on_demand_base_capacity"`
	OnDemandPercentageAboveBaseCapacity basetypes.Int64Value   `tfsdk:"on_demand_percentage_above_base_capacity"`
	SpotAllocationStrategy              basetypes.StringValue  `tfsdk:"spot_allocation_strategy"`
	SpotInstancePools                   basetypes.Int64Value   `tfsdk:"spot_instance_pools"`
	state                               attr.ValueState
}

func (v InstancesDistributionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["capacity_rebalance"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["instance_types"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["max_price"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["on_demand_base_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["on_demand_percentage_above_base_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spot_allocation_strategy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spot_instance_pools"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CapacityRebalance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["capacity_rebalance"] = val

		val, err = v.InstanceTypes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_types"] = val

		val, err = v.MaxPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_price"] = val

		val, err = v.OnDemandBaseCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_demand_base_capacity"] = val

		val, err = v.OnDemandPercentageAboveBaseCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_demand_percentage_above_base_capacity"] = val

		val, err = v.SpotAllocationStrategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spot_allocation_strategy"] = val

		val, err = v.SpotInstancePools.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spot_instance_pools"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstancesDistributionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstancesDistributionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstancesDistributionValue) String() string {
	return "InstancesDistributionValue"
}

func (v InstancesDistributionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var instanceTypesVal basetypes.ListValue
	switch {
	case v.InstanceTypes.IsUnknown():
		instanceTypesVal = types.ListUnknown(types.StringType)
	case v.InstanceTypes.IsNull():
		instanceTypesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		instanceTypesVal, d = types.ListValue(types.StringType, v.InstanceTypes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"capacity_rebalance": basetypes.BoolType{},
			"instance_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"max_price":               basetypes.Float64Type{},
			"on_demand_base_capacity": basetypes.Int64Type{},
			"on_demand_percentage_above_base_capacity": basetypes.Int64Type{},
			"spot_allocation_strategy":                 basetypes.StringType{},
			"spot_instance_pools":                      basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"capacity_rebalance": basetypes.BoolType{},
		"instance_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"max_price":               basetypes.Float64Type{},
		"on_demand_base_capacity": basetypes.Int64Type{},
		"on_demand_percentage_above_base_capacity": basetypes.Int64Type{},
		"spot_allocation_strategy":                 basetypes.StringType{},
		"spot_instance_pools":                      basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"capacity_rebalance":                       v.CapacityRebalance,
			"instance_types":                           instanceTypesVal,
			"max_price":                                v.MaxPrice,
			"on_demand_base_capacity":                  v.OnDemandBaseCapacity,
			"on_demand_percentage_above_base_capacity": v.OnDemandPercentageAboveBaseCapacity,
			"spot_allocation_strategy":                 v.SpotAllocationStrategy,
			"spot_instance_pools":                      v.SpotInstancePools,
		})

	return objVal, diags
}

func (v InstancesDistributionValue) Equal(o attr.Value) bool {
	other, ok := o.(InstancesDistributionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CapacityRebalance.Equal(other.CapacityRebalance) {
		return false
	}

	if !v.InstanceTypes.Equal(other.InstanceTypes) {
		return false
	}

	if !v.MaxPrice.Equal(other.MaxPrice) {
		return false
	}

	if !v.OnDemandBaseCapacity.Equal(other.OnDemandBaseCapacity) {
		return false
	}

	if !v.OnDemandPercentageAboveBaseCapacity.Equal(other.OnDemandPercentageAboveBaseCapacity) {
		return false
	}

	if !v.SpotAllocationStrategy.Equal(other.SpotAllocationStrategy) {
		return false
	}

	if !v.SpotInstancePools.Equal(other.SpotInstancePools) {
		return false
	}

	return true
}

func (v InstancesDistributionValue) Type(ctx context.Context) attr.Type {
	return InstancesDistributionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstancesDistributionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"capacity_rebalance": basetypes.BoolType{},
		"instance_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"max_price":               basetypes.Float64Type{},
		"on_demand_base_capacity": basetypes.Int64Type{},
		"on_demand_percentage_above_base_capacity": basetypes.Int64Type{},
		"spot_allocation_strategy":                 basetypes.StringType{},
		"spot_instance_pools":                      basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = KubeletExtraConfigType{}

type KubeletExtraConfigType struct {
	basetypes.ObjectType
}

func (t KubeletExtraConfigType) Equal(o attr.Type) bool {
	other, ok := o.(KubeletExtraConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KubeletExtraConfigType) String() string {
	return "KubeletExtraConfigType"
}

func (t KubeletExtraConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	evictionHardAttribute, ok := attributes["eviction_hard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eviction_hard is missing from object`)

		return nil, diags
	}

	evictionHardVal, ok := evictionHardAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eviction_hard expected to be basetypes.MapValue, was: %T`, evictionHardAttribute))
	}

	featureGatesAttribute, ok := attributes["feature_gates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`feature_gates is missing from object`)

		return nil, diags
	}

	featureGatesVal, ok := featureGatesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`feature_gates expected to be basetypes.MapValue, was: %T`, featureGatesAttribute))
	}

	kubeReservedAttribute, ok := attributes["kube_reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kube_reserved is missing from object`)

		return nil, diags
	}

	kubeReservedVal, ok := kubeReservedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kube_reserved expected to be basetypes.MapValue, was: %T`, kubeReservedAttribute))
	}

	kubeReservedCgroupAttribute, ok := attributes["kube_reserved_cgroup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kube_reserved_cgroup is missing from object`)

		return nil, diags
	}

	kubeReservedCgroupVal, ok := kubeReservedCgroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kube_reserved_cgroup expected to be basetypes.StringValue, was: %T`, kubeReservedCgroupAttribute))
	}

	systemReservedAttribute, ok := attributes["system_reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_reserved is missing from object`)

		return nil, diags
	}

	systemReservedVal, ok := systemReservedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_reserved expected to be basetypes.MapValue, was: %T`, systemReservedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KubeletExtraConfigValue{
		EvictionHard:       evictionHardVal,
		FeatureGates:       featureGatesVal,
		KubeReserved:       kubeReservedVal,
		KubeReservedCgroup: kubeReservedCgroupVal,
		SystemReserved:     systemReservedVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewKubeletExtraConfigValueNull() KubeletExtraConfigValue {
	return KubeletExtraConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewKubeletExtraConfigValueUnknown() KubeletExtraConfigValue {
	return KubeletExtraConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKubeletExtraConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KubeletExtraConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KubeletExtraConfigValue Attribute Value",
				"While creating a KubeletExtraConfigValue value, a missing attribute value was detected. "+
					"A KubeletExtraConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KubeletExtraConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KubeletExtraConfigValue Attribute Type",
				"While creating a KubeletExtraConfigValue value, an invalid attribute value was detected. "+
					"A KubeletExtraConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KubeletExtraConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KubeletExtraConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KubeletExtraConfigValue Attribute Value",
				"While creating a KubeletExtraConfigValue value, an extra attribute value was detected. "+
					"A KubeletExtraConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KubeletExtraConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKubeletExtraConfigValueUnknown(), diags
	}

	evictionHardAttribute, ok := attributes["eviction_hard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eviction_hard is missing from object`)

		return NewKubeletExtraConfigValueUnknown(), diags
	}

	evictionHardVal, ok := evictionHardAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eviction_hard expected to be basetypes.MapValue, was: %T`, evictionHardAttribute))
	}

	featureGatesAttribute, ok := attributes["feature_gates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`feature_gates is missing from object`)

		return NewKubeletExtraConfigValueUnknown(), diags
	}

	featureGatesVal, ok := featureGatesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`feature_gates expected to be basetypes.MapValue, was: %T`, featureGatesAttribute))
	}

	kubeReservedAttribute, ok := attributes["kube_reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kube_reserved is missing from object`)

		return NewKubeletExtraConfigValueUnknown(), diags
	}

	kubeReservedVal, ok := kubeReservedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kube_reserved expected to be basetypes.MapValue, was: %T`, kubeReservedAttribute))
	}

	kubeReservedCgroupAttribute, ok := attributes["kube_reserved_cgroup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kube_reserved_cgroup is missing from object`)

		return NewKubeletExtraConfigValueUnknown(), diags
	}

	kubeReservedCgroupVal, ok := kubeReservedCgroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kube_reserved_cgroup expected to be basetypes.StringValue, was: %T`, kubeReservedCgroupAttribute))
	}

	systemReservedAttribute, ok := attributes["system_reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_reserved is missing from object`)

		return NewKubeletExtraConfigValueUnknown(), diags
	}

	systemReservedVal, ok := systemReservedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_reserved expected to be basetypes.MapValue, was: %T`, systemReservedAttribute))
	}

	if diags.HasError() {
		return NewKubeletExtraConfigValueUnknown(), diags
	}

	return KubeletExtraConfigValue{
		EvictionHard:       evictionHardVal,
		FeatureGates:       featureGatesVal,
		KubeReserved:       kubeReservedVal,
		KubeReservedCgroup: kubeReservedCgroupVal,
		SystemReserved:     systemReservedVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewKubeletExtraConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KubeletExtraConfigValue {
	object, diags := NewKubeletExtraConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKubeletExtraConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KubeletExtraConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKubeletExtraConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKubeletExtraConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKubeletExtraConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKubeletExtraConfigValueMust(KubeletExtraConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KubeletExtraConfigType) ValueType(ctx context.Context) attr.Value {
	return KubeletExtraConfigValue{}
}

var _ basetypes.ObjectValuable = KubeletExtraConfigValue{}

type KubeletExtraConfigValue struct {
	EvictionHard       basetypes.MapValue    `tfsdk:"eviction_hard"`
	FeatureGates       basetypes.MapValue    `tfsdk:"feature_gates"`
	KubeReserved       basetypes.MapValue    `tfsdk:"kube_reserved"`
	KubeReservedCgroup basetypes.StringValue `tfsdk:"kube_reserved_cgroup"`
	SystemReserved     basetypes.MapValue    `tfsdk:"system_reserved"`
	state              attr.ValueState
}

func (v KubeletExtraConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["eviction_hard"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["feature_gates"] = basetypes.MapType{
		ElemType: types.BoolType,
	}.TerraformType(ctx)
	attrTypes["kube_reserved"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kube_reserved_cgroup"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_reserved"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.EvictionHard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eviction_hard"] = val

		val, err = v.FeatureGates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["feature_gates"] = val

		val, err = v.KubeReserved.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kube_reserved"] = val

		val, err = v.KubeReservedCgroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kube_reserved_cgroup"] = val

		val, err = v.SystemReserved.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_reserved"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KubeletExtraConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KubeletExtraConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KubeletExtraConfigValue) String() string {
	return "KubeletExtraConfigValue"
}

func (v KubeletExtraConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var evictionHardVal basetypes.MapValue
	switch {
	case v.EvictionHard.IsUnknown():
		evictionHardVal = types.MapUnknown(types.StringType)
	case v.EvictionHard.IsNull():
		evictionHardVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		evictionHardVal, d = types.MapValue(types.StringType, v.EvictionHard.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"eviction_hard": basetypes.MapType{
				ElemType: types.StringType,
			},
			"feature_gates": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"kube_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kube_reserved_cgroup": basetypes.StringType{},
			"system_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var featureGatesVal basetypes.MapValue
	switch {
	case v.FeatureGates.IsUnknown():
		featureGatesVal = types.MapUnknown(types.BoolType)
	case v.FeatureGates.IsNull():
		featureGatesVal = types.MapNull(types.BoolType)
	default:
		var d diag.Diagnostics
		featureGatesVal, d = types.MapValue(types.BoolType, v.FeatureGates.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"eviction_hard": basetypes.MapType{
				ElemType: types.StringType,
			},
			"feature_gates": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"kube_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kube_reserved_cgroup": basetypes.StringType{},
			"system_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var kubeReservedVal basetypes.MapValue
	switch {
	case v.KubeReserved.IsUnknown():
		kubeReservedVal = types.MapUnknown(types.StringType)
	case v.KubeReserved.IsNull():
		kubeReservedVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		kubeReservedVal, d = types.MapValue(types.StringType, v.KubeReserved.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"eviction_hard": basetypes.MapType{
				ElemType: types.StringType,
			},
			"feature_gates": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"kube_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kube_reserved_cgroup": basetypes.StringType{},
			"system_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var systemReservedVal basetypes.MapValue
	switch {
	case v.SystemReserved.IsUnknown():
		systemReservedVal = types.MapUnknown(types.StringType)
	case v.SystemReserved.IsNull():
		systemReservedVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		systemReservedVal, d = types.MapValue(types.StringType, v.SystemReserved.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"eviction_hard": basetypes.MapType{
				ElemType: types.StringType,
			},
			"feature_gates": basetypes.MapType{
				ElemType: types.BoolType,
			},
			"kube_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kube_reserved_cgroup": basetypes.StringType{},
			"system_reserved": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"eviction_hard": basetypes.MapType{
			ElemType: types.StringType,
		},
		"feature_gates": basetypes.MapType{
			ElemType: types.BoolType,
		},
		"kube_reserved": basetypes.MapType{
			ElemType: types.StringType,
		},
		"kube_reserved_cgroup": basetypes.StringType{},
		"system_reserved": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"eviction_hard":        evictionHardVal,
			"feature_gates":        featureGatesVal,
			"kube_reserved":        kubeReservedVal,
			"kube_reserved_cgroup": v.KubeReservedCgroup,
			"system_reserved":      systemReservedVal,
		})

	return objVal, diags
}

func (v KubeletExtraConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(KubeletExtraConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EvictionHard.Equal(other.EvictionHard) {
		return false
	}

	if !v.FeatureGates.Equal(other.FeatureGates) {
		return false
	}

	if !v.KubeReserved.Equal(other.KubeReserved) {
		return false
	}

	if !v.KubeReservedCgroup.Equal(other.KubeReservedCgroup) {
		return false
	}

	if !v.SystemReserved.Equal(other.SystemReserved) {
		return false
	}

	return true
}

func (v KubeletExtraConfigValue) Type(ctx context.Context) attr.Type {
	return KubeletExtraConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KubeletExtraConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"eviction_hard": basetypes.MapType{
			ElemType: types.StringType,
		},
		"feature_gates": basetypes.MapType{
			ElemType: types.BoolType,
		},
		"kube_reserved": basetypes.MapType{
			ElemType: types.StringType,
		},
		"kube_reserved_cgroup": basetypes.StringType{},
		"system_reserved": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = PlacementType{}

type PlacementType struct {
	basetypes.ObjectType
}

func (t PlacementType) Equal(o attr.Type) bool {
	other, ok := o.(PlacementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlacementType) String() string {
	return "PlacementType"
}

func (t PlacementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlacementValue{
		Group: groupVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlacementValueNull() PlacementValue {
	return PlacementValue{
		state: attr.ValueStateNull,
	}
}

func NewPlacementValueUnknown() PlacementValue {
	return PlacementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlacementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlacementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlacementValue Attribute Value",
				"While creating a PlacementValue value, a missing attribute value was detected. "+
					"A PlacementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlacementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlacementValue Attribute Type",
				"While creating a PlacementValue value, an invalid attribute value was detected. "+
					"A PlacementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlacementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlacementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlacementValue Attribute Value",
				"While creating a PlacementValue value, an extra attribute value was detected. "+
					"A PlacementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlacementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlacementValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewPlacementValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	if diags.HasError() {
		return NewPlacementValueUnknown(), diags
	}

	return PlacementValue{
		Group: groupVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPlacementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlacementValue {
	object, diags := NewPlacementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlacementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlacementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlacementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlacementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlacementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlacementValueMust(PlacementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlacementType) ValueType(ctx context.Context) attr.Value {
	return PlacementValue{}
}

var _ basetypes.ObjectValuable = PlacementValue{}

type PlacementValue struct {
	Group basetypes.StringValue `tfsdk:"group"`
	state attr.ValueState
}

func (v PlacementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlacementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlacementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlacementValue) String() string {
	return "PlacementValue"
}

func (v PlacementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group": v.Group,
		})

	return objVal, diags
}

func (v PlacementValue) Equal(o attr.Value) bool {
	other, ok := o.(PlacementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	return true
}

func (v PlacementValue) Type(ctx context.Context) attr.Type {
	return PlacementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlacementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroupsType{}

type SecurityGroupsType struct {
	basetypes.ObjectType
}

func (t SecurityGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroupsType) String() string {
	return "SecurityGroupsType"
}

func (t SecurityGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachIdsAttribute, ok := attributes["attach_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_ids is missing from object`)

		return nil, diags
	}

	attachIdsVal, ok := attachIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_ids expected to be basetypes.ListValue, was: %T`, attachIdsAttribute))
	}

	withLocalAttribute, ok := attributes["with_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_local is missing from object`)

		return nil, diags
	}

	withLocalVal, ok := withLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_local expected to be basetypes.BoolValue, was: %T`, withLocalAttribute))
	}

	withSharedAttribute, ok := attributes["with_shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_shared is missing from object`)

		return nil, diags
	}

	withSharedVal, ok := withSharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_shared expected to be basetypes.BoolValue, was: %T`, withSharedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroupsValue{
		AttachIds:  attachIdsVal,
		WithLocal:  withLocalVal,
		WithShared: withSharedVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueNull() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroupsValueUnknown() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, a missing attribute value was detected. "+
					"A SecurityGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroupsValue Attribute Type",
				"While creating a SecurityGroupsValue value, an invalid attribute value was detected. "+
					"A SecurityGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, an extra attribute value was detected. "+
					"A SecurityGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	attachIdsAttribute, ok := attributes["attach_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_ids is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	attachIdsVal, ok := attachIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_ids expected to be basetypes.ListValue, was: %T`, attachIdsAttribute))
	}

	withLocalAttribute, ok := attributes["with_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_local is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	withLocalVal, ok := withLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_local expected to be basetypes.BoolValue, was: %T`, withLocalAttribute))
	}

	withSharedAttribute, ok := attributes["with_shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`with_shared is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	withSharedVal, ok := withSharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`with_shared expected to be basetypes.BoolValue, was: %T`, withSharedAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	return SecurityGroupsValue{
		AttachIds:  attachIdsVal,
		WithLocal:  withLocalVal,
		WithShared: withSharedVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroupsValue {
	object, diags := NewSecurityGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroupsValueMust(SecurityGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroupsType) ValueType(ctx context.Context) attr.Value {
	return SecurityGroupsValue{}
}

var _ basetypes.ObjectValuable = SecurityGroupsValue{}

type SecurityGroupsValue struct {
	AttachIds  basetypes.ListValue `tfsdk:"attach_ids"`
	WithLocal  basetypes.BoolValue `tfsdk:"with_local"`
	WithShared basetypes.BoolValue `tfsdk:"with_shared"`
	state      attr.ValueState
}

func (v SecurityGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["attach_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["with_local"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["with_shared"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AttachIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_ids"] = val

		val, err = v.WithLocal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_local"] = val

		val, err = v.WithShared.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["with_shared"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroupsValue) String() string {
	return "SecurityGroupsValue"
}

func (v SecurityGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attachIdsVal basetypes.ListValue
	switch {
	case v.AttachIds.IsUnknown():
		attachIdsVal = types.ListUnknown(types.StringType)
	case v.AttachIds.IsNull():
		attachIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		attachIdsVal, d = types.ListValue(types.StringType, v.AttachIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"with_local":  basetypes.BoolType{},
			"with_shared": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attach_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"with_local":  basetypes.BoolType{},
		"with_shared": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attach_ids":  attachIdsVal,
			"with_local":  v.WithLocal,
			"with_shared": v.WithShared,
		})

	return objVal, diags
}

func (v SecurityGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachIds.Equal(other.AttachIds) {
		return false
	}

	if !v.WithLocal.Equal(other.WithLocal) {
		return false
	}

	if !v.WithShared.Equal(other.WithShared) {
		return false
	}

	return true
}

func (v SecurityGroupsValue) Type(ctx context.Context) attr.Type {
	return SecurityGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"with_local":  basetypes.BoolType{},
		"with_shared": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SshType{}

type SshType struct {
	basetypes.ObjectType
}

func (t SshType) Equal(o attr.Type) bool {
	other, ok := o.(SshType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SshType) String() string {
	return "SshType"
}

func (t SshType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return nil, diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	enableSsmAttribute, ok := attributes["enable_ssm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ssm is missing from object`)

		return nil, diags
	}

	enableSsmVal, ok := enableSsmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ssm expected to be basetypes.BoolValue, was: %T`, enableSsmAttribute))
	}

	publicKeyAttribute, ok := attributes["public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key is missing from object`)

		return nil, diags
	}

	publicKeyVal, ok := publicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key expected to be basetypes.StringValue, was: %T`, publicKeyAttribute))
	}

	publicKeyNameAttribute, ok := attributes["public_key_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key_name is missing from object`)

		return nil, diags
	}

	publicKeyNameVal, ok := publicKeyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key_name expected to be basetypes.StringValue, was: %T`, publicKeyNameAttribute))
	}

	sourceSecurityGroupIdsAttribute, ok := attributes["source_security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_security_group_ids is missing from object`)

		return nil, diags
	}

	sourceSecurityGroupIdsVal, ok := sourceSecurityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_security_group_ids expected to be basetypes.ListValue, was: %T`, sourceSecurityGroupIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SshValue{
		Allow:                  allowVal,
		EnableSsm:              enableSsmVal,
		PublicKey:              publicKeyVal,
		PublicKeyName:          publicKeyNameVal,
		SourceSecurityGroupIds: sourceSecurityGroupIdsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSshValueNull() SshValue {
	return SshValue{
		state: attr.ValueStateNull,
	}
}

func NewSshValueUnknown() SshValue {
	return SshValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSshValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SshValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SshValue Attribute Value",
				"While creating a SshValue value, a missing attribute value was detected. "+
					"A SshValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SshValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SshValue Attribute Type",
				"While creating a SshValue value, an invalid attribute value was detected. "+
					"A SshValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SshValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SshValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SshValue Attribute Value",
				"While creating a SshValue value, an extra attribute value was detected. "+
					"A SshValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SshValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSshValueUnknown(), diags
	}

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return NewSshValueUnknown(), diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	enableSsmAttribute, ok := attributes["enable_ssm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ssm is missing from object`)

		return NewSshValueUnknown(), diags
	}

	enableSsmVal, ok := enableSsmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ssm expected to be basetypes.BoolValue, was: %T`, enableSsmAttribute))
	}

	publicKeyAttribute, ok := attributes["public_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key is missing from object`)

		return NewSshValueUnknown(), diags
	}

	publicKeyVal, ok := publicKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key expected to be basetypes.StringValue, was: %T`, publicKeyAttribute))
	}

	publicKeyNameAttribute, ok := attributes["public_key_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_key_name is missing from object`)

		return NewSshValueUnknown(), diags
	}

	publicKeyNameVal, ok := publicKeyNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_key_name expected to be basetypes.StringValue, was: %T`, publicKeyNameAttribute))
	}

	sourceSecurityGroupIdsAttribute, ok := attributes["source_security_group_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_security_group_ids is missing from object`)

		return NewSshValueUnknown(), diags
	}

	sourceSecurityGroupIdsVal, ok := sourceSecurityGroupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_security_group_ids expected to be basetypes.ListValue, was: %T`, sourceSecurityGroupIdsAttribute))
	}

	if diags.HasError() {
		return NewSshValueUnknown(), diags
	}

	return SshValue{
		Allow:                  allowVal,
		EnableSsm:              enableSsmVal,
		PublicKey:              publicKeyVal,
		PublicKeyName:          publicKeyNameVal,
		SourceSecurityGroupIds: sourceSecurityGroupIdsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSshValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SshValue {
	object, diags := NewSshValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSshValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SshType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSshValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSshValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSshValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSshValueMust(SshValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SshType) ValueType(ctx context.Context) attr.Value {
	return SshValue{}
}

var _ basetypes.ObjectValuable = SshValue{}

type SshValue struct {
	Allow                  basetypes.BoolValue   `tfsdk:"allow"`
	EnableSsm              basetypes.BoolValue   `tfsdk:"enable_ssm"`
	PublicKey              basetypes.StringValue `tfsdk:"public_key"`
	PublicKeyName          basetypes.StringValue `tfsdk:"public_key_name"`
	SourceSecurityGroupIds basetypes.ListValue   `tfsdk:"source_security_group_ids"`
	state                  attr.ValueState
}

func (v SshValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["allow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_ssm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["public_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["public_key_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_security_group_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Allow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow"] = val

		val, err = v.EnableSsm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ssm"] = val

		val, err = v.PublicKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_key"] = val

		val, err = v.PublicKeyName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_key_name"] = val

		val, err = v.SourceSecurityGroupIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_security_group_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SshValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SshValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SshValue) String() string {
	return "SshValue"
}

func (v SshValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceSecurityGroupIdsVal basetypes.ListValue
	switch {
	case v.SourceSecurityGroupIds.IsUnknown():
		sourceSecurityGroupIdsVal = types.ListUnknown(types.StringType)
	case v.SourceSecurityGroupIds.IsNull():
		sourceSecurityGroupIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		sourceSecurityGroupIdsVal, d = types.ListValue(types.StringType, v.SourceSecurityGroupIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow":           basetypes.BoolType{},
			"enable_ssm":      basetypes.BoolType{},
			"public_key":      basetypes.StringType{},
			"public_key_name": basetypes.StringType{},
			"source_security_group_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow":           basetypes.BoolType{},
		"enable_ssm":      basetypes.BoolType{},
		"public_key":      basetypes.StringType{},
		"public_key_name": basetypes.StringType{},
		"source_security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow":                     v.Allow,
			"enable_ssm":                v.EnableSsm,
			"public_key":                v.PublicKey,
			"public_key_name":           v.PublicKeyName,
			"source_security_group_ids": sourceSecurityGroupIdsVal,
		})

	return objVal, diags
}

func (v SshValue) Equal(o attr.Value) bool {
	other, ok := o.(SshValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Allow.Equal(other.Allow) {
		return false
	}

	if !v.EnableSsm.Equal(other.EnableSsm) {
		return false
	}

	if !v.PublicKey.Equal(other.PublicKey) {
		return false
	}

	if !v.PublicKeyName.Equal(other.PublicKeyName) {
		return false
	}

	if !v.SourceSecurityGroupIds.Equal(other.SourceSecurityGroupIds) {
		return false
	}

	return true
}

func (v SshValue) Type(ctx context.Context) attr.Type {
	return SshType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SshValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow":           basetypes.BoolType{},
		"enable_ssm":      basetypes.BoolType{},
		"public_key":      basetypes.StringType{},
		"public_key_name": basetypes.StringType{},
		"source_security_group_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TaintsType{}

type TaintsType struct {
	basetypes.ObjectType
}

func (t TaintsType) Equal(o attr.Type) bool {
	other, ok := o.(TaintsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TaintsType) String() string {
	return "TaintsType"
}

func (t TaintsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TaintsValue{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaintsValueNull() TaintsValue {
	return TaintsValue{
		state: attr.ValueStateNull,
	}
}

func NewTaintsValueUnknown() TaintsValue {
	return TaintsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTaintsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TaintsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TaintsValue Attribute Value",
				"While creating a TaintsValue value, a missing attribute value was detected. "+
					"A TaintsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaintsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TaintsValue Attribute Type",
				"While creating a TaintsValue value, an invalid attribute value was detected. "+
					"A TaintsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaintsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TaintsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TaintsValue Attribute Value",
				"While creating a TaintsValue value, an extra attribute value was detected. "+
					"A TaintsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TaintsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaintsValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTaintsValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTaintsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTaintsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTaintsValueUnknown(), diags
	}

	return TaintsValue{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaintsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TaintsValue {
	object, diags := NewTaintsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaintsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TaintsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaintsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaintsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaintsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaintsValueMust(TaintsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TaintsType) ValueType(ctx context.Context) attr.Value {
	return TaintsValue{}
}

var _ basetypes.ObjectValuable = TaintsValue{}

type TaintsValue struct {
	Effect basetypes.StringValue `tfsdk:"effect"`
	Key    basetypes.StringValue `tfsdk:"key"`
	Value  basetypes.StringValue `tfsdk:"value"`
	state  attr.ValueState
}

func (v TaintsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TaintsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TaintsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TaintsValue) String() string {
	return "TaintsValue"
}

func (v TaintsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect": v.Effect,
			"key":    v.Key,
			"value":  v.Value,
		})

	return objVal, diags
}

func (v TaintsValue) Equal(o attr.Value) bool {
	other, ok := o.(TaintsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TaintsValue) Type(ctx context.Context) attr.Type {
	return TaintsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TaintsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = UpdateConfigType{}

type UpdateConfigType struct {
	basetypes.ObjectType
}

func (t UpdateConfigType) Equal(o attr.Type) bool {
	other, ok := o.(UpdateConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UpdateConfigType) String() string {
	return "UpdateConfigType"
}

func (t UpdateConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxUnavaliableAttribute, ok := attributes["max_unavaliable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavaliable is missing from object`)

		return nil, diags
	}

	maxUnavaliableVal, ok := maxUnavaliableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavaliable expected to be basetypes.Int64Value, was: %T`, maxUnavaliableAttribute))
	}

	maxUnavaliablePercetageAttribute, ok := attributes["max_unavaliable_percetage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavaliable_percetage is missing from object`)

		return nil, diags
	}

	maxUnavaliablePercetageVal, ok := maxUnavaliablePercetageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavaliable_percetage expected to be basetypes.Int64Value, was: %T`, maxUnavaliablePercetageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UpdateConfigValue{
		MaxUnavaliable:          maxUnavaliableVal,
		MaxUnavaliablePercetage: maxUnavaliablePercetageVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewUpdateConfigValueNull() UpdateConfigValue {
	return UpdateConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewUpdateConfigValueUnknown() UpdateConfigValue {
	return UpdateConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUpdateConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UpdateConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UpdateConfigValue Attribute Value",
				"While creating a UpdateConfigValue value, a missing attribute value was detected. "+
					"A UpdateConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UpdateConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UpdateConfigValue Attribute Type",
				"While creating a UpdateConfigValue value, an invalid attribute value was detected. "+
					"A UpdateConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UpdateConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UpdateConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UpdateConfigValue Attribute Value",
				"While creating a UpdateConfigValue value, an extra attribute value was detected. "+
					"A UpdateConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UpdateConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUpdateConfigValueUnknown(), diags
	}

	maxUnavaliableAttribute, ok := attributes["max_unavaliable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavaliable is missing from object`)

		return NewUpdateConfigValueUnknown(), diags
	}

	maxUnavaliableVal, ok := maxUnavaliableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavaliable expected to be basetypes.Int64Value, was: %T`, maxUnavaliableAttribute))
	}

	maxUnavaliablePercetageAttribute, ok := attributes["max_unavaliable_percetage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavaliable_percetage is missing from object`)

		return NewUpdateConfigValueUnknown(), diags
	}

	maxUnavaliablePercetageVal, ok := maxUnavaliablePercetageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavaliable_percetage expected to be basetypes.Int64Value, was: %T`, maxUnavaliablePercetageAttribute))
	}

	if diags.HasError() {
		return NewUpdateConfigValueUnknown(), diags
	}

	return UpdateConfigValue{
		MaxUnavaliable:          maxUnavaliableVal,
		MaxUnavaliablePercetage: maxUnavaliablePercetageVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewUpdateConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UpdateConfigValue {
	object, diags := NewUpdateConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUpdateConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UpdateConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUpdateConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUpdateConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUpdateConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUpdateConfigValueMust(UpdateConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UpdateConfigType) ValueType(ctx context.Context) attr.Value {
	return UpdateConfigValue{}
}

var _ basetypes.ObjectValuable = UpdateConfigValue{}

type UpdateConfigValue struct {
	MaxUnavaliable          basetypes.Int64Value `tfsdk:"max_unavaliable"`
	MaxUnavaliablePercetage basetypes.Int64Value `tfsdk:"max_unavaliable_percetage"`
	state                   attr.ValueState
}

func (v UpdateConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["max_unavaliable"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_unavaliable_percetage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MaxUnavaliable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavaliable"] = val

		val, err = v.MaxUnavaliablePercetage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavaliable_percetage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UpdateConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UpdateConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UpdateConfigValue) String() string {
	return "UpdateConfigValue"
}

func (v UpdateConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_unavaliable":           basetypes.Int64Type{},
		"max_unavaliable_percetage": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_unavaliable":           v.MaxUnavaliable,
			"max_unavaliable_percetage": v.MaxUnavaliablePercetage,
		})

	return objVal, diags
}

func (v UpdateConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(UpdateConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxUnavaliable.Equal(other.MaxUnavaliable) {
		return false
	}

	if !v.MaxUnavaliablePercetage.Equal(other.MaxUnavaliablePercetage) {
		return false
	}

	return true
}

func (v UpdateConfigValue) Type(ctx context.Context) attr.Type {
	return UpdateConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UpdateConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_unavaliable":           basetypes.Int64Type{},
		"max_unavaliable_percetage": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrivateClusterType{}

type PrivateClusterType struct {
	basetypes.ObjectType
}

func (t PrivateClusterType) Equal(o attr.Type) bool {
	other, ok := o.(PrivateClusterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrivateClusterType) String() string {
	return "PrivateClusterType"
}

func (t PrivateClusterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalEndpointServicesAttribute, ok := attributes["additional_endpoint_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_endpoint_services is missing from object`)

		return nil, diags
	}

	additionalEndpointServicesVal, ok := additionalEndpointServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_endpoint_services expected to be basetypes.ListValue, was: %T`, additionalEndpointServicesAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	skipEndpointCreationAttribute, ok := attributes["skip_endpoint_creation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_endpoint_creation is missing from object`)

		return nil, diags
	}

	skipEndpointCreationVal, ok := skipEndpointCreationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_endpoint_creation expected to be basetypes.BoolValue, was: %T`, skipEndpointCreationAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrivateClusterValue{
		AdditionalEndpointServices: additionalEndpointServicesVal,
		Enabled:                    enabledVal,
		SkipEndpointCreation:       skipEndpointCreationVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewPrivateClusterValueNull() PrivateClusterValue {
	return PrivateClusterValue{
		state: attr.ValueStateNull,
	}
}

func NewPrivateClusterValueUnknown() PrivateClusterValue {
	return PrivateClusterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrivateClusterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrivateClusterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrivateClusterValue Attribute Value",
				"While creating a PrivateClusterValue value, a missing attribute value was detected. "+
					"A PrivateClusterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivateClusterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrivateClusterValue Attribute Type",
				"While creating a PrivateClusterValue value, an invalid attribute value was detected. "+
					"A PrivateClusterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivateClusterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrivateClusterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrivateClusterValue Attribute Value",
				"While creating a PrivateClusterValue value, an extra attribute value was detected. "+
					"A PrivateClusterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrivateClusterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrivateClusterValueUnknown(), diags
	}

	additionalEndpointServicesAttribute, ok := attributes["additional_endpoint_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_endpoint_services is missing from object`)

		return NewPrivateClusterValueUnknown(), diags
	}

	additionalEndpointServicesVal, ok := additionalEndpointServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_endpoint_services expected to be basetypes.ListValue, was: %T`, additionalEndpointServicesAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewPrivateClusterValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	skipEndpointCreationAttribute, ok := attributes["skip_endpoint_creation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_endpoint_creation is missing from object`)

		return NewPrivateClusterValueUnknown(), diags
	}

	skipEndpointCreationVal, ok := skipEndpointCreationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_endpoint_creation expected to be basetypes.BoolValue, was: %T`, skipEndpointCreationAttribute))
	}

	if diags.HasError() {
		return NewPrivateClusterValueUnknown(), diags
	}

	return PrivateClusterValue{
		AdditionalEndpointServices: additionalEndpointServicesVal,
		Enabled:                    enabledVal,
		SkipEndpointCreation:       skipEndpointCreationVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewPrivateClusterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrivateClusterValue {
	object, diags := NewPrivateClusterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrivateClusterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrivateClusterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrivateClusterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrivateClusterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrivateClusterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrivateClusterValueMust(PrivateClusterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrivateClusterType) ValueType(ctx context.Context) attr.Value {
	return PrivateClusterValue{}
}

var _ basetypes.ObjectValuable = PrivateClusterValue{}

type PrivateClusterValue struct {
	AdditionalEndpointServices basetypes.ListValue `tfsdk:"additional_endpoint_services"`
	Enabled                    basetypes.BoolValue `tfsdk:"enabled"`
	SkipEndpointCreation       basetypes.BoolValue `tfsdk:"skip_endpoint_creation"`
	state                      attr.ValueState
}

func (v PrivateClusterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["additional_endpoint_services"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["skip_endpoint_creation"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AdditionalEndpointServices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_endpoint_services"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.SkipEndpointCreation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip_endpoint_creation"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrivateClusterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrivateClusterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrivateClusterValue) String() string {
	return "PrivateClusterValue"
}

func (v PrivateClusterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var additionalEndpointServicesVal basetypes.ListValue
	switch {
	case v.AdditionalEndpointServices.IsUnknown():
		additionalEndpointServicesVal = types.ListUnknown(types.StringType)
	case v.AdditionalEndpointServices.IsNull():
		additionalEndpointServicesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		additionalEndpointServicesVal, d = types.ListValue(types.StringType, v.AdditionalEndpointServices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_endpoint_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled":                basetypes.BoolType{},
			"skip_endpoint_creation": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_endpoint_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled":                basetypes.BoolType{},
		"skip_endpoint_creation": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_endpoint_services": additionalEndpointServicesVal,
			"enabled":                      v.Enabled,
			"skip_endpoint_creation":       v.SkipEndpointCreation,
		})

	return objVal, diags
}

func (v PrivateClusterValue) Equal(o attr.Value) bool {
	other, ok := o.(PrivateClusterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalEndpointServices.Equal(other.AdditionalEndpointServices) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.SkipEndpointCreation.Equal(other.SkipEndpointCreation) {
		return false
	}

	return true
}

func (v PrivateClusterValue) Type(ctx context.Context) attr.Type {
	return PrivateClusterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrivateClusterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_endpoint_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled":                basetypes.BoolType{},
		"skip_endpoint_creation": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SecretsEncryptionType{}

type SecretsEncryptionType struct {
	basetypes.ObjectType
}

func (t SecretsEncryptionType) Equal(o attr.Type) bool {
	other, ok := o.(SecretsEncryptionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecretsEncryptionType) String() string {
	return "SecretsEncryptionType"
}

func (t SecretsEncryptionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	encryptExistingSecretsAttribute, ok := attributes["encrypt_existing_secrets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encrypt_existing_secrets is missing from object`)

		return nil, diags
	}

	encryptExistingSecretsVal, ok := encryptExistingSecretsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encrypt_existing_secrets expected to be basetypes.BoolValue, was: %T`, encryptExistingSecretsAttribute))
	}

	keyArnAttribute, ok := attributes["key_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_arn is missing from object`)

		return nil, diags
	}

	keyArnVal, ok := keyArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_arn expected to be basetypes.StringValue, was: %T`, keyArnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecretsEncryptionValue{
		EncryptExistingSecrets: encryptExistingSecretsVal,
		KeyArn:                 keyArnVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSecretsEncryptionValueNull() SecretsEncryptionValue {
	return SecretsEncryptionValue{
		state: attr.ValueStateNull,
	}
}

func NewSecretsEncryptionValueUnknown() SecretsEncryptionValue {
	return SecretsEncryptionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecretsEncryptionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecretsEncryptionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecretsEncryptionValue Attribute Value",
				"While creating a SecretsEncryptionValue value, a missing attribute value was detected. "+
					"A SecretsEncryptionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecretsEncryptionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecretsEncryptionValue Attribute Type",
				"While creating a SecretsEncryptionValue value, an invalid attribute value was detected. "+
					"A SecretsEncryptionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecretsEncryptionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecretsEncryptionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecretsEncryptionValue Attribute Value",
				"While creating a SecretsEncryptionValue value, an extra attribute value was detected. "+
					"A SecretsEncryptionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecretsEncryptionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecretsEncryptionValueUnknown(), diags
	}

	encryptExistingSecretsAttribute, ok := attributes["encrypt_existing_secrets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encrypt_existing_secrets is missing from object`)

		return NewSecretsEncryptionValueUnknown(), diags
	}

	encryptExistingSecretsVal, ok := encryptExistingSecretsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encrypt_existing_secrets expected to be basetypes.BoolValue, was: %T`, encryptExistingSecretsAttribute))
	}

	keyArnAttribute, ok := attributes["key_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_arn is missing from object`)

		return NewSecretsEncryptionValueUnknown(), diags
	}

	keyArnVal, ok := keyArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_arn expected to be basetypes.StringValue, was: %T`, keyArnAttribute))
	}

	if diags.HasError() {
		return NewSecretsEncryptionValueUnknown(), diags
	}

	return SecretsEncryptionValue{
		EncryptExistingSecrets: encryptExistingSecretsVal,
		KeyArn:                 keyArnVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSecretsEncryptionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecretsEncryptionValue {
	object, diags := NewSecretsEncryptionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecretsEncryptionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecretsEncryptionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecretsEncryptionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecretsEncryptionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecretsEncryptionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecretsEncryptionValueMust(SecretsEncryptionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecretsEncryptionType) ValueType(ctx context.Context) attr.Value {
	return SecretsEncryptionValue{}
}

var _ basetypes.ObjectValuable = SecretsEncryptionValue{}

type SecretsEncryptionValue struct {
	EncryptExistingSecrets basetypes.BoolValue   `tfsdk:"encrypt_existing_secrets"`
	KeyArn                 basetypes.StringValue `tfsdk:"key_arn"`
	state                  attr.ValueState
}

func (v SecretsEncryptionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["encrypt_existing_secrets"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["key_arn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.EncryptExistingSecrets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encrypt_existing_secrets"] = val

		val, err = v.KeyArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key_arn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecretsEncryptionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecretsEncryptionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecretsEncryptionValue) String() string {
	return "SecretsEncryptionValue"
}

func (v SecretsEncryptionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"encrypt_existing_secrets": basetypes.BoolType{},
		"key_arn":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"encrypt_existing_secrets": v.EncryptExistingSecrets,
			"key_arn":                  v.KeyArn,
		})

	return objVal, diags
}

func (v SecretsEncryptionValue) Equal(o attr.Value) bool {
	other, ok := o.(SecretsEncryptionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EncryptExistingSecrets.Equal(other.EncryptExistingSecrets) {
		return false
	}

	if !v.KeyArn.Equal(other.KeyArn) {
		return false
	}

	return true
}

func (v SecretsEncryptionValue) Type(ctx context.Context) attr.Type {
	return SecretsEncryptionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecretsEncryptionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"encrypt_existing_secrets": basetypes.BoolType{},
		"key_arn":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpcType{}

type VpcType struct {
	basetypes.ObjectType
}

func (t VpcType) Equal(o attr.Type) bool {
	other, ok := o.(VpcType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpcType) String() string {
	return "VpcType"
}

func (t VpcType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoAllocateIpv6Attribute, ok := attributes["auto_allocate_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_allocate_ipv6 is missing from object`)

		return nil, diags
	}

	autoAllocateIpv6Val, ok := autoAllocateIpv6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_allocate_ipv6 expected to be basetypes.BoolValue, was: %T`, autoAllocateIpv6Attribute))
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	clusterEndpointsAttribute, ok := attributes["cluster_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_endpoints is missing from object`)

		return nil, diags
	}

	clusterEndpointsVal, ok := clusterEndpointsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_endpoints expected to be basetypes.ListValue, was: %T`, clusterEndpointsAttribute))
	}

	extraCidrsAttribute, ok := attributes["extra_cidrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_cidrs is missing from object`)

		return nil, diags
	}

	extraCidrsVal, ok := extraCidrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_cidrs expected to be basetypes.ListValue, was: %T`, extraCidrsAttribute))
	}

	extraIpv6CidrsAttribute, ok := attributes["extra_ipv6_cidrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_ipv6_cidrs is missing from object`)

		return nil, diags
	}

	extraIpv6CidrsVal, ok := extraIpv6CidrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_ipv6_cidrs expected to be basetypes.ListValue, was: %T`, extraIpv6CidrsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	ipv6CidrAttribute, ok := attributes["ipv6_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_cidr is missing from object`)

		return nil, diags
	}

	ipv6CidrVal, ok := ipv6CidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_cidr expected to be basetypes.StringValue, was: %T`, ipv6CidrAttribute))
	}

	ipv6PoolAttribute, ok := attributes["ipv6_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pool is missing from object`)

		return nil, diags
	}

	ipv6PoolVal, ok := ipv6PoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pool expected to be basetypes.StringValue, was: %T`, ipv6PoolAttribute))
	}

	manageSharedNodeSecurityGroupRulesAttribute, ok := attributes["manage_shared_node_security_group_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manage_shared_node_security_group_rules is missing from object`)

		return nil, diags
	}

	manageSharedNodeSecurityGroupRulesVal, ok := manageSharedNodeSecurityGroupRulesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manage_shared_node_security_group_rules expected to be basetypes.BoolValue, was: %T`, manageSharedNodeSecurityGroupRulesAttribute))
	}

	natAttribute, ok := attributes["nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat is missing from object`)

		return nil, diags
	}

	natVal, ok := natAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat expected to be basetypes.ListValue, was: %T`, natAttribute))
	}

	publicAccessCidrsAttribute, ok := attributes["public_access_cidrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_access_cidrs is missing from object`)

		return nil, diags
	}

	publicAccessCidrsVal, ok := publicAccessCidrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_access_cidrs expected to be basetypes.ListValue, was: %T`, publicAccessCidrsAttribute))
	}

	securityGroupAttribute, ok := attributes["security_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group is missing from object`)

		return nil, diags
	}

	securityGroupVal, ok := securityGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group expected to be basetypes.StringValue, was: %T`, securityGroupAttribute))
	}

	sharedNodeSecurityGroupAttribute, ok := attributes["shared_node_security_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shared_node_security_group is missing from object`)

		return nil, diags
	}

	sharedNodeSecurityGroupVal, ok := sharedNodeSecurityGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shared_node_security_group expected to be basetypes.StringValue, was: %T`, sharedNodeSecurityGroupAttribute))
	}

	subnets3Attribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets3 is missing from object`)

		return nil, diags
	}

	subnets3Val, ok := subnets3Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets3 expected to be basetypes.ListValue, was: %T`, subnets3Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpcValue{
		AutoAllocateIpv6:                   autoAllocateIpv6Val,
		Cidr:                               cidrVal,
		ClusterEndpoints:                   clusterEndpointsVal,
		ExtraCidrs:                         extraCidrsVal,
		ExtraIpv6Cidrs:                     extraIpv6CidrsVal,
		Id:                                 idVal,
		Ipv6Cidr:                           ipv6CidrVal,
		Ipv6Pool:                           ipv6PoolVal,
		ManageSharedNodeSecurityGroupRules: manageSharedNodeSecurityGroupRulesVal,
		Nat:                                natVal,
		PublicAccessCidrs:                  publicAccessCidrsVal,
		SecurityGroup:                      securityGroupVal,
		SharedNodeSecurityGroup:            sharedNodeSecurityGroupVal,
		Subnets3:                           subnets3Val,
		state:                              attr.ValueStateKnown,
	}, diags
}

func NewVpcValueNull() VpcValue {
	return VpcValue{
		state: attr.ValueStateNull,
	}
}

func NewVpcValueUnknown() VpcValue {
	return VpcValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpcValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpcValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpcValue Attribute Value",
				"While creating a VpcValue value, a missing attribute value was detected. "+
					"A VpcValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpcValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpcValue Attribute Type",
				"While creating a VpcValue value, an invalid attribute value was detected. "+
					"A VpcValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpcValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpcValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpcValue Attribute Value",
				"While creating a VpcValue value, an extra attribute value was detected. "+
					"A VpcValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpcValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpcValueUnknown(), diags
	}

	autoAllocateIpv6Attribute, ok := attributes["auto_allocate_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_allocate_ipv6 is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	autoAllocateIpv6Val, ok := autoAllocateIpv6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_allocate_ipv6 expected to be basetypes.BoolValue, was: %T`, autoAllocateIpv6Attribute))
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	clusterEndpointsAttribute, ok := attributes["cluster_endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_endpoints is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	clusterEndpointsVal, ok := clusterEndpointsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_endpoints expected to be basetypes.ListValue, was: %T`, clusterEndpointsAttribute))
	}

	extraCidrsAttribute, ok := attributes["extra_cidrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_cidrs is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	extraCidrsVal, ok := extraCidrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_cidrs expected to be basetypes.ListValue, was: %T`, extraCidrsAttribute))
	}

	extraIpv6CidrsAttribute, ok := attributes["extra_ipv6_cidrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_ipv6_cidrs is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	extraIpv6CidrsVal, ok := extraIpv6CidrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_ipv6_cidrs expected to be basetypes.ListValue, was: %T`, extraIpv6CidrsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	ipv6CidrAttribute, ok := attributes["ipv6_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_cidr is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	ipv6CidrVal, ok := ipv6CidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_cidr expected to be basetypes.StringValue, was: %T`, ipv6CidrAttribute))
	}

	ipv6PoolAttribute, ok := attributes["ipv6_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pool is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	ipv6PoolVal, ok := ipv6PoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pool expected to be basetypes.StringValue, was: %T`, ipv6PoolAttribute))
	}

	manageSharedNodeSecurityGroupRulesAttribute, ok := attributes["manage_shared_node_security_group_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manage_shared_node_security_group_rules is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	manageSharedNodeSecurityGroupRulesVal, ok := manageSharedNodeSecurityGroupRulesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manage_shared_node_security_group_rules expected to be basetypes.BoolValue, was: %T`, manageSharedNodeSecurityGroupRulesAttribute))
	}

	natAttribute, ok := attributes["nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	natVal, ok := natAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat expected to be basetypes.ListValue, was: %T`, natAttribute))
	}

	publicAccessCidrsAttribute, ok := attributes["public_access_cidrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_access_cidrs is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	publicAccessCidrsVal, ok := publicAccessCidrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_access_cidrs expected to be basetypes.ListValue, was: %T`, publicAccessCidrsAttribute))
	}

	securityGroupAttribute, ok := attributes["security_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_group is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	securityGroupVal, ok := securityGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_group expected to be basetypes.StringValue, was: %T`, securityGroupAttribute))
	}

	sharedNodeSecurityGroupAttribute, ok := attributes["shared_node_security_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shared_node_security_group is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	sharedNodeSecurityGroupVal, ok := sharedNodeSecurityGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shared_node_security_group expected to be basetypes.StringValue, was: %T`, sharedNodeSecurityGroupAttribute))
	}

	subnets3Attribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets3 is missing from object`)

		return NewVpcValueUnknown(), diags
	}

	subnets3Val, ok := subnets3Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets3 expected to be basetypes.ListValue, was: %T`, subnets3Attribute))
	}

	if diags.HasError() {
		return NewVpcValueUnknown(), diags
	}

	return VpcValue{
		AutoAllocateIpv6:                   autoAllocateIpv6Val,
		Cidr:                               cidrVal,
		ClusterEndpoints:                   clusterEndpointsVal,
		ExtraCidrs:                         extraCidrsVal,
		ExtraIpv6Cidrs:                     extraIpv6CidrsVal,
		Id:                                 idVal,
		Ipv6Cidr:                           ipv6CidrVal,
		Ipv6Pool:                           ipv6PoolVal,
		ManageSharedNodeSecurityGroupRules: manageSharedNodeSecurityGroupRulesVal,
		Nat:                                natVal,
		PublicAccessCidrs:                  publicAccessCidrsVal,
		SecurityGroup:                      securityGroupVal,
		SharedNodeSecurityGroup:            sharedNodeSecurityGroupVal,
		Subnets3:                           subnets3Val,
		state:                              attr.ValueStateKnown,
	}, diags
}

func NewVpcValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpcValue {
	object, diags := NewVpcValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpcValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpcType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpcValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpcValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpcValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpcValueMust(VpcValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpcType) ValueType(ctx context.Context) attr.Value {
	return VpcValue{}
}

var _ basetypes.ObjectValuable = VpcValue{}

type VpcValue struct {
	AutoAllocateIpv6                   basetypes.BoolValue   `tfsdk:"auto_allocate_ipv6"`
	Cidr                               basetypes.StringValue `tfsdk:"cidr"`
	ClusterEndpoints                   basetypes.ListValue   `tfsdk:"cluster_endpoints"`
	ExtraCidrs                         basetypes.ListValue   `tfsdk:"extra_cidrs"`
	ExtraIpv6Cidrs                     basetypes.ListValue   `tfsdk:"extra_ipv6_cidrs"`
	Id                                 basetypes.StringValue `tfsdk:"id"`
	Ipv6Cidr                           basetypes.StringValue `tfsdk:"ipv6_cidr"`
	Ipv6Pool                           basetypes.StringValue `tfsdk:"ipv6_pool"`
	ManageSharedNodeSecurityGroupRules basetypes.BoolValue   `tfsdk:"manage_shared_node_security_group_rules"`
	Nat                                basetypes.ListValue   `tfsdk:"nat"`
	PublicAccessCidrs                  basetypes.ListValue   `tfsdk:"public_access_cidrs"`
	SecurityGroup                      basetypes.StringValue `tfsdk:"security_group"`
	SharedNodeSecurityGroup            basetypes.StringValue `tfsdk:"shared_node_security_group"`
	Subnets3                           basetypes.ListValue   `tfsdk:"subnets"`
	state                              attr.ValueState
}

func (v VpcValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["auto_allocate_ipv6"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cluster_endpoints"] = basetypes.ListType{
		ElemType: ClusterEndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["extra_cidrs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["extra_ipv6_cidrs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["manage_shared_node_security_group_rules"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nat"] = basetypes.ListType{
		ElemType: NatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["public_access_cidrs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["security_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["shared_node_security_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: Subnets3Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.AutoAllocateIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_allocate_ipv6"] = val

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.ClusterEndpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_endpoints"] = val

		val, err = v.ExtraCidrs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extra_cidrs"] = val

		val, err = v.ExtraIpv6Cidrs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extra_ipv6_cidrs"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Ipv6Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_cidr"] = val

		val, err = v.Ipv6Pool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_pool"] = val

		val, err = v.ManageSharedNodeSecurityGroupRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["manage_shared_node_security_group_rules"] = val

		val, err = v.Nat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat"] = val

		val, err = v.PublicAccessCidrs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_access_cidrs"] = val

		val, err = v.SecurityGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_group"] = val

		val, err = v.SharedNodeSecurityGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["shared_node_security_group"] = val

		val, err = v.Subnets3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpcValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpcValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpcValue) String() string {
	return "VpcValue"
}

func (v VpcValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	clusterEndpoints := types.ListValueMust(
		ClusterEndpointsType{
			basetypes.ObjectType{
				AttrTypes: ClusterEndpointsValue{}.AttributeTypes(ctx),
			},
		},
		v.ClusterEndpoints.Elements(),
	)

	if v.ClusterEndpoints.IsNull() {
		clusterEndpoints = types.ListNull(
			ClusterEndpointsType{
				basetypes.ObjectType{
					AttrTypes: ClusterEndpointsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ClusterEndpoints.IsUnknown() {
		clusterEndpoints = types.ListUnknown(
			ClusterEndpointsType{
				basetypes.ObjectType{
					AttrTypes: ClusterEndpointsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nat := types.ListValueMust(
		NatType{
			basetypes.ObjectType{
				AttrTypes: NatValue{}.AttributeTypes(ctx),
			},
		},
		v.Nat.Elements(),
	)

	if v.Nat.IsNull() {
		nat = types.ListNull(
			NatType{
				basetypes.ObjectType{
					AttrTypes: NatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Nat.IsUnknown() {
		nat = types.ListUnknown(
			NatType{
				basetypes.ObjectType{
					AttrTypes: NatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	subnets3 := types.ListValueMust(
		Subnets3Type{
			basetypes.ObjectType{
				AttrTypes: Subnets3Value{}.AttributeTypes(ctx),
			},
		},
		v.Subnets3.Elements(),
	)

	if v.Subnets3.IsNull() {
		subnets3 = types.ListNull(
			Subnets3Type{
				basetypes.ObjectType{
					AttrTypes: Subnets3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Subnets3.IsUnknown() {
		subnets3 = types.ListUnknown(
			Subnets3Type{
				basetypes.ObjectType{
					AttrTypes: Subnets3Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var extraCidrsVal basetypes.ListValue
	switch {
	case v.ExtraCidrs.IsUnknown():
		extraCidrsVal = types.ListUnknown(types.StringType)
	case v.ExtraCidrs.IsNull():
		extraCidrsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		extraCidrsVal, d = types.ListValue(types.StringType, v.ExtraCidrs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_allocate_ipv6": basetypes.BoolType{},
			"cidr":               basetypes.StringType{},
			"cluster_endpoints": basetypes.ListType{
				ElemType: ClusterEndpointsValue{}.Type(ctx),
			},
			"extra_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"extra_ipv6_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id":        basetypes.StringType{},
			"ipv6_cidr": basetypes.StringType{},
			"ipv6_pool": basetypes.StringType{},
			"manage_shared_node_security_group_rules": basetypes.BoolType{},
			"nat": basetypes.ListType{
				ElemType: NatValue{}.Type(ctx),
			},
			"public_access_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"security_group":             basetypes.StringType{},
			"shared_node_security_group": basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: Subnets3Value{}.Type(ctx),
			},
		}), diags
	}

	var extraIpv6CidrsVal basetypes.ListValue
	switch {
	case v.ExtraIpv6Cidrs.IsUnknown():
		extraIpv6CidrsVal = types.ListUnknown(types.StringType)
	case v.ExtraIpv6Cidrs.IsNull():
		extraIpv6CidrsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		extraIpv6CidrsVal, d = types.ListValue(types.StringType, v.ExtraIpv6Cidrs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_allocate_ipv6": basetypes.BoolType{},
			"cidr":               basetypes.StringType{},
			"cluster_endpoints": basetypes.ListType{
				ElemType: ClusterEndpointsValue{}.Type(ctx),
			},
			"extra_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"extra_ipv6_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id":        basetypes.StringType{},
			"ipv6_cidr": basetypes.StringType{},
			"ipv6_pool": basetypes.StringType{},
			"manage_shared_node_security_group_rules": basetypes.BoolType{},
			"nat": basetypes.ListType{
				ElemType: NatValue{}.Type(ctx),
			},
			"public_access_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"security_group":             basetypes.StringType{},
			"shared_node_security_group": basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: Subnets3Value{}.Type(ctx),
			},
		}), diags
	}

	var publicAccessCidrsVal basetypes.ListValue
	switch {
	case v.PublicAccessCidrs.IsUnknown():
		publicAccessCidrsVal = types.ListUnknown(types.StringType)
	case v.PublicAccessCidrs.IsNull():
		publicAccessCidrsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		publicAccessCidrsVal, d = types.ListValue(types.StringType, v.PublicAccessCidrs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_allocate_ipv6": basetypes.BoolType{},
			"cidr":               basetypes.StringType{},
			"cluster_endpoints": basetypes.ListType{
				ElemType: ClusterEndpointsValue{}.Type(ctx),
			},
			"extra_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"extra_ipv6_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id":        basetypes.StringType{},
			"ipv6_cidr": basetypes.StringType{},
			"ipv6_pool": basetypes.StringType{},
			"manage_shared_node_security_group_rules": basetypes.BoolType{},
			"nat": basetypes.ListType{
				ElemType: NatValue{}.Type(ctx),
			},
			"public_access_cidrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"security_group":             basetypes.StringType{},
			"shared_node_security_group": basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: Subnets3Value{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auto_allocate_ipv6": basetypes.BoolType{},
		"cidr":               basetypes.StringType{},
		"cluster_endpoints": basetypes.ListType{
			ElemType: ClusterEndpointsValue{}.Type(ctx),
		},
		"extra_cidrs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"extra_ipv6_cidrs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"id":        basetypes.StringType{},
		"ipv6_cidr": basetypes.StringType{},
		"ipv6_pool": basetypes.StringType{},
		"manage_shared_node_security_group_rules": basetypes.BoolType{},
		"nat": basetypes.ListType{
			ElemType: NatValue{}.Type(ctx),
		},
		"public_access_cidrs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"security_group":             basetypes.StringType{},
		"shared_node_security_group": basetypes.StringType{},
		"subnets": basetypes.ListType{
			ElemType: Subnets3Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_allocate_ipv6": v.AutoAllocateIpv6,
			"cidr":               v.Cidr,
			"cluster_endpoints":  clusterEndpoints,
			"extra_cidrs":        extraCidrsVal,
			"extra_ipv6_cidrs":   extraIpv6CidrsVal,
			"id":                 v.Id,
			"ipv6_cidr":          v.Ipv6Cidr,
			"ipv6_pool":          v.Ipv6Pool,
			"manage_shared_node_security_group_rules": v.ManageSharedNodeSecurityGroupRules,
			"nat":                        nat,
			"public_access_cidrs":        publicAccessCidrsVal,
			"security_group":             v.SecurityGroup,
			"shared_node_security_group": v.SharedNodeSecurityGroup,
			"subnets":                    subnets3,
		})

	return objVal, diags
}

func (v VpcValue) Equal(o attr.Value) bool {
	other, ok := o.(VpcValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoAllocateIpv6.Equal(other.AutoAllocateIpv6) {
		return false
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.ClusterEndpoints.Equal(other.ClusterEndpoints) {
		return false
	}

	if !v.ExtraCidrs.Equal(other.ExtraCidrs) {
		return false
	}

	if !v.ExtraIpv6Cidrs.Equal(other.ExtraIpv6Cidrs) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Ipv6Cidr.Equal(other.Ipv6Cidr) {
		return false
	}

	if !v.Ipv6Pool.Equal(other.Ipv6Pool) {
		return false
	}

	if !v.ManageSharedNodeSecurityGroupRules.Equal(other.ManageSharedNodeSecurityGroupRules) {
		return false
	}

	if !v.Nat.Equal(other.Nat) {
		return false
	}

	if !v.PublicAccessCidrs.Equal(other.PublicAccessCidrs) {
		return false
	}

	if !v.SecurityGroup.Equal(other.SecurityGroup) {
		return false
	}

	if !v.SharedNodeSecurityGroup.Equal(other.SharedNodeSecurityGroup) {
		return false
	}

	if !v.Subnets3.Equal(other.Subnets3) {
		return false
	}

	return true
}

func (v VpcValue) Type(ctx context.Context) attr.Type {
	return VpcType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpcValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_allocate_ipv6": basetypes.BoolType{},
		"cidr":               basetypes.StringType{},
		"cluster_endpoints": basetypes.ListType{
			ElemType: ClusterEndpointsValue{}.Type(ctx),
		},
		"extra_cidrs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"extra_ipv6_cidrs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"id":        basetypes.StringType{},
		"ipv6_cidr": basetypes.StringType{},
		"ipv6_pool": basetypes.StringType{},
		"manage_shared_node_security_group_rules": basetypes.BoolType{},
		"nat": basetypes.ListType{
			ElemType: NatValue{}.Type(ctx),
		},
		"public_access_cidrs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"security_group":             basetypes.StringType{},
		"shared_node_security_group": basetypes.StringType{},
		"subnets": basetypes.ListType{
			ElemType: Subnets3Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterEndpointsType{}

type ClusterEndpointsType struct {
	basetypes.ObjectType
}

func (t ClusterEndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterEndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterEndpointsType) String() string {
	return "ClusterEndpointsType"
}

func (t ClusterEndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	privateAccessAttribute, ok := attributes["private_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_access is missing from object`)

		return nil, diags
	}

	privateAccessVal, ok := privateAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_access expected to be basetypes.BoolValue, was: %T`, privateAccessAttribute))
	}

	publicAccessAttribute, ok := attributes["public_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_access is missing from object`)

		return nil, diags
	}

	publicAccessVal, ok := publicAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_access expected to be basetypes.BoolValue, was: %T`, publicAccessAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterEndpointsValue{
		PrivateAccess: privateAccessVal,
		PublicAccess:  publicAccessVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewClusterEndpointsValueNull() ClusterEndpointsValue {
	return ClusterEndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterEndpointsValueUnknown() ClusterEndpointsValue {
	return ClusterEndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterEndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterEndpointsValue Attribute Value",
				"While creating a ClusterEndpointsValue value, a missing attribute value was detected. "+
					"A ClusterEndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterEndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterEndpointsValue Attribute Type",
				"While creating a ClusterEndpointsValue value, an invalid attribute value was detected. "+
					"A ClusterEndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterEndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterEndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterEndpointsValue Attribute Value",
				"While creating a ClusterEndpointsValue value, an extra attribute value was detected. "+
					"A ClusterEndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterEndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterEndpointsValueUnknown(), diags
	}

	privateAccessAttribute, ok := attributes["private_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_access is missing from object`)

		return NewClusterEndpointsValueUnknown(), diags
	}

	privateAccessVal, ok := privateAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_access expected to be basetypes.BoolValue, was: %T`, privateAccessAttribute))
	}

	publicAccessAttribute, ok := attributes["public_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_access is missing from object`)

		return NewClusterEndpointsValueUnknown(), diags
	}

	publicAccessVal, ok := publicAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_access expected to be basetypes.BoolValue, was: %T`, publicAccessAttribute))
	}

	if diags.HasError() {
		return NewClusterEndpointsValueUnknown(), diags
	}

	return ClusterEndpointsValue{
		PrivateAccess: privateAccessVal,
		PublicAccess:  publicAccessVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewClusterEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterEndpointsValue {
	object, diags := NewClusterEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterEndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterEndpointsValueMust(ClusterEndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterEndpointsType) ValueType(ctx context.Context) attr.Value {
	return ClusterEndpointsValue{}
}

var _ basetypes.ObjectValuable = ClusterEndpointsValue{}

type ClusterEndpointsValue struct {
	PrivateAccess basetypes.BoolValue `tfsdk:"private_access"`
	PublicAccess  basetypes.BoolValue `tfsdk:"public_access"`
	state         attr.ValueState
}

func (v ClusterEndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["private_access"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["public_access"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrivateAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_access"] = val

		val, err = v.PublicAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_access"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterEndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterEndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterEndpointsValue) String() string {
	return "ClusterEndpointsValue"
}

func (v ClusterEndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"private_access": basetypes.BoolType{},
		"public_access":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"private_access": v.PrivateAccess,
			"public_access":  v.PublicAccess,
		})

	return objVal, diags
}

func (v ClusterEndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterEndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrivateAccess.Equal(other.PrivateAccess) {
		return false
	}

	if !v.PublicAccess.Equal(other.PublicAccess) {
		return false
	}

	return true
}

func (v ClusterEndpointsValue) Type(ctx context.Context) attr.Type {
	return ClusterEndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterEndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"private_access": basetypes.BoolType{},
		"public_access":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = NatType{}

type NatType struct {
	basetypes.ObjectType
}

func (t NatType) Equal(o attr.Type) bool {
	other, ok := o.(NatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NatType) String() string {
	return "NatType"
}

func (t NatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NatValue{
		Gateway: gatewayVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNatValueNull() NatValue {
	return NatValue{
		state: attr.ValueStateNull,
	}
}

func NewNatValueUnknown() NatValue {
	return NatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NatValue Attribute Value",
				"While creating a NatValue value, a missing attribute value was detected. "+
					"A NatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NatValue Attribute Type",
				"While creating a NatValue value, an invalid attribute value was detected. "+
					"A NatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NatValue Attribute Value",
				"While creating a NatValue value, an extra attribute value was detected. "+
					"A NatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNatValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewNatValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	if diags.HasError() {
		return NewNatValueUnknown(), diags
	}

	return NatValue{
		Gateway: gatewayVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NatValue {
	object, diags := NewNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNatValueMust(NatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NatType) ValueType(ctx context.Context) attr.Value {
	return NatValue{}
}

var _ basetypes.ObjectValuable = NatValue{}

type NatValue struct {
	Gateway basetypes.StringValue `tfsdk:"gateway"`
	state   attr.ValueState
}

func (v NatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NatValue) String() string {
	return "NatValue"
}

func (v NatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"gateway": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gateway": v.Gateway,
		})

	return objVal, diags
}

func (v NatValue) Equal(o attr.Value) bool {
	other, ok := o.(NatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	return true
}

func (v NatValue) Type(ctx context.Context) attr.Type {
	return NatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Subnets3Type{}

type Subnets3Type struct {
	basetypes.ObjectType
}

func (t Subnets3Type) Equal(o attr.Type) bool {
	other, ok := o.(Subnets3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Subnets3Type) String() string {
	return "Subnets3Type"
}

func (t Subnets3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	privateAttribute, ok := attributes["private"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private is missing from object`)

		return nil, diags
	}

	privateVal, ok := privateAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private expected to be basetypes.SetValue, was: %T`, privateAttribute))
	}

	publicAttribute, ok := attributes["public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public is missing from object`)

		return nil, diags
	}

	publicVal, ok := publicAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public expected to be basetypes.SetValue, was: %T`, publicAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Subnets3Value{
		Private: privateVal,
		Public:  publicVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSubnets3ValueNull() Subnets3Value {
	return Subnets3Value{
		state: attr.ValueStateNull,
	}
}

func NewSubnets3ValueUnknown() Subnets3Value {
	return Subnets3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSubnets3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Subnets3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Subnets3Value Attribute Value",
				"While creating a Subnets3Value value, a missing attribute value was detected. "+
					"A Subnets3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subnets3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Subnets3Value Attribute Type",
				"While creating a Subnets3Value value, an invalid attribute value was detected. "+
					"A Subnets3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Subnets3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Subnets3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Subnets3Value Attribute Value",
				"While creating a Subnets3Value value, an extra attribute value was detected. "+
					"A Subnets3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Subnets3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubnets3ValueUnknown(), diags
	}

	privateAttribute, ok := attributes["private"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private is missing from object`)

		return NewSubnets3ValueUnknown(), diags
	}

	privateVal, ok := privateAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private expected to be basetypes.SetValue, was: %T`, privateAttribute))
	}

	publicAttribute, ok := attributes["public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public is missing from object`)

		return NewSubnets3ValueUnknown(), diags
	}

	publicVal, ok := publicAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public expected to be basetypes.SetValue, was: %T`, publicAttribute))
	}

	if diags.HasError() {
		return NewSubnets3ValueUnknown(), diags
	}

	return Subnets3Value{
		Private: privateVal,
		Public:  publicVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSubnets3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Subnets3Value {
	object, diags := NewSubnets3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubnets3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Subnets3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubnets3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubnets3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubnets3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubnets3ValueMust(Subnets3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Subnets3Type) ValueType(ctx context.Context) attr.Value {
	return Subnets3Value{}
}

var _ basetypes.ObjectValuable = Subnets3Value{}

type Subnets3Value struct {
	Private basetypes.SetValue `tfsdk:"private"`
	Public  basetypes.SetValue `tfsdk:"public"`
	state   attr.ValueState
}

func (v Subnets3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["private"] = basetypes.SetType{
		ElemType: PrivateValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["public"] = basetypes.SetType{
		ElemType: PublicValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Private.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private"] = val

		val, err = v.Public.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Subnets3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Subnets3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Subnets3Value) String() string {
	return "Subnets3Value"
}

func (v Subnets3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	private := types.SetValueMust(
		PrivateType{
			basetypes.ObjectType{
				AttrTypes: PrivateValue{}.AttributeTypes(ctx),
			},
		},
		v.Private.Elements(),
	)

	if v.Private.IsNull() {
		private = types.SetNull(
			PrivateType{
				basetypes.ObjectType{
					AttrTypes: PrivateValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Private.IsUnknown() {
		private = types.SetUnknown(
			PrivateType{
				basetypes.ObjectType{
					AttrTypes: PrivateValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	public := types.SetValueMust(
		PublicType{
			basetypes.ObjectType{
				AttrTypes: PublicValue{}.AttributeTypes(ctx),
			},
		},
		v.Public.Elements(),
	)

	if v.Public.IsNull() {
		public = types.SetNull(
			PublicType{
				basetypes.ObjectType{
					AttrTypes: PublicValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Public.IsUnknown() {
		public = types.SetUnknown(
			PublicType{
				basetypes.ObjectType{
					AttrTypes: PublicValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"private": basetypes.SetType{
			ElemType: PrivateValue{}.Type(ctx),
		},
		"public": basetypes.SetType{
			ElemType: PublicValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"private": private,
			"public":  public,
		})

	return objVal, diags
}

func (v Subnets3Value) Equal(o attr.Value) bool {
	other, ok := o.(Subnets3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Private.Equal(other.Private) {
		return false
	}

	if !v.Public.Equal(other.Public) {
		return false
	}

	return true
}

func (v Subnets3Value) Type(ctx context.Context) attr.Type {
	return Subnets3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Subnets3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"private": basetypes.SetType{
			ElemType: PrivateValue{}.Type(ctx),
		},
		"public": basetypes.SetType{
			ElemType: PublicValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrivateType{}

type PrivateType struct {
	basetypes.ObjectType
}

func (t PrivateType) Equal(o attr.Type) bool {
	other, ok := o.(PrivateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrivateType) String() string {
	return "PrivateType"
}

func (t PrivateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	azAttribute, ok := attributes["az"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`az is missing from object`)

		return nil, diags
	}

	azVal, ok := azAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`az expected to be basetypes.StringValue, was: %T`, azAttribute))
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrivateValue{
		Az:    azVal,
		Cidr:  cidrVal,
		Id:    idVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPrivateValueNull() PrivateValue {
	return PrivateValue{
		state: attr.ValueStateNull,
	}
}

func NewPrivateValueUnknown() PrivateValue {
	return PrivateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrivateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrivateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrivateValue Attribute Value",
				"While creating a PrivateValue value, a missing attribute value was detected. "+
					"A PrivateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrivateValue Attribute Type",
				"While creating a PrivateValue value, an invalid attribute value was detected. "+
					"A PrivateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrivateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrivateValue Attribute Value",
				"While creating a PrivateValue value, an extra attribute value was detected. "+
					"A PrivateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrivateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrivateValueUnknown(), diags
	}

	azAttribute, ok := attributes["az"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`az is missing from object`)

		return NewPrivateValueUnknown(), diags
	}

	azVal, ok := azAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`az expected to be basetypes.StringValue, was: %T`, azAttribute))
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewPrivateValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPrivateValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPrivateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewPrivateValueUnknown(), diags
	}

	return PrivateValue{
		Az:    azVal,
		Cidr:  cidrVal,
		Id:    idVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPrivateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrivateValue {
	object, diags := NewPrivateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrivateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrivateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrivateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrivateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrivateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrivateValueMust(PrivateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrivateType) ValueType(ctx context.Context) attr.Value {
	return PrivateValue{}
}

var _ basetypes.ObjectValuable = PrivateValue{}

type PrivateValue struct {
	Az    basetypes.StringValue `tfsdk:"az"`
	Cidr  basetypes.StringValue `tfsdk:"cidr"`
	Id    basetypes.StringValue `tfsdk:"id"`
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v PrivateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["az"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Az.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["az"] = val

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrivateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrivateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrivateValue) String() string {
	return "PrivateValue"
}

func (v PrivateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"az":   basetypes.StringType{},
		"cidr": basetypes.StringType{},
		"id":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"az":   v.Az,
			"cidr": v.Cidr,
			"id":   v.Id,
			"name": v.Name,
		})

	return objVal, diags
}

func (v PrivateValue) Equal(o attr.Value) bool {
	other, ok := o.(PrivateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Az.Equal(other.Az) {
		return false
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v PrivateValue) Type(ctx context.Context) attr.Type {
	return PrivateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrivateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"az":   basetypes.StringType{},
		"cidr": basetypes.StringType{},
		"id":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PublicType{}

type PublicType struct {
	basetypes.ObjectType
}

func (t PublicType) Equal(o attr.Type) bool {
	other, ok := o.(PublicType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PublicType) String() string {
	return "PublicType"
}

func (t PublicType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	azAttribute, ok := attributes["az"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`az is missing from object`)

		return nil, diags
	}

	azVal, ok := azAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`az expected to be basetypes.StringValue, was: %T`, azAttribute))
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PublicValue{
		Az:    azVal,
		Cidr:  cidrVal,
		Id:    idVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPublicValueNull() PublicValue {
	return PublicValue{
		state: attr.ValueStateNull,
	}
}

func NewPublicValueUnknown() PublicValue {
	return PublicValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPublicValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PublicValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PublicValue Attribute Value",
				"While creating a PublicValue value, a missing attribute value was detected. "+
					"A PublicValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PublicValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PublicValue Attribute Type",
				"While creating a PublicValue value, an invalid attribute value was detected. "+
					"A PublicValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PublicValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PublicValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PublicValue Attribute Value",
				"While creating a PublicValue value, an extra attribute value was detected. "+
					"A PublicValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PublicValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPublicValueUnknown(), diags
	}

	azAttribute, ok := attributes["az"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`az is missing from object`)

		return NewPublicValueUnknown(), diags
	}

	azVal, ok := azAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`az expected to be basetypes.StringValue, was: %T`, azAttribute))
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewPublicValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPublicValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPublicValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewPublicValueUnknown(), diags
	}

	return PublicValue{
		Az:    azVal,
		Cidr:  cidrVal,
		Id:    idVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPublicValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PublicValue {
	object, diags := NewPublicValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPublicValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PublicType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPublicValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPublicValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPublicValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPublicValueMust(PublicValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PublicType) ValueType(ctx context.Context) attr.Value {
	return PublicValue{}
}

var _ basetypes.ObjectValuable = PublicValue{}

type PublicValue struct {
	Az    basetypes.StringValue `tfsdk:"az"`
	Cidr  basetypes.StringValue `tfsdk:"cidr"`
	Id    basetypes.StringValue `tfsdk:"id"`
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v PublicValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["az"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Az.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["az"] = val

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PublicValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PublicValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PublicValue) String() string {
	return "PublicValue"
}

func (v PublicValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"az":   basetypes.StringType{},
		"cidr": basetypes.StringType{},
		"id":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"az":   v.Az,
			"cidr": v.Cidr,
			"id":   v.Id,
			"name": v.Name,
		})

	return objVal, diags
}

func (v PublicValue) Equal(o attr.Value) bool {
	other, ok := o.(PublicValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Az.Equal(other.Az) {
		return false
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v PublicValue) Type(ctx context.Context) attr.Type {
	return PublicType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PublicValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"az":   basetypes.StringType{},
		"cidr": basetypes.StringType{},
		"id":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TimeoutsType{}

type TimeoutsType struct {
	basetypes.ObjectType
}

func (t TimeoutsType) Equal(o attr.Type) bool {
	other, ok := o.(TimeoutsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimeoutsType) String() string {
	return "TimeoutsType"
}

func (t TimeoutsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createAttribute, ok := attributes["create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create is missing from object`)

		return nil, diags
	}

	createVal, ok := createAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create expected to be basetypes.StringValue, was: %T`, createAttribute))
	}

	deleteAttribute, ok := attributes["delete"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete is missing from object`)

		return nil, diags
	}

	deleteVal, ok := deleteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete expected to be basetypes.StringValue, was: %T`, deleteAttribute))
	}

	updateAttribute, ok := attributes["update"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update is missing from object`)

		return nil, diags
	}

	updateVal, ok := updateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update expected to be basetypes.StringValue, was: %T`, updateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TimeoutsValue{
		Create: createVal,
		Delete: deleteVal,
		Update: updateVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTimeoutsValueNull() TimeoutsValue {
	return TimeoutsValue{
		state: attr.ValueStateNull,
	}
}

func NewTimeoutsValueUnknown() TimeoutsValue {
	return TimeoutsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimeoutsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimeoutsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimeoutsValue Attribute Value",
				"While creating a TimeoutsValue value, a missing attribute value was detected. "+
					"A TimeoutsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimeoutsValue Attribute Type",
				"While creating a TimeoutsValue value, an invalid attribute value was detected. "+
					"A TimeoutsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimeoutsValue Attribute Value",
				"While creating a TimeoutsValue value, an extra attribute value was detected. "+
					"A TimeoutsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimeoutsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimeoutsValueUnknown(), diags
	}

	createAttribute, ok := attributes["create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create is missing from object`)

		return NewTimeoutsValueUnknown(), diags
	}

	createVal, ok := createAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create expected to be basetypes.StringValue, was: %T`, createAttribute))
	}

	deleteAttribute, ok := attributes["delete"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`delete is missing from object`)

		return NewTimeoutsValueUnknown(), diags
	}

	deleteVal, ok := deleteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`delete expected to be basetypes.StringValue, was: %T`, deleteAttribute))
	}

	updateAttribute, ok := attributes["update"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update is missing from object`)

		return NewTimeoutsValueUnknown(), diags
	}

	updateVal, ok := updateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update expected to be basetypes.StringValue, was: %T`, updateAttribute))
	}

	if diags.HasError() {
		return NewTimeoutsValueUnknown(), diags
	}

	return TimeoutsValue{
		Create: createVal,
		Delete: deleteVal,
		Update: updateVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTimeoutsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimeoutsValue {
	object, diags := NewTimeoutsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimeoutsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimeoutsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimeoutsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimeoutsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimeoutsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimeoutsValueMust(TimeoutsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimeoutsType) ValueType(ctx context.Context) attr.Value {
	return TimeoutsValue{}
}

var _ basetypes.ObjectValuable = TimeoutsValue{}

type TimeoutsValue struct {
	Create basetypes.StringValue `tfsdk:"create"`
	Delete basetypes.StringValue `tfsdk:"delete"`
	Update basetypes.StringValue `tfsdk:"update"`
	state  attr.ValueState
}

func (v TimeoutsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["create"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["delete"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["update"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Create.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["create"] = val

		val, err = v.Delete.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["delete"] = val

		val, err = v.Update.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["update"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimeoutsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimeoutsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimeoutsValue) String() string {
	return "TimeoutsValue"
}

func (v TimeoutsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"create": basetypes.StringType{},
		"delete": basetypes.StringType{},
		"update": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"create": v.Create,
			"delete": v.Delete,
			"update": v.Update,
		})

	return objVal, diags
}

func (v TimeoutsValue) Equal(o attr.Value) bool {
	other, ok := o.(TimeoutsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Create.Equal(other.Create) {
		return false
	}

	if !v.Delete.Equal(other.Delete) {
		return false
	}

	if !v.Update.Equal(other.Update) {
		return false
	}

	return true
}

func (v TimeoutsValue) Type(ctx context.Context) attr.Type {
	return TimeoutsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimeoutsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"create": basetypes.StringType{},
		"delete": basetypes.StringType{},
		"update": basetypes.StringType{},
	}
}
