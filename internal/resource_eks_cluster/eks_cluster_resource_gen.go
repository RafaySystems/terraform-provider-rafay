// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_eks_cluster

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func EksClusterResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Blocks: map[string]schema.Block{
			"cluster": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"kind": schema.StringAttribute{
							Optional:            true,
							Description:         "The resource kind.",
							MarkdownDescription: "The resource kind.",
						},
					},
					Blocks: map[string]schema.Block{
						"metadata": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the EKS cluster in Rafay console.",
										MarkdownDescription: "The name of the EKS cluster in Rafay console.",
									},
									"project": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the Rafay project the cluster will be created in.",
										MarkdownDescription: "The name of the Rafay project the cluster will be created in.",
									},
								},
								CustomType: MetadataType{
									ObjectType: types.ObjectType{
										AttrTypes: MetadataValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"spec": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"blueprint": schema.StringAttribute{
										Optional:            true,
										Description:         "The name of the blueprint to use for the EKS cluster.",
										MarkdownDescription: "The name of the blueprint to use for the EKS cluster.",
									},
									"cloud_provider": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the cloud provider for EKS cluster.",
										MarkdownDescription: "The name of the cloud provider for EKS cluster.",
									},
									"cni_provider": schema.StringAttribute{
										Optional:            true,
										Description:         "The CNI provider to use for the EKS cluster.",
										MarkdownDescription: "The CNI provider to use for the EKS cluster.",
									},
									"type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of the cluster.",
										MarkdownDescription: "The type of the cluster.",
									},
								},
								CustomType: SpecType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
					},
					CustomType: ClusterType{
						ObjectType: types.ObjectType{
							AttrTypes: ClusterValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"cluster_config": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"apiversion": schema.StringAttribute{
							Optional:            true,
							Description:         "The Rafay API version of the EKS cluster.",
							MarkdownDescription: "The Rafay API version of the EKS cluster.",
						},
						"kind": schema.StringAttribute{
							Optional:            true,
							Description:         "The kind of the resource.",
							MarkdownDescription: "The kind of the resource.",
						},
						"node_groups_map": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ami_family": schema.StringAttribute{
										Optional: true,
									},
									"desired_capacity": schema.Int64Attribute{
										Optional: true,
									},
									"disable_imdsv1": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to disable IMDSv1 on the node group.",
										MarkdownDescription: "Whether to disable IMDSv1 on the node group.",
									},
									"disable_pods_imds": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to disable IMDS for pods in the node group.",
										MarkdownDescription: "Whether to disable IMDS for pods in the node group.",
									},
									"efa_enabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										MarkdownDescription: "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
									},
									"iam": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"iam_node_group_with_addon_policies": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"alb_ingress": schema.BoolAttribute{
																Optional: true,
															},
															"app_mesh": schema.BoolAttribute{
																Optional: true,
															},
															"app_mesh_review": schema.BoolAttribute{
																Optional: true,
															},
															"auto_scaler": schema.BoolAttribute{
																Optional: true,
															},
															"cert_manager": schema.BoolAttribute{
																Optional: true,
															},
															"cloud_watch": schema.BoolAttribute{
																Optional: true,
															},
															"ebs": schema.BoolAttribute{
																Optional: true,
															},
															"efs": schema.BoolAttribute{
																Optional: true,
															},
															"external_dns": schema.BoolAttribute{
																Optional: true,
															},
															"fsx": schema.BoolAttribute{
																Optional: true,
															},
															"image_builder": schema.BoolAttribute{
																Optional: true,
															},
															"xray": schema.BoolAttribute{
																Optional: true,
															},
														},
														CustomType: IamNodeGroupWithAddonPolicies2Type{
															ObjectType: types.ObjectType{
																AttrTypes: IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx),
															},
														},
													},
													Optional: true,
												},
											},
											CustomType: Iam2Type{
												ObjectType: types.ObjectType{
													AttrTypes: Iam2Value{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
									"instance_type": schema.StringAttribute{
										Required:            true,
										Description:         "The type of EC2 instance to use for the nodes in this group.",
										MarkdownDescription: "The type of EC2 instance to use for the nodes in this group.",
									},
									"max_pods_per_node": schema.Int64Attribute{
										Optional: true,
									},
									"max_size": schema.Int64Attribute{
										Optional: true,
									},
									"min_size": schema.Int64Attribute{
										Optional: true,
									},
									"private_networking": schema.BoolAttribute{
										Optional:            true,
										Description:         "Enable private networking for the node group.",
										MarkdownDescription: "Enable private networking for the node group.",
									},
									"version": schema.StringAttribute{
										Optional: true,
									},
									"volume_iops": schema.Int64Attribute{
										Optional:            true,
										Description:         "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										MarkdownDescription: "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
									},
									"volume_size": schema.Int64Attribute{
										Optional:            true,
										Description:         "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										MarkdownDescription: "The size of the EBS volumes attached to the nodes in this group, in GiB.",
									},
									"volume_throughput": schema.Int64Attribute{
										Optional:            true,
										Description:         "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										MarkdownDescription: "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
									},
									"volume_type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of EBS volume to use for the nodes in this group.",
										MarkdownDescription: "The type of EBS volume to use for the nodes in this group.",
									},
								},
								CustomType: NodeGroupsMapType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Map of node group names to their configurations. Each key is the name of the node group, and the value is an object containing the configuration for that node group.",
							MarkdownDescription: "Map of node group names to their configurations. Each key is the name of the node group, and the value is an object containing the configuration for that node group.",
						},
					},
					Blocks: map[string]schema.Block{
						"metadata": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "EKS Cluster name.",
										MarkdownDescription: "EKS Cluster name.",
									},
									"region": schema.StringAttribute{
										Required:            true,
										Description:         "The AWS region hosting this cluster.",
										MarkdownDescription: "The AWS region hosting this cluster.",
									},
									"tags": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of tags to assign to the EKS cluster.",
										MarkdownDescription: "A map of tags to assign to the EKS cluster.",
									},
									"version": schema.StringAttribute{
										Optional:            true,
										Description:         "The version of the EKS control plane.",
										MarkdownDescription: "The version of the EKS control plane.",
									},
								},
								CustomType: Metadata2Type{
									ObjectType: types.ObjectType{
										AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"node_groups": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"ami_family": schema.StringAttribute{
										Optional: true,
									},
									"desired_capacity": schema.Int64Attribute{
										Optional: true,
									},
									"disable_imdsv1": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to disable IMDSv1 on the node group.",
										MarkdownDescription: "Whether to disable IMDSv1 on the node group.",
									},
									"disable_pods_imds": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to disable IMDS for pods in the node group.",
										MarkdownDescription: "Whether to disable IMDS for pods in the node group.",
									},
									"efa_enabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										MarkdownDescription: "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
									},
									"instance_type": schema.StringAttribute{
										Required:            true,
										Description:         "The type of EC2 instance to use for the nodes in this group.",
										MarkdownDescription: "The type of EC2 instance to use for the nodes in this group.",
									},
									"max_pods_per_node": schema.Int64Attribute{
										Optional: true,
									},
									"max_size": schema.Int64Attribute{
										Optional: true,
									},
									"min_size": schema.Int64Attribute{
										Optional: true,
									},
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the node group.",
										MarkdownDescription: "The name of the node group.",
									},
									"private_networking": schema.BoolAttribute{
										Optional:            true,
										Description:         "Enable private networking for the node group.",
										MarkdownDescription: "Enable private networking for the node group.",
									},
									"version": schema.StringAttribute{
										Optional: true,
									},
									"volume_iops": schema.Int64Attribute{
										Optional:            true,
										Description:         "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										MarkdownDescription: "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
									},
									"volume_size": schema.Int64Attribute{
										Optional:            true,
										Description:         "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										MarkdownDescription: "The size of the EBS volumes attached to the nodes in this group, in GiB.",
									},
									"volume_throughput": schema.Int64Attribute{
										Optional:            true,
										Description:         "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										MarkdownDescription: "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
									},
									"volume_type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of EBS volume to use for the nodes in this group.",
										MarkdownDescription: "The type of EBS volume to use for the nodes in this group.",
									},
								},
								Blocks: map[string]schema.Block{
									"iam": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Blocks: map[string]schema.Block{
												"iam_node_group_with_addon_policies": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"alb_ingress": schema.BoolAttribute{
																Optional: true,
															},
															"app_mesh": schema.BoolAttribute{
																Optional: true,
															},
															"app_mesh_review": schema.BoolAttribute{
																Optional: true,
															},
															"auto_scaler": schema.BoolAttribute{
																Optional: true,
															},
															"cert_manager": schema.BoolAttribute{
																Optional: true,
															},
															"cloud_watch": schema.BoolAttribute{
																Optional: true,
															},
															"ebs": schema.BoolAttribute{
																Optional: true,
															},
															"efs": schema.BoolAttribute{
																Optional: true,
															},
															"external_dns": schema.BoolAttribute{
																Optional: true,
															},
															"fsx": schema.BoolAttribute{
																Optional: true,
															},
															"image_builder": schema.BoolAttribute{
																Optional: true,
															},
															"xray": schema.BoolAttribute{
																Optional: true,
															},
														},
														CustomType: IamNodeGroupWithAddonPoliciesType{
															ObjectType: types.ObjectType{
																AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: IamType{
												ObjectType: types.ObjectType{
													AttrTypes: IamValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: NodeGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							DeprecationMessage: "The 'node_groups' block is deprecated and will be removed in a future release. Use 'node_groups_map'                                                                                                             for new configs. Existing setups still work, but migration is recommended.",
						},
					},
					CustomType: ClusterConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
		},
		Version: 1,
	}
}

type EksClusterModel struct {
	Cluster       types.List `tfsdk:"cluster"`
	ClusterConfig types.List `tfsdk:"cluster_config"`
}

var _ basetypes.ObjectTypable = ClusterType{}

type ClusterType struct {
	basetypes.ObjectType
}

func (t ClusterType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterType) String() string {
	return "ClusterType"
}

func (t ClusterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ListValue, was: %T`, specAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterValue{
		Kind:     kindVal,
		Metadata: metadataVal,
		Spec:     specVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterValueNull() ClusterValue {
	return ClusterValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterValueUnknown() ClusterValue {
	return ClusterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterValue Attribute Value",
				"While creating a ClusterValue value, a missing attribute value was detected. "+
					"A ClusterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterValue Attribute Type",
				"While creating a ClusterValue value, an invalid attribute value was detected. "+
					"A ClusterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterValue Attribute Value",
				"While creating a ClusterValue value, an extra attribute value was detected. "+
					"A ClusterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterValueUnknown(), diags
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ListValue, was: %T`, specAttribute))
	}

	if diags.HasError() {
		return NewClusterValueUnknown(), diags
	}

	return ClusterValue{
		Kind:     kindVal,
		Metadata: metadataVal,
		Spec:     specVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterValue {
	object, diags := NewClusterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterValueMust(ClusterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterType) ValueType(ctx context.Context) attr.Value {
	return ClusterValue{}
}

var _ basetypes.ObjectValuable = ClusterValue{}

type ClusterValue struct {
	Kind     basetypes.StringValue `tfsdk:"kind"`
	Metadata basetypes.ListValue   `tfsdk:"metadata"`
	Spec     basetypes.ListValue   `tfsdk:"spec"`
	state    attr.ValueState
}

func (v ClusterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: MetadataValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ListType{
		ElemType: SpecValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterValue) String() string {
	return "ClusterValue"
}

func (v ClusterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	metadata := types.ListValueMust(
		MetadataType{
			basetypes.ObjectType{
				AttrTypes: MetadataValue{}.AttributeTypes(ctx),
			},
		},
		v.Metadata.Elements(),
	)

	if v.Metadata.IsNull() {
		metadata = types.ListNull(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ListUnknown(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	spec := types.ListValueMust(
		SpecType{
			basetypes.ObjectType{
				AttrTypes: SpecValue{}.AttributeTypes(ctx),
			},
		},
		v.Spec.Elements(),
	)

	if v.Spec.IsNull() {
		spec = types.ListNull(
			SpecType{
				basetypes.ObjectType{
					AttrTypes: SpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ListUnknown(
			SpecType{
				basetypes.ObjectType{
					AttrTypes: SpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"kind": basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"spec": basetypes.ListType{
			ElemType: SpecValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"kind":     v.Kind,
			"metadata": metadata,
			"spec":     spec,
		})

	return objVal, diags
}

func (v ClusterValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	return true
}

func (v ClusterValue) Type(ctx context.Context) attr.Type {
	return ClusterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"kind": basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"spec": basetypes.ListType{
			ElemType: SpecValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Name:    nameVal,
		Project: projectVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Name:    nameVal,
		Project: projectVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Name    basetypes.StringValue `tfsdk:"name"`
	Project basetypes.StringValue `tfsdk:"project"`
	state   attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":    basetypes.StringType{},
		"project": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":    v.Name,
			"project": v.Project,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":    basetypes.StringType{},
		"project": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return nil, diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.StringValue, was: %T`, blueprintAttribute))
	}

	cloudProviderAttribute, ok := attributes["cloud_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider is missing from object`)

		return nil, diags
	}

	cloudProviderVal, ok := cloudProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider expected to be basetypes.StringValue, was: %T`, cloudProviderAttribute))
	}

	cniProviderAttribute, ok := attributes["cni_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_provider is missing from object`)

		return nil, diags
	}

	cniProviderVal, ok := cniProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_provider expected to be basetypes.StringValue, was: %T`, cniProviderAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Blueprint:     blueprintVal,
		CloudProvider: cloudProviderVal,
		CniProvider:   cniProviderVal,
		SpecType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.StringValue, was: %T`, blueprintAttribute))
	}

	cloudProviderAttribute, ok := attributes["cloud_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cloudProviderVal, ok := cloudProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider expected to be basetypes.StringValue, was: %T`, cloudProviderAttribute))
	}

	cniProviderAttribute, ok := attributes["cni_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_provider is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cniProviderVal, ok := cniProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_provider expected to be basetypes.StringValue, was: %T`, cniProviderAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Blueprint:     blueprintVal,
		CloudProvider: cloudProviderVal,
		CniProvider:   cniProviderVal,
		SpecType:      typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Blueprint     basetypes.StringValue `tfsdk:"blueprint"`
	CloudProvider basetypes.StringValue `tfsdk:"cloud_provider"`
	CniProvider   basetypes.StringValue `tfsdk:"cni_provider"`
	SpecType      basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["blueprint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cloud_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cni_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Blueprint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blueprint"] = val

		val, err = v.CloudProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_provider"] = val

		val, err = v.CniProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cni_provider"] = val

		val, err = v.SpecType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"blueprint":      basetypes.StringType{},
		"cloud_provider": basetypes.StringType{},
		"cni_provider":   basetypes.StringType{},
		"type":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"blueprint":      v.Blueprint,
			"cloud_provider": v.CloudProvider,
			"cni_provider":   v.CniProvider,
			"type":           v.SpecType,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Blueprint.Equal(other.Blueprint) {
		return false
	}

	if !v.CloudProvider.Equal(other.CloudProvider) {
		return false
	}

	if !v.CniProvider.Equal(other.CniProvider) {
		return false
	}

	if !v.SpecType.Equal(other.SpecType) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"blueprint":      basetypes.StringType{},
		"cloud_provider": basetypes.StringType{},
		"cni_provider":   basetypes.StringType{},
		"type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterConfigType{}

type ClusterConfigType struct {
	basetypes.ObjectType
}

func (t ClusterConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterConfigType) String() string {
	return "ClusterConfigType"
}

func (t ClusterConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiversionAttribute, ok := attributes["apiversion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apiversion is missing from object`)

		return nil, diags
	}

	apiversionVal, ok := apiversionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apiversion expected to be basetypes.StringValue, was: %T`, apiversionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadata2Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata2 is missing from object`)

		return nil, diags
	}

	metadata2Val, ok := metadata2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata2 expected to be basetypes.ListValue, was: %T`, metadata2Attribute))
	}

	nodeGroupsAttribute, ok := attributes["node_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups is missing from object`)

		return nil, diags
	}

	nodeGroupsVal, ok := nodeGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups expected to be basetypes.ListValue, was: %T`, nodeGroupsAttribute))
	}

	nodeGroupsMapAttribute, ok := attributes["node_groups_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups_map is missing from object`)

		return nil, diags
	}

	nodeGroupsMapVal, ok := nodeGroupsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups_map expected to be basetypes.MapValue, was: %T`, nodeGroupsMapAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterConfigValue{
		Apiversion:    apiversionVal,
		Kind:          kindVal,
		Metadata2:     metadata2Val,
		NodeGroups:    nodeGroupsVal,
		NodeGroupsMap: nodeGroupsMapVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueNull() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterConfigValueUnknown() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, a missing attribute value was detected. "+
					"A ClusterConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterConfigValue Attribute Type",
				"While creating a ClusterConfigValue value, an invalid attribute value was detected. "+
					"A ClusterConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, an extra attribute value was detected. "+
					"A ClusterConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	apiversionAttribute, ok := attributes["apiversion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apiversion is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	apiversionVal, ok := apiversionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apiversion expected to be basetypes.StringValue, was: %T`, apiversionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadata2Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata2 is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	metadata2Val, ok := metadata2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata2 expected to be basetypes.ListValue, was: %T`, metadata2Attribute))
	}

	nodeGroupsAttribute, ok := attributes["node_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	nodeGroupsVal, ok := nodeGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups expected to be basetypes.ListValue, was: %T`, nodeGroupsAttribute))
	}

	nodeGroupsMapAttribute, ok := attributes["node_groups_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups_map is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	nodeGroupsMapVal, ok := nodeGroupsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups_map expected to be basetypes.MapValue, was: %T`, nodeGroupsMapAttribute))
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	return ClusterConfigValue{
		Apiversion:    apiversionVal,
		Kind:          kindVal,
		Metadata2:     metadata2Val,
		NodeGroups:    nodeGroupsVal,
		NodeGroupsMap: nodeGroupsMapVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterConfigValue {
	object, diags := NewClusterConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterConfigValueMust(ClusterConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterConfigType) ValueType(ctx context.Context) attr.Value {
	return ClusterConfigValue{}
}

var _ basetypes.ObjectValuable = ClusterConfigValue{}

type ClusterConfigValue struct {
	Apiversion    basetypes.StringValue `tfsdk:"apiversion"`
	Kind          basetypes.StringValue `tfsdk:"kind"`
	Metadata2     basetypes.ListValue   `tfsdk:"metadata"`
	NodeGroups    basetypes.ListValue   `tfsdk:"node_groups"`
	NodeGroupsMap basetypes.MapValue    `tfsdk:"node_groups_map"`
	state         attr.ValueState
}

func (v ClusterConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["apiversion"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: Metadata2Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_groups"] = basetypes.ListType{
		ElemType: NodeGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_groups_map"] = basetypes.MapType{
		ElemType: NodeGroupsMapValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Apiversion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apiversion"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.NodeGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_groups"] = val

		val, err = v.NodeGroupsMap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_groups_map"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterConfigValue) String() string {
	return "ClusterConfigValue"
}

func (v ClusterConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	metadata2 := types.ListValueMust(
		Metadata2Type{
			basetypes.ObjectType{
				AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
			},
		},
		v.Metadata2.Elements(),
	)

	if v.Metadata2.IsNull() {
		metadata2 = types.ListNull(
			Metadata2Type{
				basetypes.ObjectType{
					AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata2.IsUnknown() {
		metadata2 = types.ListUnknown(
			Metadata2Type{
				basetypes.ObjectType{
					AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeGroups := types.ListValueMust(
		NodeGroupsType{
			basetypes.ObjectType{
				AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeGroups.Elements(),
	)

	if v.NodeGroups.IsNull() {
		nodeGroups = types.ListNull(
			NodeGroupsType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeGroups.IsUnknown() {
		nodeGroups = types.ListUnknown(
			NodeGroupsType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeGroupsMap := types.MapValueMust(
		NodeGroupsMapType{
			basetypes.ObjectType{
				AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeGroupsMap.Elements(),
	)

	if v.NodeGroupsMap.IsNull() {
		nodeGroupsMap = types.MapNull(
			NodeGroupsMapType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeGroupsMap.IsUnknown() {
		nodeGroupsMap = types.MapUnknown(
			NodeGroupsMapType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"apiversion": basetypes.StringType{},
		"kind":       basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: Metadata2Value{}.Type(ctx),
		},
		"node_groups": basetypes.ListType{
			ElemType: NodeGroupsValue{}.Type(ctx),
		},
		"node_groups_map": basetypes.MapType{
			ElemType: NodeGroupsMapValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"apiversion":      v.Apiversion,
			"kind":            v.Kind,
			"metadata":       metadata2,
			"node_groups":     nodeGroups,
			"node_groups_map": nodeGroupsMap,
		})

	return objVal, diags
}

func (v ClusterConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Apiversion.Equal(other.Apiversion) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata2.Equal(other.Metadata2) {
		return false
	}

	if !v.NodeGroups.Equal(other.NodeGroups) {
		return false
	}

	if !v.NodeGroupsMap.Equal(other.NodeGroupsMap) {
		return false
	}

	return true
}

func (v ClusterConfigValue) Type(ctx context.Context) attr.Type {
	return ClusterConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"apiversion": basetypes.StringType{},
		"kind":       basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: Metadata2Value{}.Type(ctx),
		},
		"node_groups": basetypes.ListType{
			ElemType: NodeGroupsValue{}.Type(ctx),
		},
		"node_groups_map": basetypes.MapType{
			ElemType: NodeGroupsMapValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = NodeGroupsMapType{}

type NodeGroupsMapType struct {
	basetypes.ObjectType
}

func (t NodeGroupsMapType) Equal(o attr.Type) bool {
	other, ok := o.(NodeGroupsMapType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeGroupsMapType) String() string {
	return "NodeGroupsMapType"
}

func (t NodeGroupsMapType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return nil, diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return nil, diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return nil, diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return nil, diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return nil, diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	iam2Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam2 is missing from object`)

		return nil, diags
	}

	iam2Val, ok := iam2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam2 expected to be basetypes.ListValue, was: %T`, iam2Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return nil, diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return nil, diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return nil, diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return nil, diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return nil, diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeGroupsMapValue{
		AmiFamily:         amiFamilyVal,
		DesiredCapacity:   desiredCapacityVal,
		DisableImdsv1:     disableImdsv1Val,
		DisablePodsImds:   disablePodsImdsVal,
		EfaEnabled:        efaEnabledVal,
		Iam2:              iam2Val,
		InstanceType:      instanceTypeVal,
		MaxPodsPerNode:    maxPodsPerNodeVal,
		MaxSize:           maxSizeVal,
		MinSize:           minSizeVal,
		PrivateNetworking: privateNetworkingVal,
		Version:           versionVal,
		VolumeIops:        volumeIopsVal,
		VolumeSize:        volumeSizeVal,
		VolumeThroughput:  volumeThroughputVal,
		VolumeType:        volumeTypeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsMapValueNull() NodeGroupsMapValue {
	return NodeGroupsMapValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeGroupsMapValueUnknown() NodeGroupsMapValue {
	return NodeGroupsMapValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeGroupsMapValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeGroupsMapValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeGroupsMapValue Attribute Value",
				"While creating a NodeGroupsMapValue value, a missing attribute value was detected. "+
					"A NodeGroupsMapValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeGroupsMapValue Attribute Type",
				"While creating a NodeGroupsMapValue value, an invalid attribute value was detected. "+
					"A NodeGroupsMapValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeGroupsMapValue Attribute Value",
				"While creating a NodeGroupsMapValue value, an extra attribute value was detected. "+
					"A NodeGroupsMapValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeGroupsMapValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeGroupsMapValueUnknown(), diags
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	iam2Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam2 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	iam2Val, ok := iam2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam2 expected to be basetypes.ListValue, was: %T`, iam2Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewNodeGroupsMapValueUnknown(), diags
	}

	return NodeGroupsMapValue{
		AmiFamily:         amiFamilyVal,
		DesiredCapacity:   desiredCapacityVal,
		DisableImdsv1:     disableImdsv1Val,
		DisablePodsImds:   disablePodsImdsVal,
		EfaEnabled:        efaEnabledVal,
		Iam2:              iam2Val,
		InstanceType:      instanceTypeVal,
		MaxPodsPerNode:    maxPodsPerNodeVal,
		MaxSize:           maxSizeVal,
		MinSize:           minSizeVal,
		PrivateNetworking: privateNetworkingVal,
		Version:           versionVal,
		VolumeIops:        volumeIopsVal,
		VolumeSize:        volumeSizeVal,
		VolumeThroughput:  volumeThroughputVal,
		VolumeType:        volumeTypeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsMapValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeGroupsMapValue {
	object, diags := NewNodeGroupsMapValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeGroupsMapValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeGroupsMapType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeGroupsMapValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeGroupsMapValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeGroupsMapValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeGroupsMapValueMust(NodeGroupsMapValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeGroupsMapType) ValueType(ctx context.Context) attr.Value {
	return NodeGroupsMapValue{}
}

var _ basetypes.ObjectValuable = NodeGroupsMapValue{}

type NodeGroupsMapValue struct {
	AmiFamily         basetypes.StringValue `tfsdk:"ami_family"`
	DesiredCapacity   basetypes.Int64Value  `tfsdk:"desired_capacity"`
	DisableImdsv1     basetypes.BoolValue   `tfsdk:"disable_imdsv1"`
	DisablePodsImds   basetypes.BoolValue   `tfsdk:"disable_pods_imds"`
	EfaEnabled        basetypes.BoolValue   `tfsdk:"efa_enabled"`
	Iam2              basetypes.ListValue   `tfsdk:"iam"`
	InstanceType      basetypes.StringValue `tfsdk:"instance_type"`
	MaxPodsPerNode    basetypes.Int64Value  `tfsdk:"max_pods_per_node"`
	MaxSize           basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize           basetypes.Int64Value  `tfsdk:"min_size"`
	PrivateNetworking basetypes.BoolValue   `tfsdk:"private_networking"`
	Version           basetypes.StringValue `tfsdk:"version"`
	VolumeIops        basetypes.Int64Value  `tfsdk:"volume_iops"`
	VolumeSize        basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeThroughput  basetypes.Int64Value  `tfsdk:"volume_throughput"`
	VolumeType        basetypes.StringValue `tfsdk:"volume_type"`
	state             attr.ValueState
}

func (v NodeGroupsMapValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["ami_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["desired_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_imdsv1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_pods_imds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ListType{
		ElemType: Iam2Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_pods_per_node"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["private_networking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_throughput"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.AmiFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami_family"] = val

		val, err = v.DesiredCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_capacity"] = val

		val, err = v.DisableImdsv1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_imdsv1"] = val

		val, err = v.DisablePodsImds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_pods_imds"] = val

		val, err = v.EfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efa_enabled"] = val

		val, err = v.Iam2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.InstanceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_type"] = val

		val, err = v.MaxPodsPerNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pods_per_node"] = val

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.PrivateNetworking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_networking"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VolumeIops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_iops"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeThroughput.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_throughput"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeGroupsMapValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeGroupsMapValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeGroupsMapValue) String() string {
	return "NodeGroupsMapValue"
}

func (v NodeGroupsMapValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	iam2 := types.ListValueMust(
		Iam2Type{
			basetypes.ObjectType{
				AttrTypes: Iam2Value{}.AttributeTypes(ctx),
			},
		},
		v.Iam2.Elements(),
	)

	if v.Iam2.IsNull() {
		iam2 = types.ListNull(
			Iam2Type{
				basetypes.ObjectType{
					AttrTypes: Iam2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Iam2.IsUnknown() {
		iam2 = types.ListUnknown(
			Iam2Type{
				basetypes.ObjectType{
					AttrTypes: Iam2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"ami_family":        basetypes.StringType{},
		"desired_capacity":  basetypes.Int64Type{},
		"disable_imdsv1":    basetypes.BoolType{},
		"disable_pods_imds": basetypes.BoolType{},
		"efa_enabled":       basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: Iam2Value{}.Type(ctx),
		},
		"instance_type":      basetypes.StringType{},
		"max_pods_per_node":  basetypes.Int64Type{},
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"private_networking": basetypes.BoolType{},
		"version":            basetypes.StringType{},
		"volume_iops":        basetypes.Int64Type{},
		"volume_size":        basetypes.Int64Type{},
		"volume_throughput":  basetypes.Int64Type{},
		"volume_type":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ami_family":         v.AmiFamily,
			"desired_capacity":   v.DesiredCapacity,
			"disable_imdsv1":     v.DisableImdsv1,
			"disable_pods_imds":  v.DisablePodsImds,
			"efa_enabled":        v.EfaEnabled,
			"iam":               iam2,
			"instance_type":      v.InstanceType,
			"max_pods_per_node":  v.MaxPodsPerNode,
			"max_size":           v.MaxSize,
			"min_size":           v.MinSize,
			"private_networking": v.PrivateNetworking,
			"version":            v.Version,
			"volume_iops":        v.VolumeIops,
			"volume_size":        v.VolumeSize,
			"volume_throughput":  v.VolumeThroughput,
			"volume_type":        v.VolumeType,
		})

	return objVal, diags
}

func (v NodeGroupsMapValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeGroupsMapValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmiFamily.Equal(other.AmiFamily) {
		return false
	}

	if !v.DesiredCapacity.Equal(other.DesiredCapacity) {
		return false
	}

	if !v.DisableImdsv1.Equal(other.DisableImdsv1) {
		return false
	}

	if !v.DisablePodsImds.Equal(other.DisablePodsImds) {
		return false
	}

	if !v.EfaEnabled.Equal(other.EfaEnabled) {
		return false
	}

	if !v.Iam2.Equal(other.Iam2) {
		return false
	}

	if !v.InstanceType.Equal(other.InstanceType) {
		return false
	}

	if !v.MaxPodsPerNode.Equal(other.MaxPodsPerNode) {
		return false
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.PrivateNetworking.Equal(other.PrivateNetworking) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VolumeIops.Equal(other.VolumeIops) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeThroughput.Equal(other.VolumeThroughput) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v NodeGroupsMapValue) Type(ctx context.Context) attr.Type {
	return NodeGroupsMapType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeGroupsMapValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami_family":        basetypes.StringType{},
		"desired_capacity":  basetypes.Int64Type{},
		"disable_imdsv1":    basetypes.BoolType{},
		"disable_pods_imds": basetypes.BoolType{},
		"efa_enabled":       basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: Iam2Value{}.Type(ctx),
		},
		"instance_type":      basetypes.StringType{},
		"max_pods_per_node":  basetypes.Int64Type{},
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"private_networking": basetypes.BoolType{},
		"version":            basetypes.StringType{},
		"volume_iops":        basetypes.Int64Type{},
		"volume_size":        basetypes.Int64Type{},
		"volume_throughput":  basetypes.Int64Type{},
		"volume_type":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Iam2Type{}

type Iam2Type struct {
	basetypes.ObjectType
}

func (t Iam2Type) Equal(o attr.Type) bool {
	other, ok := o.(Iam2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Iam2Type) String() string {
	return "Iam2Type"
}

func (t Iam2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	iamNodeGroupWithAddonPolicies2Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies2 is missing from object`)

		return nil, diags
	}

	iamNodeGroupWithAddonPolicies2Val, ok := iamNodeGroupWithAddonPolicies2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies2 expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPolicies2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Iam2Value{
		IamNodeGroupWithAddonPolicies2: iamNodeGroupWithAddonPolicies2Val,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam2ValueNull() Iam2Value {
	return Iam2Value{
		state: attr.ValueStateNull,
	}
}

func NewIam2ValueUnknown() Iam2Value {
	return Iam2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIam2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Iam2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Iam2Value Attribute Value",
				"While creating a Iam2Value value, a missing attribute value was detected. "+
					"A Iam2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Iam2Value Attribute Type",
				"While creating a Iam2Value value, an invalid attribute value was detected. "+
					"A Iam2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Iam2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Iam2Value Attribute Value",
				"While creating a Iam2Value value, an extra attribute value was detected. "+
					"A Iam2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Iam2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIam2ValueUnknown(), diags
	}

	iamNodeGroupWithAddonPolicies2Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies2 is missing from object`)

		return NewIam2ValueUnknown(), diags
	}

	iamNodeGroupWithAddonPolicies2Val, ok := iamNodeGroupWithAddonPolicies2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies2 expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPolicies2Attribute))
	}

	if diags.HasError() {
		return NewIam2ValueUnknown(), diags
	}

	return Iam2Value{
		IamNodeGroupWithAddonPolicies2: iamNodeGroupWithAddonPolicies2Val,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Iam2Value {
	object, diags := NewIam2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIam2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Iam2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIam2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIam2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIam2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIam2ValueMust(Iam2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Iam2Type) ValueType(ctx context.Context) attr.Value {
	return Iam2Value{}
}

var _ basetypes.ObjectValuable = Iam2Value{}

type Iam2Value struct {
	IamNodeGroupWithAddonPolicies2 basetypes.ListValue `tfsdk:"iam_node_group_with_addon_policies"`
	state                          attr.ValueState
}

func (v Iam2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["iam_node_group_with_addon_policies"] = basetypes.ListType{
		ElemType: IamNodeGroupWithAddonPolicies2Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.IamNodeGroupWithAddonPolicies2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_node_group_with_addon_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Iam2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Iam2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Iam2Value) String() string {
	return "Iam2Value"
}

func (v Iam2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	iamNodeGroupWithAddonPolicies2 := types.ListValueMust(
		IamNodeGroupWithAddonPolicies2Type{
			basetypes.ObjectType{
				AttrTypes: IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx),
			},
		},
		v.IamNodeGroupWithAddonPolicies2.Elements(),
	)

	if v.IamNodeGroupWithAddonPolicies2.IsNull() {
		iamNodeGroupWithAddonPolicies2 = types.ListNull(
			IamNodeGroupWithAddonPolicies2Type{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IamNodeGroupWithAddonPolicies2.IsUnknown() {
		iamNodeGroupWithAddonPolicies2 = types.ListUnknown(
			IamNodeGroupWithAddonPolicies2Type{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPolicies2Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"iam_node_group_with_addon_policies": iamNodeGroupWithAddonPolicies2,
		})

	return objVal, diags
}

func (v Iam2Value) Equal(o attr.Value) bool {
	other, ok := o.(Iam2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IamNodeGroupWithAddonPolicies2.Equal(other.IamNodeGroupWithAddonPolicies2) {
		return false
	}

	return true
}

func (v Iam2Value) Type(ctx context.Context) attr.Type {
	return Iam2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Iam2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPolicies2Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = IamNodeGroupWithAddonPolicies2Type{}

type IamNodeGroupWithAddonPolicies2Type struct {
	basetypes.ObjectType
}

func (t IamNodeGroupWithAddonPolicies2Type) Equal(o attr.Type) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamNodeGroupWithAddonPolicies2Type) String() string {
	return "IamNodeGroupWithAddonPolicies2Type"
}

func (t IamNodeGroupWithAddonPolicies2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return nil, diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return nil, diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return nil, diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return nil, diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return nil, diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return nil, diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return nil, diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamNodeGroupWithAddonPolicies2Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies2ValueNull() IamNodeGroupWithAddonPolicies2Value {
	return IamNodeGroupWithAddonPolicies2Value{
		state: attr.ValueStateNull,
	}
}

func NewIamNodeGroupWithAddonPolicies2ValueUnknown() IamNodeGroupWithAddonPolicies2Value {
	return IamNodeGroupWithAddonPolicies2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIamNodeGroupWithAddonPolicies2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamNodeGroupWithAddonPolicies2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamNodeGroupWithAddonPolicies2Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies2Value value, a missing attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamNodeGroupWithAddonPolicies2Value Attribute Type",
				"While creating a IamNodeGroupWithAddonPolicies2Value value, an invalid attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamNodeGroupWithAddonPolicies2Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies2Value value, an extra attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamNodeGroupWithAddonPolicies2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	return IamNodeGroupWithAddonPolicies2Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamNodeGroupWithAddonPolicies2Value {
	object, diags := NewIamNodeGroupWithAddonPolicies2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamNodeGroupWithAddonPolicies2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamNodeGroupWithAddonPolicies2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamNodeGroupWithAddonPolicies2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamNodeGroupWithAddonPolicies2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamNodeGroupWithAddonPolicies2ValueMust(IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t IamNodeGroupWithAddonPolicies2Type) ValueType(ctx context.Context) attr.Value {
	return IamNodeGroupWithAddonPolicies2Value{}
}

var _ basetypes.ObjectValuable = IamNodeGroupWithAddonPolicies2Value{}

type IamNodeGroupWithAddonPolicies2Value struct {
	AlbIngress    basetypes.BoolValue `tfsdk:"alb_ingress"`
	AppMesh       basetypes.BoolValue `tfsdk:"app_mesh"`
	AppMeshReview basetypes.BoolValue `tfsdk:"app_mesh_review"`
	AutoScaler    basetypes.BoolValue `tfsdk:"auto_scaler"`
	CertManager   basetypes.BoolValue `tfsdk:"cert_manager"`
	CloudWatch    basetypes.BoolValue `tfsdk:"cloud_watch"`
	Ebs           basetypes.BoolValue `tfsdk:"ebs"`
	Efs           basetypes.BoolValue `tfsdk:"efs"`
	ExternalDns   basetypes.BoolValue `tfsdk:"external_dns"`
	Fsx           basetypes.BoolValue `tfsdk:"fsx"`
	ImageBuilder  basetypes.BoolValue `tfsdk:"image_builder"`
	Xray          basetypes.BoolValue `tfsdk:"xray"`
	state         attr.ValueState
}

func (v IamNodeGroupWithAddonPolicies2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alb_ingress"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh_review"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fsx"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xray"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AlbIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alb_ingress"] = val

		val, err = v.AppMesh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh"] = val

		val, err = v.AppMeshReview.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh_review"] = val

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.Ebs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs"] = val

		val, err = v.Efs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.Fsx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fsx"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		val, err = v.Xray.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xray"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamNodeGroupWithAddonPolicies2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamNodeGroupWithAddonPolicies2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamNodeGroupWithAddonPolicies2Value) String() string {
	return "IamNodeGroupWithAddonPolicies2Value"
}

func (v IamNodeGroupWithAddonPolicies2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alb_ingress":     v.AlbIngress,
			"app_mesh":        v.AppMesh,
			"app_mesh_review": v.AppMeshReview,
			"auto_scaler":     v.AutoScaler,
			"cert_manager":    v.CertManager,
			"cloud_watch":     v.CloudWatch,
			"ebs":             v.Ebs,
			"efs":             v.Efs,
			"external_dns":    v.ExternalDns,
			"fsx":             v.Fsx,
			"image_builder":   v.ImageBuilder,
			"xray":            v.Xray,
		})

	return objVal, diags
}

func (v IamNodeGroupWithAddonPolicies2Value) Equal(o attr.Value) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlbIngress.Equal(other.AlbIngress) {
		return false
	}

	if !v.AppMesh.Equal(other.AppMesh) {
		return false
	}

	if !v.AppMeshReview.Equal(other.AppMeshReview) {
		return false
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.Ebs.Equal(other.Ebs) {
		return false
	}

	if !v.Efs.Equal(other.Efs) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.Fsx.Equal(other.Fsx) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	if !v.Xray.Equal(other.Xray) {
		return false
	}

	return true
}

func (v IamNodeGroupWithAddonPolicies2Value) Type(ctx context.Context) attr.Type {
	return IamNodeGroupWithAddonPolicies2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamNodeGroupWithAddonPolicies2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Metadata2Type{}

type Metadata2Type struct {
	basetypes.ObjectType
}

func (t Metadata2Type) Equal(o attr.Type) bool {
	other, ok := o.(Metadata2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Metadata2Type) String() string {
	return "Metadata2Type"
}

func (t Metadata2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Metadata2Value{
		Name:    nameVal,
		Region:  regionVal,
		Tags:    tagsVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadata2ValueNull() Metadata2Value {
	return Metadata2Value{
		state: attr.ValueStateNull,
	}
}

func NewMetadata2ValueUnknown() Metadata2Value {
	return Metadata2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadata2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Metadata2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Metadata2Value Attribute Value",
				"While creating a Metadata2Value value, a missing attribute value was detected. "+
					"A Metadata2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Metadata2Value Attribute Type",
				"While creating a Metadata2Value value, an invalid attribute value was detected. "+
					"A Metadata2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Metadata2Value Attribute Value",
				"While creating a Metadata2Value value, an extra attribute value was detected. "+
					"A Metadata2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Metadata2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadata2ValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewMetadata2ValueUnknown(), diags
	}

	return Metadata2Value{
		Name:    nameVal,
		Region:  regionVal,
		Tags:    tagsVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadata2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Metadata2Value {
	object, diags := NewMetadata2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadata2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Metadata2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadata2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadata2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadata2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadata2ValueMust(Metadata2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Metadata2Type) ValueType(ctx context.Context) attr.Value {
	return Metadata2Value{}
}

var _ basetypes.ObjectValuable = Metadata2Value{}

type Metadata2Value struct {
	Name    basetypes.StringValue `tfsdk:"name"`
	Region  basetypes.StringValue `tfsdk:"region"`
	Tags    basetypes.MapValue    `tfsdk:"tags"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v Metadata2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Metadata2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Metadata2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Metadata2Value) String() string {
	return "Metadata2Value"
}

func (v Metadata2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"name":   basetypes.StringType{},
			"region": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"version": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"region": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":    v.Name,
			"region":  v.Region,
			"tags":    tagsVal,
			"version": v.Version,
		})

	return objVal, diags
}

func (v Metadata2Value) Equal(o attr.Value) bool {
	other, ok := o.(Metadata2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v Metadata2Value) Type(ctx context.Context) attr.Type {
	return Metadata2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Metadata2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"region": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodeGroupsType{}

type NodeGroupsType struct {
	basetypes.ObjectType
}

func (t NodeGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(NodeGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeGroupsType) String() string {
	return "NodeGroupsType"
}

func (t NodeGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return nil, diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return nil, diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return nil, diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return nil, diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return nil, diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	iamAttribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam is missing from object`)

		return nil, diags
	}

	iamVal, ok := iamAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam expected to be basetypes.ListValue, was: %T`, iamAttribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return nil, diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return nil, diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return nil, diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return nil, diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return nil, diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeGroupsValue{
		AmiFamily:         amiFamilyVal,
		DesiredCapacity:   desiredCapacityVal,
		DisableImdsv1:     disableImdsv1Val,
		DisablePodsImds:   disablePodsImdsVal,
		EfaEnabled:        efaEnabledVal,
		Iam:               iamVal,
		InstanceType:      instanceTypeVal,
		MaxPodsPerNode:    maxPodsPerNodeVal,
		MaxSize:           maxSizeVal,
		MinSize:           minSizeVal,
		Name:              nameVal,
		PrivateNetworking: privateNetworkingVal,
		Version:           versionVal,
		VolumeIops:        volumeIopsVal,
		VolumeSize:        volumeSizeVal,
		VolumeThroughput:  volumeThroughputVal,
		VolumeType:        volumeTypeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsValueNull() NodeGroupsValue {
	return NodeGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeGroupsValueUnknown() NodeGroupsValue {
	return NodeGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeGroupsValue Attribute Value",
				"While creating a NodeGroupsValue value, a missing attribute value was detected. "+
					"A NodeGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeGroupsValue Attribute Type",
				"While creating a NodeGroupsValue value, an invalid attribute value was detected. "+
					"A NodeGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeGroupsValue Attribute Value",
				"While creating a NodeGroupsValue value, an extra attribute value was detected. "+
					"A NodeGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeGroupsValueUnknown(), diags
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	iamAttribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	iamVal, ok := iamAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam expected to be basetypes.ListValue, was: %T`, iamAttribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewNodeGroupsValueUnknown(), diags
	}

	return NodeGroupsValue{
		AmiFamily:         amiFamilyVal,
		DesiredCapacity:   desiredCapacityVal,
		DisableImdsv1:     disableImdsv1Val,
		DisablePodsImds:   disablePodsImdsVal,
		EfaEnabled:        efaEnabledVal,
		Iam:               iamVal,
		InstanceType:      instanceTypeVal,
		MaxPodsPerNode:    maxPodsPerNodeVal,
		MaxSize:           maxSizeVal,
		MinSize:           minSizeVal,
		Name:              nameVal,
		PrivateNetworking: privateNetworkingVal,
		Version:           versionVal,
		VolumeIops:        volumeIopsVal,
		VolumeSize:        volumeSizeVal,
		VolumeThroughput:  volumeThroughputVal,
		VolumeType:        volumeTypeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeGroupsValue {
	object, diags := NewNodeGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeGroupsValueMust(NodeGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeGroupsType) ValueType(ctx context.Context) attr.Value {
	return NodeGroupsValue{}
}

var _ basetypes.ObjectValuable = NodeGroupsValue{}

type NodeGroupsValue struct {
	AmiFamily         basetypes.StringValue `tfsdk:"ami_family"`
	DesiredCapacity   basetypes.Int64Value  `tfsdk:"desired_capacity"`
	DisableImdsv1     basetypes.BoolValue   `tfsdk:"disable_imdsv1"`
	DisablePodsImds   basetypes.BoolValue   `tfsdk:"disable_pods_imds"`
	EfaEnabled        basetypes.BoolValue   `tfsdk:"efa_enabled"`
	Iam               basetypes.ListValue   `tfsdk:"iam"`
	InstanceType      basetypes.StringValue `tfsdk:"instance_type"`
	MaxPodsPerNode    basetypes.Int64Value  `tfsdk:"max_pods_per_node"`
	MaxSize           basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize           basetypes.Int64Value  `tfsdk:"min_size"`
	Name              basetypes.StringValue `tfsdk:"name"`
	PrivateNetworking basetypes.BoolValue   `tfsdk:"private_networking"`
	Version           basetypes.StringValue `tfsdk:"version"`
	VolumeIops        basetypes.Int64Value  `tfsdk:"volume_iops"`
	VolumeSize        basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeThroughput  basetypes.Int64Value  `tfsdk:"volume_throughput"`
	VolumeType        basetypes.StringValue `tfsdk:"volume_type"`
	state             attr.ValueState
}

func (v NodeGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["ami_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["desired_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_imdsv1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_pods_imds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ListType{
		ElemType: IamValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_pods_per_node"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_networking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_throughput"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.AmiFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami_family"] = val

		val, err = v.DesiredCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_capacity"] = val

		val, err = v.DisableImdsv1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_imdsv1"] = val

		val, err = v.DisablePodsImds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_pods_imds"] = val

		val, err = v.EfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efa_enabled"] = val

		val, err = v.Iam.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.InstanceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_type"] = val

		val, err = v.MaxPodsPerNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pods_per_node"] = val

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PrivateNetworking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_networking"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VolumeIops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_iops"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeThroughput.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_throughput"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeGroupsValue) String() string {
	return "NodeGroupsValue"
}

func (v NodeGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	iam := types.ListValueMust(
		IamType{
			basetypes.ObjectType{
				AttrTypes: IamValue{}.AttributeTypes(ctx),
			},
		},
		v.Iam.Elements(),
	)

	if v.Iam.IsNull() {
		iam = types.ListNull(
			IamType{
				basetypes.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Iam.IsUnknown() {
		iam = types.ListUnknown(
			IamType{
				basetypes.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"ami_family":        basetypes.StringType{},
		"desired_capacity":  basetypes.Int64Type{},
		"disable_imdsv1":    basetypes.BoolType{},
		"disable_pods_imds": basetypes.BoolType{},
		"efa_enabled":       basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: IamValue{}.Type(ctx),
		},
		"instance_type":      basetypes.StringType{},
		"max_pods_per_node":  basetypes.Int64Type{},
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"name":               basetypes.StringType{},
		"private_networking": basetypes.BoolType{},
		"version":            basetypes.StringType{},
		"volume_iops":        basetypes.Int64Type{},
		"volume_size":        basetypes.Int64Type{},
		"volume_throughput":  basetypes.Int64Type{},
		"volume_type":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ami_family":         v.AmiFamily,
			"desired_capacity":   v.DesiredCapacity,
			"disable_imdsv1":     v.DisableImdsv1,
			"disable_pods_imds":  v.DisablePodsImds,
			"efa_enabled":        v.EfaEnabled,
			"iam":                iam,
			"instance_type":      v.InstanceType,
			"max_pods_per_node":  v.MaxPodsPerNode,
			"max_size":           v.MaxSize,
			"min_size":           v.MinSize,
			"name":               v.Name,
			"private_networking": v.PrivateNetworking,
			"version":            v.Version,
			"volume_iops":        v.VolumeIops,
			"volume_size":        v.VolumeSize,
			"volume_throughput":  v.VolumeThroughput,
			"volume_type":        v.VolumeType,
		})

	return objVal, diags
}

func (v NodeGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmiFamily.Equal(other.AmiFamily) {
		return false
	}

	if !v.DesiredCapacity.Equal(other.DesiredCapacity) {
		return false
	}

	if !v.DisableImdsv1.Equal(other.DisableImdsv1) {
		return false
	}

	if !v.DisablePodsImds.Equal(other.DisablePodsImds) {
		return false
	}

	if !v.EfaEnabled.Equal(other.EfaEnabled) {
		return false
	}

	if !v.Iam.Equal(other.Iam) {
		return false
	}

	if !v.InstanceType.Equal(other.InstanceType) {
		return false
	}

	if !v.MaxPodsPerNode.Equal(other.MaxPodsPerNode) {
		return false
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PrivateNetworking.Equal(other.PrivateNetworking) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VolumeIops.Equal(other.VolumeIops) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeThroughput.Equal(other.VolumeThroughput) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v NodeGroupsValue) Type(ctx context.Context) attr.Type {
	return NodeGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami_family":        basetypes.StringType{},
		"desired_capacity":  basetypes.Int64Type{},
		"disable_imdsv1":    basetypes.BoolType{},
		"disable_pods_imds": basetypes.BoolType{},
		"efa_enabled":       basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: IamValue{}.Type(ctx),
		},
		"instance_type":      basetypes.StringType{},
		"max_pods_per_node":  basetypes.Int64Type{},
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"name":               basetypes.StringType{},
		"private_networking": basetypes.BoolType{},
		"version":            basetypes.StringType{},
		"volume_iops":        basetypes.Int64Type{},
		"volume_size":        basetypes.Int64Type{},
		"volume_throughput":  basetypes.Int64Type{},
		"volume_type":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IamType{}

type IamType struct {
	basetypes.ObjectType
}

func (t IamType) Equal(o attr.Type) bool {
	other, ok := o.(IamType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamType) String() string {
	return "IamType"
}

func (t IamType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	iamNodeGroupWithAddonPoliciesAttribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies is missing from object`)

		return nil, diags
	}

	iamNodeGroupWithAddonPoliciesVal, ok := iamNodeGroupWithAddonPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPoliciesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamValue{
		IamNodeGroupWithAddonPolicies: iamNodeGroupWithAddonPoliciesVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewIamValueNull() IamValue {
	return IamValue{
		state: attr.ValueStateNull,
	}
}

func NewIamValueUnknown() IamValue {
	return IamValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIamValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamValue Attribute Value",
				"While creating a IamValue value, a missing attribute value was detected. "+
					"A IamValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamValue Attribute Type",
				"While creating a IamValue value, an invalid attribute value was detected. "+
					"A IamValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamValue Attribute Value",
				"While creating a IamValue value, an extra attribute value was detected. "+
					"A IamValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamValueUnknown(), diags
	}

	iamNodeGroupWithAddonPoliciesAttribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies is missing from object`)

		return NewIamValueUnknown(), diags
	}

	iamNodeGroupWithAddonPoliciesVal, ok := iamNodeGroupWithAddonPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPoliciesAttribute))
	}

	if diags.HasError() {
		return NewIamValueUnknown(), diags
	}

	return IamValue{
		IamNodeGroupWithAddonPolicies: iamNodeGroupWithAddonPoliciesVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewIamValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamValue {
	object, diags := NewIamValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamValueMust(IamValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IamType) ValueType(ctx context.Context) attr.Value {
	return IamValue{}
}

var _ basetypes.ObjectValuable = IamValue{}

type IamValue struct {
	IamNodeGroupWithAddonPolicies basetypes.ListValue `tfsdk:"iam_node_group_with_addon_policies"`
	state                         attr.ValueState
}

func (v IamValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["iam_node_group_with_addon_policies"] = basetypes.ListType{
		ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.IamNodeGroupWithAddonPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_node_group_with_addon_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamValue) String() string {
	return "IamValue"
}

func (v IamValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	iamNodeGroupWithAddonPolicies := types.ListValueMust(
		IamNodeGroupWithAddonPoliciesType{
			basetypes.ObjectType{
				AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.IamNodeGroupWithAddonPolicies.Elements(),
	)

	if v.IamNodeGroupWithAddonPolicies.IsNull() {
		iamNodeGroupWithAddonPolicies = types.ListNull(
			IamNodeGroupWithAddonPoliciesType{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IamNodeGroupWithAddonPolicies.IsUnknown() {
		iamNodeGroupWithAddonPolicies = types.ListUnknown(
			IamNodeGroupWithAddonPoliciesType{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"iam_node_group_with_addon_policies": iamNodeGroupWithAddonPolicies,
		})

	return objVal, diags
}

func (v IamValue) Equal(o attr.Value) bool {
	other, ok := o.(IamValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IamNodeGroupWithAddonPolicies.Equal(other.IamNodeGroupWithAddonPolicies) {
		return false
	}

	return true
}

func (v IamValue) Type(ctx context.Context) attr.Type {
	return IamType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = IamNodeGroupWithAddonPoliciesType{}

type IamNodeGroupWithAddonPoliciesType struct {
	basetypes.ObjectType
}

func (t IamNodeGroupWithAddonPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(IamNodeGroupWithAddonPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamNodeGroupWithAddonPoliciesType) String() string {
	return "IamNodeGroupWithAddonPoliciesType"
}

func (t IamNodeGroupWithAddonPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return nil, diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return nil, diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return nil, diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return nil, diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return nil, diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return nil, diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return nil, diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamNodeGroupWithAddonPoliciesValue{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPoliciesValueNull() IamNodeGroupWithAddonPoliciesValue {
	return IamNodeGroupWithAddonPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewIamNodeGroupWithAddonPoliciesValueUnknown() IamNodeGroupWithAddonPoliciesValue {
	return IamNodeGroupWithAddonPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIamNodeGroupWithAddonPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamNodeGroupWithAddonPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamNodeGroupWithAddonPoliciesValue Attribute Value",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, a missing attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamNodeGroupWithAddonPoliciesValue Attribute Type",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, an invalid attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamNodeGroupWithAddonPoliciesValue Attribute Value",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, an extra attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamNodeGroupWithAddonPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	return IamNodeGroupWithAddonPoliciesValue{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamNodeGroupWithAddonPoliciesValue {
	object, diags := NewIamNodeGroupWithAddonPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamNodeGroupWithAddonPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamNodeGroupWithAddonPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamNodeGroupWithAddonPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamNodeGroupWithAddonPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamNodeGroupWithAddonPoliciesValueMust(IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IamNodeGroupWithAddonPoliciesType) ValueType(ctx context.Context) attr.Value {
	return IamNodeGroupWithAddonPoliciesValue{}
}

var _ basetypes.ObjectValuable = IamNodeGroupWithAddonPoliciesValue{}

type IamNodeGroupWithAddonPoliciesValue struct {
	AlbIngress    basetypes.BoolValue `tfsdk:"alb_ingress"`
	AppMesh       basetypes.BoolValue `tfsdk:"app_mesh"`
	AppMeshReview basetypes.BoolValue `tfsdk:"app_mesh_review"`
	AutoScaler    basetypes.BoolValue `tfsdk:"auto_scaler"`
	CertManager   basetypes.BoolValue `tfsdk:"cert_manager"`
	CloudWatch    basetypes.BoolValue `tfsdk:"cloud_watch"`
	Ebs           basetypes.BoolValue `tfsdk:"ebs"`
	Efs           basetypes.BoolValue `tfsdk:"efs"`
	ExternalDns   basetypes.BoolValue `tfsdk:"external_dns"`
	Fsx           basetypes.BoolValue `tfsdk:"fsx"`
	ImageBuilder  basetypes.BoolValue `tfsdk:"image_builder"`
	Xray          basetypes.BoolValue `tfsdk:"xray"`
	state         attr.ValueState
}

func (v IamNodeGroupWithAddonPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alb_ingress"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh_review"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fsx"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xray"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AlbIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alb_ingress"] = val

		val, err = v.AppMesh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh"] = val

		val, err = v.AppMeshReview.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh_review"] = val

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.Ebs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs"] = val

		val, err = v.Efs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.Fsx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fsx"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		val, err = v.Xray.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xray"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamNodeGroupWithAddonPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamNodeGroupWithAddonPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamNodeGroupWithAddonPoliciesValue) String() string {
	return "IamNodeGroupWithAddonPoliciesValue"
}

func (v IamNodeGroupWithAddonPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alb_ingress":     v.AlbIngress,
			"app_mesh":        v.AppMesh,
			"app_mesh_review": v.AppMeshReview,
			"auto_scaler":     v.AutoScaler,
			"cert_manager":    v.CertManager,
			"cloud_watch":     v.CloudWatch,
			"ebs":             v.Ebs,
			"efs":             v.Efs,
			"external_dns":    v.ExternalDns,
			"fsx":             v.Fsx,
			"image_builder":   v.ImageBuilder,
			"xray":            v.Xray,
		})

	return objVal, diags
}

func (v IamNodeGroupWithAddonPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(IamNodeGroupWithAddonPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlbIngress.Equal(other.AlbIngress) {
		return false
	}

	if !v.AppMesh.Equal(other.AppMesh) {
		return false
	}

	if !v.AppMeshReview.Equal(other.AppMeshReview) {
		return false
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.Ebs.Equal(other.Ebs) {
		return false
	}

	if !v.Efs.Equal(other.Efs) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.Fsx.Equal(other.Fsx) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	if !v.Xray.Equal(other.Xray) {
		return false
	}

	return true
}

func (v IamNodeGroupWithAddonPoliciesValue) Type(ctx context.Context) attr.Type {
	return IamNodeGroupWithAddonPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamNodeGroupWithAddonPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}
}
