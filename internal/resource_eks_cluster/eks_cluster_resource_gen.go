// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_eks_cluster

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func EksClusterResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Blocks: map[string]schema.Block{
			"cluster": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"kind": schema.StringAttribute{
							Optional:            true,
							Description:         "The resource kind.",
							MarkdownDescription: "The resource kind.",
						},
					},
					Blocks: map[string]schema.Block{
						"metadata": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"labels": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "The labels for the cluster in Rafay console.",
										MarkdownDescription: "The labels for the cluster in Rafay console.",
									},
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the EKS cluster in Rafay console.",
										MarkdownDescription: "The name of the EKS cluster in Rafay console.",
									},
									"project": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the Rafay project the cluster will be created in.",
										MarkdownDescription: "The name of the Rafay project the cluster will be created in.",
									},
								},
								CustomType: MetadataType{
									ObjectType: types.ObjectType{
										AttrTypes: MetadataValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"spec": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"blueprint": schema.StringAttribute{
										Optional:            true,
										Description:         "The name of the blueprint to use for the EKS cluster.",
										MarkdownDescription: "The name of the blueprint to use for the EKS cluster.",
									},
									"blueprint_version": schema.StringAttribute{
										Optional:            true,
										Description:         "The blueprint version.",
										MarkdownDescription: "The blueprint version.",
									},
									"cloud_provider": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the cloud provider for EKS cluster.",
										MarkdownDescription: "The name of the cloud provider for EKS cluster.",
									},
									"cni_provider": schema.StringAttribute{
										Optional:            true,
										Description:         "The CNI provider to use for the EKS cluster.",
										MarkdownDescription: "The CNI provider to use for the EKS cluster.",
									},
									"cross_account_role_arn": schema.StringAttribute{
										Optional:            true,
										Description:         "Role ARN of the linked account.",
										MarkdownDescription: "Role ARN of the linked account.",
									},
									"proxy_config": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Proxy configuration for the EKS cluster.",
										MarkdownDescription: "Proxy configuration for the EKS cluster.",
									},
									"type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of the cluster.",
										MarkdownDescription: "The type of the cluster.",
									},
								},
								Blocks: map[string]schema.Block{
									"cni_params": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"custom_cni_cidr": schema.StringAttribute{
													Optional:            true,
													Description:         "Secondary IPv4 CIDR block for the VPC. This should be specified if you choose to auto-create VPC and subnets while creating the EKS cluster.",
													MarkdownDescription: "Secondary IPv4 CIDR block for the VPC. This should be specified if you choose to auto-create VPC and subnets while creating the EKS cluster.",
												},
											},
											Blocks: map[string]schema.Block{
												"custom_cni_crd_spec": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																Optional:            true,
																Description:         "The name of the Availability Zone (AZ). The availability zone specified here should be a part of the region specified for the EKS cluster.",
																MarkdownDescription: "The name of the Availability Zone (AZ). The availability zone specified here should be a part of the region specified for the EKS cluster.",
															},
														},
														Blocks: map[string]schema.Block{
															"cni_spec": schema.ListNestedBlock{
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																		"security_groups": schema.ListAttribute{
																			ElementType:         types.StringType,
																			Optional:            true,
																			Description:         "The security groups associated with secondary ENIs for AWS EC2 nodes.",
																			MarkdownDescription: "The security groups associated with secondary ENIs for AWS EC2 nodes.",
																		},
																		"subnet": schema.StringAttribute{
																			Optional:            true,
																			Description:         "The subnet associated with secondary ENIs for AWS EC2 nodes.",
																			MarkdownDescription: "The subnet associated with secondary ENIs for AWS EC2 nodes.",
																		},
																	},
																	CustomType: CniSpecType{
																		ObjectType: types.ObjectType{
																			AttrTypes: CniSpecValue{}.AttributeTypes(ctx),
																		},
																	},
																},
															},
														},
														CustomType: CustomCniCrdSpecType{
															ObjectType: types.ObjectType{
																AttrTypes: CustomCniCrdSpecValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: CniParamsType{
												ObjectType: types.ObjectType{
													AttrTypes: CniParamsValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
									"sharing": schema.SingleNestedBlock{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Optional:            true,
												Description:         "Whether to enable cluster sharing.",
												MarkdownDescription: "Whether to enable cluster sharing.",
											},
										},
										Blocks: map[string]schema.Block{
											"projects": schema.ListNestedBlock{
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															Required:            true,
															Description:         "The name of the project to share the cluster with.",
															MarkdownDescription: "The name of the project to share the cluster with.",
														},
													},
													CustomType: ProjectsType{
														ObjectType: types.ObjectType{
															AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
														},
													},
												},
											},
										},
										CustomType: SharingType{
											ObjectType: types.ObjectType{
												AttrTypes: SharingValue{}.AttributeTypes(ctx),
											},
										},
									},
									"system_components_placement": schema.SingleNestedBlock{
										Attributes: map[string]schema.Attribute{
											"node_selector": schema.MapAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "Key-Value pairs insuring pods to be scheduled on desired nodes.",
												MarkdownDescription: "Key-Value pairs insuring pods to be scheduled on desired nodes.",
											},
										},
										Blocks: map[string]schema.Block{
											"daemonset_override": schema.ListNestedBlock{
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"node_selection_enabled": schema.BoolAttribute{
															Optional:            true,
															Description:         "Whether to enable node selection for the daemonset.",
															MarkdownDescription: "Whether to enable node selection for the daemonset.",
														},
													},
													Blocks: map[string]schema.Block{
														"tolerations": schema.ListNestedBlock{
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"effect": schema.StringAttribute{
																		Optional:            true,
																		Description:         "indicates the taint effect to match.",
																		MarkdownDescription: "indicates the taint effect to match.",
																	},
																	"key": schema.StringAttribute{
																		Optional:            true,
																		Description:         "the taint key that the toleration applies to.",
																		MarkdownDescription: "the taint key that the toleration applies to.",
																	},
																	"operator": schema.StringAttribute{
																		Optional:            true,
																		Description:         "represents a key's relationship to the value.",
																		MarkdownDescription: "represents a key's relationship to the value.",
																	},
																	"toleration_seconds": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "represents the period of time the toleration tolerates the taint.",
																		MarkdownDescription: "represents the period of time the toleration tolerates the taint.",
																	},
																	"value": schema.StringAttribute{
																		Optional:            true,
																		Description:         "the taint value the toleration matches to.",
																		MarkdownDescription: "the taint value the toleration matches to.",
																	},
																},
																CustomType: Tolerations2Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Tolerations2Value{}.AttributeTypes(ctx),
																	},
																},
															},
														},
													},
													CustomType: DaemonsetOverrideType{
														ObjectType: types.ObjectType{
															AttrTypes: DaemonsetOverrideValue{}.AttributeTypes(ctx),
														},
													},
												},
											},
											"tolerations": schema.ListNestedBlock{
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"effect": schema.StringAttribute{
															Optional:            true,
															Description:         "indicates the taint effect to match.",
															MarkdownDescription: "indicates the taint effect to match.",
														},
														"key": schema.StringAttribute{
															Optional:            true,
															Description:         "the taint key that the toleration applies to.",
															MarkdownDescription: "the taint key that the toleration applies to.",
														},
														"operator": schema.StringAttribute{
															Optional:            true,
															Description:         "represents a key's relationship to the value.",
															MarkdownDescription: "represents a key's relationship to the value.",
														},
														"toleration_seconds": schema.Int64Attribute{
															Optional:            true,
															Description:         "represents the period of time the toleration tolerates the taint.",
															MarkdownDescription: "represents the period of time the toleration tolerates the taint.",
														},
														"value": schema.StringAttribute{
															Optional:            true,
															Description:         "the taint value the toleration matches to.",
															MarkdownDescription: "the taint value the toleration matches to.",
														},
													},
													CustomType: TolerationsType{
														ObjectType: types.ObjectType{
															AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
														},
													},
												},
											},
										},
										CustomType: SystemComponentsPlacementType{
											ObjectType: types.ObjectType{
												AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
											},
										},
									},
								},
								CustomType: SpecType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
					},
					CustomType: ClusterType{
						ObjectType: types.ObjectType{
							AttrTypes: ClusterValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"cluster_config": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"apiversion": schema.StringAttribute{
							Optional:            true,
							Description:         "The Rafay API version of the EKS cluster.",
							MarkdownDescription: "The Rafay API version of the EKS cluster.",
						},
						"kind": schema.StringAttribute{
							Optional:            true,
							Description:         "The kind of the resource.",
							MarkdownDescription: "The kind of the resource.",
						},
						"node_groups_map": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ami_family": schema.StringAttribute{
										Optional: true,
									},
									"desired_capacity": schema.Int64Attribute{
										Optional: true,
									},
									"disable_imdsv1": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to disable IMDSv1 on the node group.",
										MarkdownDescription: "Whether to disable IMDSv1 on the node group.",
									},
									"disable_pods_imds": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to disable IMDS for pods in the node group.",
										MarkdownDescription: "Whether to disable IMDS for pods in the node group.",
									},
									"efa_enabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										MarkdownDescription: "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
									},
									"iam": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"iam_node_group_with_addon_policies": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"alb_ingress": schema.BoolAttribute{
																Optional: true,
															},
															"app_mesh": schema.BoolAttribute{
																Optional: true,
															},
															"app_mesh_review": schema.BoolAttribute{
																Optional: true,
															},
															"auto_scaler": schema.BoolAttribute{
																Optional: true,
															},
															"cert_manager": schema.BoolAttribute{
																Optional: true,
															},
															"cloud_watch": schema.BoolAttribute{
																Optional: true,
															},
															"ebs": schema.BoolAttribute{
																Optional: true,
															},
															"efs": schema.BoolAttribute{
																Optional: true,
															},
															"external_dns": schema.BoolAttribute{
																Optional: true,
															},
															"fsx": schema.BoolAttribute{
																Optional: true,
															},
															"image_builder": schema.BoolAttribute{
																Optional: true,
															},
															"xray": schema.BoolAttribute{
																Optional: true,
															},
														},
														CustomType: IamNodeGroupWithAddonPolicies2Type{
															ObjectType: types.ObjectType{
																AttrTypes: IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx),
															},
														},
													},
													Optional: true,
												},
											},
											CustomType: Iam2Type{
												ObjectType: types.ObjectType{
													AttrTypes: Iam2Value{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
									"instance_type": schema.StringAttribute{
										Required:            true,
										Description:         "The type of EC2 instance to use for the nodes in this group.",
										MarkdownDescription: "The type of EC2 instance to use for the nodes in this group.",
									},
									"max_pods_per_node": schema.Int64Attribute{
										Optional: true,
									},
									"max_size": schema.Int64Attribute{
										Optional: true,
									},
									"min_size": schema.Int64Attribute{
										Optional: true,
									},
									"private_networking": schema.BoolAttribute{
										Optional:            true,
										Description:         "Enable private networking for the node group.",
										MarkdownDescription: "Enable private networking for the node group.",
									},
									"version": schema.StringAttribute{
										Optional: true,
									},
									"volume_iops": schema.Int64Attribute{
										Optional:            true,
										Description:         "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										MarkdownDescription: "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
									},
									"volume_size": schema.Int64Attribute{
										Optional:            true,
										Description:         "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										MarkdownDescription: "The size of the EBS volumes attached to the nodes in this group, in GiB.",
									},
									"volume_throughput": schema.Int64Attribute{
										Optional:            true,
										Description:         "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										MarkdownDescription: "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
									},
									"volume_type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of EBS volume to use for the nodes in this group.",
										MarkdownDescription: "The type of EBS volume to use for the nodes in this group.",
									},
								},
								CustomType: NodeGroupsMapType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Map of node group names to their configurations. Each key is the name of the node group, and the value is an object containing the configuration for that node group.",
							MarkdownDescription: "Map of node group names to their configurations. Each key is the name of the node group, and the value is an object containing the configuration for that node group.",
						},
					},
					Blocks: map[string]schema.Block{
						"metadata": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "EKS Cluster name.",
										MarkdownDescription: "EKS Cluster name.",
									},
									"region": schema.StringAttribute{
										Required:            true,
										Description:         "The AWS region hosting this cluster.",
										MarkdownDescription: "The AWS region hosting this cluster.",
									},
									"tags": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "A map of tags to assign to the EKS cluster.",
										MarkdownDescription: "A map of tags to assign to the EKS cluster.",
									},
									"version": schema.StringAttribute{
										Optional:            true,
										Description:         "The version of the EKS control plane.",
										MarkdownDescription: "The version of the EKS control plane.",
									},
								},
								CustomType: Metadata2Type{
									ObjectType: types.ObjectType{
										AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
									},
								},
							},
						},
						"node_groups": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"ami_family": schema.StringAttribute{
										Optional: true,
									},
									"desired_capacity": schema.Int64Attribute{
										Optional: true,
									},
									"disable_imdsv1": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to disable IMDSv1 on the node group.",
										MarkdownDescription: "Whether to disable IMDSv1 on the node group.",
									},
									"disable_pods_imds": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to disable IMDS for pods in the node group.",
										MarkdownDescription: "Whether to disable IMDS for pods in the node group.",
									},
									"efa_enabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
										MarkdownDescription: "Creates the maximum allowed number of EFA-enabled network cards on nodes in this group.",
									},
									"instance_type": schema.StringAttribute{
										Required:            true,
										Description:         "The type of EC2 instance to use for the nodes in this group.",
										MarkdownDescription: "The type of EC2 instance to use for the nodes in this group.",
									},
									"max_pods_per_node": schema.Int64Attribute{
										Optional: true,
									},
									"max_size": schema.Int64Attribute{
										Optional: true,
									},
									"min_size": schema.Int64Attribute{
										Optional: true,
									},
									"name": schema.StringAttribute{
										Required:            true,
										Description:         "The name of the node group.",
										MarkdownDescription: "The name of the node group.",
									},
									"private_networking": schema.BoolAttribute{
										Optional:            true,
										Description:         "Enable private networking for the node group.",
										MarkdownDescription: "Enable private networking for the node group.",
									},
									"version": schema.StringAttribute{
										Optional: true,
									},
									"volume_iops": schema.Int64Attribute{
										Optional:            true,
										Description:         "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
										MarkdownDescription: "The number of IOPS to provision for the EBS volumes attached to the nodes in this group.",
									},
									"volume_size": schema.Int64Attribute{
										Optional:            true,
										Description:         "The size of the EBS volumes attached to the nodes in this group, in GiB.",
										MarkdownDescription: "The size of the EBS volumes attached to the nodes in this group, in GiB.",
									},
									"volume_throughput": schema.Int64Attribute{
										Optional:            true,
										Description:         "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
										MarkdownDescription: "The throughput of the EBS volumes attached to the nodes in this group, in MiB/s.",
									},
									"volume_type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of EBS volume to use for the nodes in this group.",
										MarkdownDescription: "The type of EBS volume to use for the nodes in this group.",
									},
								},
								Blocks: map[string]schema.Block{
									"iam": schema.ListNestedBlock{
										NestedObject: schema.NestedBlockObject{
											Blocks: map[string]schema.Block{
												"iam_node_group_with_addon_policies": schema.ListNestedBlock{
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{
															"alb_ingress": schema.BoolAttribute{
																Optional: true,
															},
															"app_mesh": schema.BoolAttribute{
																Optional: true,
															},
															"app_mesh_review": schema.BoolAttribute{
																Optional: true,
															},
															"auto_scaler": schema.BoolAttribute{
																Optional: true,
															},
															"cert_manager": schema.BoolAttribute{
																Optional: true,
															},
															"cloud_watch": schema.BoolAttribute{
																Optional: true,
															},
															"ebs": schema.BoolAttribute{
																Optional: true,
															},
															"efs": schema.BoolAttribute{
																Optional: true,
															},
															"external_dns": schema.BoolAttribute{
																Optional: true,
															},
															"fsx": schema.BoolAttribute{
																Optional: true,
															},
															"image_builder": schema.BoolAttribute{
																Optional: true,
															},
															"xray": schema.BoolAttribute{
																Optional: true,
															},
														},
														CustomType: IamNodeGroupWithAddonPoliciesType{
															ObjectType: types.ObjectType{
																AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
															},
														},
													},
												},
											},
											CustomType: IamType{
												ObjectType: types.ObjectType{
													AttrTypes: IamValue{}.AttributeTypes(ctx),
												},
											},
										},
									},
								},
								CustomType: NodeGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							DeprecationMessage: "The 'node_groups' block is deprecated and will be removed in a future release. Use 'node_groups_map'                                                                                                             for new configs. Existing setups still work, but migration is recommended.",
						},
					},
					CustomType: ClusterConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
		},
		Version: 1,
	}
}

type EksClusterModel struct {
	Cluster       types.List `tfsdk:"cluster"`
	ClusterConfig types.List `tfsdk:"cluster_config"`
}

var _ basetypes.ObjectTypable = ClusterType{}

type ClusterType struct {
	basetypes.ObjectType
}

func (t ClusterType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterType) String() string {
	return "ClusterType"
}

func (t ClusterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ListValue, was: %T`, specAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterValue{
		Kind:     kindVal,
		Metadata: metadataVal,
		Spec:     specVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterValueNull() ClusterValue {
	return ClusterValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterValueUnknown() ClusterValue {
	return ClusterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterValue Attribute Value",
				"While creating a ClusterValue value, a missing attribute value was detected. "+
					"A ClusterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterValue Attribute Type",
				"While creating a ClusterValue value, an invalid attribute value was detected. "+
					"A ClusterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterValue Attribute Value",
				"While creating a ClusterValue value, an extra attribute value was detected. "+
					"A ClusterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterValueUnknown(), diags
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewClusterValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ListValue, was: %T`, specAttribute))
	}

	if diags.HasError() {
		return NewClusterValueUnknown(), diags
	}

	return ClusterValue{
		Kind:     kindVal,
		Metadata: metadataVal,
		Spec:     specVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterValue {
	object, diags := NewClusterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterValueMust(ClusterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterType) ValueType(ctx context.Context) attr.Value {
	return ClusterValue{}
}

var _ basetypes.ObjectValuable = ClusterValue{}

type ClusterValue struct {
	Kind     basetypes.StringValue `tfsdk:"kind"`
	Metadata basetypes.ListValue   `tfsdk:"metadata"`
	Spec     basetypes.ListValue   `tfsdk:"spec"`
	state    attr.ValueState
}

func (v ClusterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: MetadataValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ListType{
		ElemType: SpecValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterValue) String() string {
	return "ClusterValue"
}

func (v ClusterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	metadata := types.ListValueMust(
		MetadataType{
			basetypes.ObjectType{
				AttrTypes: MetadataValue{}.AttributeTypes(ctx),
			},
		},
		v.Metadata.Elements(),
	)

	if v.Metadata.IsNull() {
		metadata = types.ListNull(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ListUnknown(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	spec := types.ListValueMust(
		SpecType{
			basetypes.ObjectType{
				AttrTypes: SpecValue{}.AttributeTypes(ctx),
			},
		},
		v.Spec.Elements(),
	)

	if v.Spec.IsNull() {
		spec = types.ListNull(
			SpecType{
				basetypes.ObjectType{
					AttrTypes: SpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ListUnknown(
			SpecType{
				basetypes.ObjectType{
					AttrTypes: SpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"kind": basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"spec": basetypes.ListType{
			ElemType: SpecValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"kind":     v.Kind,
			"metadata": metadata,
			"spec":     spec,
		})

	return objVal, diags
}

func (v ClusterValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	return true
}

func (v ClusterValue) Type(ctx context.Context) attr.Type {
	return ClusterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"kind": basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"spec": basetypes.ListType{
			ElemType: SpecValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Labels:  labelsVal,
		Name:    nameVal,
		Project: projectVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Labels:  labelsVal,
		Name:    nameVal,
		Project: projectVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Labels  basetypes.MapValue    `tfsdk:"labels"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Project basetypes.StringValue `tfsdk:"project"`
	state   attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":    basetypes.StringType{},
			"project": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":    basetypes.StringType{},
		"project": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"labels":  labelsVal,
			"name":    v.Name,
			"project": v.Project,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":    basetypes.StringType{},
		"project": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return nil, diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.StringValue, was: %T`, blueprintAttribute))
	}

	blueprintVersionAttribute, ok := attributes["blueprint_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint_version is missing from object`)

		return nil, diags
	}

	blueprintVersionVal, ok := blueprintVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint_version expected to be basetypes.StringValue, was: %T`, blueprintVersionAttribute))
	}

	cloudProviderAttribute, ok := attributes["cloud_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider is missing from object`)

		return nil, diags
	}

	cloudProviderVal, ok := cloudProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider expected to be basetypes.StringValue, was: %T`, cloudProviderAttribute))
	}

	cniParamsAttribute, ok := attributes["cni_params"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_params is missing from object`)

		return nil, diags
	}

	cniParamsVal, ok := cniParamsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_params expected to be basetypes.ListValue, was: %T`, cniParamsAttribute))
	}

	cniProviderAttribute, ok := attributes["cni_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_provider is missing from object`)

		return nil, diags
	}

	cniProviderVal, ok := cniProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_provider expected to be basetypes.StringValue, was: %T`, cniProviderAttribute))
	}

	crossAccountRoleArnAttribute, ok := attributes["cross_account_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cross_account_role_arn is missing from object`)

		return nil, diags
	}

	crossAccountRoleArnVal, ok := crossAccountRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cross_account_role_arn expected to be basetypes.StringValue, was: %T`, crossAccountRoleArnAttribute))
	}

	proxyConfigAttribute, ok := attributes["proxy_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_config is missing from object`)

		return nil, diags
	}

	proxyConfigVal, ok := proxyConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_config expected to be basetypes.MapValue, was: %T`, proxyConfigAttribute))
	}

	sharingAttribute, ok := attributes["sharing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sharing is missing from object`)

		return nil, diags
	}

	sharingVal, ok := sharingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sharing expected to be basetypes.ObjectValue, was: %T`, sharingAttribute))
	}

	systemComponentsPlacementAttribute, ok := attributes["system_components_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_components_placement is missing from object`)

		return nil, diags
	}

	systemComponentsPlacementVal, ok := systemComponentsPlacementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_components_placement expected to be basetypes.ObjectValue, was: %T`, systemComponentsPlacementAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Blueprint:                 blueprintVal,
		BlueprintVersion:          blueprintVersionVal,
		CloudProvider:             cloudProviderVal,
		CniParams:                 cniParamsVal,
		CniProvider:               cniProviderVal,
		CrossAccountRoleArn:       crossAccountRoleArnVal,
		ProxyConfig:               proxyConfigVal,
		Sharing:                   sharingVal,
		SystemComponentsPlacement: systemComponentsPlacementVal,
		SpecType:                  typeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.StringValue, was: %T`, blueprintAttribute))
	}

	blueprintVersionAttribute, ok := attributes["blueprint_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint_version is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	blueprintVersionVal, ok := blueprintVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint_version expected to be basetypes.StringValue, was: %T`, blueprintVersionAttribute))
	}

	cloudProviderAttribute, ok := attributes["cloud_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_provider is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cloudProviderVal, ok := cloudProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_provider expected to be basetypes.StringValue, was: %T`, cloudProviderAttribute))
	}

	cniParamsAttribute, ok := attributes["cni_params"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_params is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cniParamsVal, ok := cniParamsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_params expected to be basetypes.ListValue, was: %T`, cniParamsAttribute))
	}

	cniProviderAttribute, ok := attributes["cni_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_provider is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cniProviderVal, ok := cniProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_provider expected to be basetypes.StringValue, was: %T`, cniProviderAttribute))
	}

	crossAccountRoleArnAttribute, ok := attributes["cross_account_role_arn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cross_account_role_arn is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	crossAccountRoleArnVal, ok := crossAccountRoleArnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cross_account_role_arn expected to be basetypes.StringValue, was: %T`, crossAccountRoleArnAttribute))
	}

	proxyConfigAttribute, ok := attributes["proxy_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_config is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	proxyConfigVal, ok := proxyConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_config expected to be basetypes.MapValue, was: %T`, proxyConfigAttribute))
	}

	sharingAttribute, ok := attributes["sharing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sharing is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sharingVal, ok := sharingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sharing expected to be basetypes.ObjectValue, was: %T`, sharingAttribute))
	}

	systemComponentsPlacementAttribute, ok := attributes["system_components_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_components_placement is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemComponentsPlacementVal, ok := systemComponentsPlacementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_components_placement expected to be basetypes.ObjectValue, was: %T`, systemComponentsPlacementAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Blueprint:                 blueprintVal,
		BlueprintVersion:          blueprintVersionVal,
		CloudProvider:             cloudProviderVal,
		CniParams:                 cniParamsVal,
		CniProvider:               cniProviderVal,
		CrossAccountRoleArn:       crossAccountRoleArnVal,
		ProxyConfig:               proxyConfigVal,
		Sharing:                   sharingVal,
		SystemComponentsPlacement: systemComponentsPlacementVal,
		SpecType:                  typeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Blueprint                 basetypes.StringValue `tfsdk:"blueprint"`
	BlueprintVersion          basetypes.StringValue `tfsdk:"blueprint_version"`
	CloudProvider             basetypes.StringValue `tfsdk:"cloud_provider"`
	CniParams                 basetypes.ListValue   `tfsdk:"cni_params"`
	CniProvider               basetypes.StringValue `tfsdk:"cni_provider"`
	CrossAccountRoleArn       basetypes.StringValue `tfsdk:"cross_account_role_arn"`
	ProxyConfig               basetypes.MapValue    `tfsdk:"proxy_config"`
	Sharing                   basetypes.ObjectValue `tfsdk:"sharing"`
	SystemComponentsPlacement basetypes.ObjectValue `tfsdk:"system_components_placement"`
	SpecType                  basetypes.StringValue `tfsdk:"type"`
	state                     attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["blueprint"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["blueprint_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cloud_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cni_params"] = basetypes.ListType{
		ElemType: CniParamsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["cni_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cross_account_role_arn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["proxy_config"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sharing"] = basetypes.ObjectType{
		AttrTypes: SharingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["system_components_placement"] = basetypes.ObjectType{
		AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Blueprint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blueprint"] = val

		val, err = v.BlueprintVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blueprint_version"] = val

		val, err = v.CloudProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_provider"] = val

		val, err = v.CniParams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cni_params"] = val

		val, err = v.CniProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cni_provider"] = val

		val, err = v.CrossAccountRoleArn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cross_account_role_arn"] = val

		val, err = v.ProxyConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_config"] = val

		val, err = v.Sharing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sharing"] = val

		val, err = v.SystemComponentsPlacement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_components_placement"] = val

		val, err = v.SpecType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	cniParams := types.ListValueMust(
		CniParamsType{
			basetypes.ObjectType{
				AttrTypes: CniParamsValue{}.AttributeTypes(ctx),
			},
		},
		v.CniParams.Elements(),
	)

	if v.CniParams.IsNull() {
		cniParams = types.ListNull(
			CniParamsType{
				basetypes.ObjectType{
					AttrTypes: CniParamsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CniParams.IsUnknown() {
		cniParams = types.ListUnknown(
			CniParamsType{
				basetypes.ObjectType{
					AttrTypes: CniParamsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var sharing basetypes.ObjectValue

	if v.Sharing.IsNull() {
		sharing = types.ObjectNull(
			SharingValue{}.AttributeTypes(ctx),
		)
	}

	if v.Sharing.IsUnknown() {
		sharing = types.ObjectUnknown(
			SharingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Sharing.IsNull() && !v.Sharing.IsUnknown() {
		sharing = types.ObjectValueMust(
			SharingValue{}.AttributeTypes(ctx),
			v.Sharing.Attributes(),
		)
	}

	var systemComponentsPlacement basetypes.ObjectValue

	if v.SystemComponentsPlacement.IsNull() {
		systemComponentsPlacement = types.ObjectNull(
			SystemComponentsPlacementValue{}.AttributeTypes(ctx),
		)
	}

	if v.SystemComponentsPlacement.IsUnknown() {
		systemComponentsPlacement = types.ObjectUnknown(
			SystemComponentsPlacementValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SystemComponentsPlacement.IsNull() && !v.SystemComponentsPlacement.IsUnknown() {
		systemComponentsPlacement = types.ObjectValueMust(
			SystemComponentsPlacementValue{}.AttributeTypes(ctx),
			v.SystemComponentsPlacement.Attributes(),
		)
	}

	var proxyConfigVal basetypes.MapValue
	switch {
	case v.ProxyConfig.IsUnknown():
		proxyConfigVal = types.MapUnknown(types.StringType)
	case v.ProxyConfig.IsNull():
		proxyConfigVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		proxyConfigVal, d = types.MapValue(types.StringType, v.ProxyConfig.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"blueprint":         basetypes.StringType{},
			"blueprint_version": basetypes.StringType{},
			"cloud_provider":    basetypes.StringType{},
			"cni_params": basetypes.ListType{
				ElemType: CniParamsValue{}.Type(ctx),
			},
			"cni_provider":           basetypes.StringType{},
			"cross_account_role_arn": basetypes.StringType{},
			"proxy_config": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sharing": basetypes.ObjectType{
				AttrTypes: SharingValue{}.AttributeTypes(ctx),
			},
			"system_components_placement": basetypes.ObjectType{
				AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"blueprint":         basetypes.StringType{},
		"blueprint_version": basetypes.StringType{},
		"cloud_provider":    basetypes.StringType{},
		"cni_params": basetypes.ListType{
			ElemType: CniParamsValue{}.Type(ctx),
		},
		"cni_provider":           basetypes.StringType{},
		"cross_account_role_arn": basetypes.StringType{},
		"proxy_config": basetypes.MapType{
			ElemType: types.StringType,
		},
		"sharing": basetypes.ObjectType{
			AttrTypes: SharingValue{}.AttributeTypes(ctx),
		},
		"system_components_placement": basetypes.ObjectType{
			AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"blueprint":                   v.Blueprint,
			"blueprint_version":           v.BlueprintVersion,
			"cloud_provider":              v.CloudProvider,
			"cni_params":                  cniParams,
			"cni_provider":                v.CniProvider,
			"cross_account_role_arn":      v.CrossAccountRoleArn,
			"proxy_config":                proxyConfigVal,
			"sharing":                     sharing,
			"system_components_placement": systemComponentsPlacement,
			"type":                        v.SpecType,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Blueprint.Equal(other.Blueprint) {
		return false
	}

	if !v.BlueprintVersion.Equal(other.BlueprintVersion) {
		return false
	}

	if !v.CloudProvider.Equal(other.CloudProvider) {
		return false
	}

	if !v.CniParams.Equal(other.CniParams) {
		return false
	}

	if !v.CniProvider.Equal(other.CniProvider) {
		return false
	}

	if !v.CrossAccountRoleArn.Equal(other.CrossAccountRoleArn) {
		return false
	}

	if !v.ProxyConfig.Equal(other.ProxyConfig) {
		return false
	}

	if !v.Sharing.Equal(other.Sharing) {
		return false
	}

	if !v.SystemComponentsPlacement.Equal(other.SystemComponentsPlacement) {
		return false
	}

	if !v.SpecType.Equal(other.SpecType) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"blueprint":         basetypes.StringType{},
		"blueprint_version": basetypes.StringType{},
		"cloud_provider":    basetypes.StringType{},
		"cni_params": basetypes.ListType{
			ElemType: CniParamsValue{}.Type(ctx),
		},
		"cni_provider":           basetypes.StringType{},
		"cross_account_role_arn": basetypes.StringType{},
		"proxy_config": basetypes.MapType{
			ElemType: types.StringType,
		},
		"sharing": basetypes.ObjectType{
			AttrTypes: SharingValue{}.AttributeTypes(ctx),
		},
		"system_components_placement": basetypes.ObjectType{
			AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CniParamsType{}

type CniParamsType struct {
	basetypes.ObjectType
}

func (t CniParamsType) Equal(o attr.Type) bool {
	other, ok := o.(CniParamsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CniParamsType) String() string {
	return "CniParamsType"
}

func (t CniParamsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customCniCidrAttribute, ok := attributes["custom_cni_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_cni_cidr is missing from object`)

		return nil, diags
	}

	customCniCidrVal, ok := customCniCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_cni_cidr expected to be basetypes.StringValue, was: %T`, customCniCidrAttribute))
	}

	customCniCrdSpecAttribute, ok := attributes["custom_cni_crd_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_cni_crd_spec is missing from object`)

		return nil, diags
	}

	customCniCrdSpecVal, ok := customCniCrdSpecAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_cni_crd_spec expected to be basetypes.ListValue, was: %T`, customCniCrdSpecAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CniParamsValue{
		CustomCniCidr:    customCniCidrVal,
		CustomCniCrdSpec: customCniCrdSpecVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCniParamsValueNull() CniParamsValue {
	return CniParamsValue{
		state: attr.ValueStateNull,
	}
}

func NewCniParamsValueUnknown() CniParamsValue {
	return CniParamsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCniParamsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CniParamsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CniParamsValue Attribute Value",
				"While creating a CniParamsValue value, a missing attribute value was detected. "+
					"A CniParamsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniParamsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CniParamsValue Attribute Type",
				"While creating a CniParamsValue value, an invalid attribute value was detected. "+
					"A CniParamsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniParamsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CniParamsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CniParamsValue Attribute Value",
				"While creating a CniParamsValue value, an extra attribute value was detected. "+
					"A CniParamsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CniParamsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCniParamsValueUnknown(), diags
	}

	customCniCidrAttribute, ok := attributes["custom_cni_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_cni_cidr is missing from object`)

		return NewCniParamsValueUnknown(), diags
	}

	customCniCidrVal, ok := customCniCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_cni_cidr expected to be basetypes.StringValue, was: %T`, customCniCidrAttribute))
	}

	customCniCrdSpecAttribute, ok := attributes["custom_cni_crd_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_cni_crd_spec is missing from object`)

		return NewCniParamsValueUnknown(), diags
	}

	customCniCrdSpecVal, ok := customCniCrdSpecAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_cni_crd_spec expected to be basetypes.ListValue, was: %T`, customCniCrdSpecAttribute))
	}

	if diags.HasError() {
		return NewCniParamsValueUnknown(), diags
	}

	return CniParamsValue{
		CustomCniCidr:    customCniCidrVal,
		CustomCniCrdSpec: customCniCrdSpecVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCniParamsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CniParamsValue {
	object, diags := NewCniParamsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCniParamsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CniParamsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCniParamsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCniParamsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCniParamsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCniParamsValueMust(CniParamsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CniParamsType) ValueType(ctx context.Context) attr.Value {
	return CniParamsValue{}
}

var _ basetypes.ObjectValuable = CniParamsValue{}

type CniParamsValue struct {
	CustomCniCidr    basetypes.StringValue `tfsdk:"custom_cni_cidr"`
	CustomCniCrdSpec basetypes.ListValue   `tfsdk:"custom_cni_crd_spec"`
	state            attr.ValueState
}

func (v CniParamsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["custom_cni_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_cni_crd_spec"] = basetypes.ListType{
		ElemType: CustomCniCrdSpecValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CustomCniCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_cni_cidr"] = val

		val, err = v.CustomCniCrdSpec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_cni_crd_spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CniParamsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CniParamsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CniParamsValue) String() string {
	return "CniParamsValue"
}

func (v CniParamsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	customCniCrdSpec := types.ListValueMust(
		CustomCniCrdSpecType{
			basetypes.ObjectType{
				AttrTypes: CustomCniCrdSpecValue{}.AttributeTypes(ctx),
			},
		},
		v.CustomCniCrdSpec.Elements(),
	)

	if v.CustomCniCrdSpec.IsNull() {
		customCniCrdSpec = types.ListNull(
			CustomCniCrdSpecType{
				basetypes.ObjectType{
					AttrTypes: CustomCniCrdSpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CustomCniCrdSpec.IsUnknown() {
		customCniCrdSpec = types.ListUnknown(
			CustomCniCrdSpecType{
				basetypes.ObjectType{
					AttrTypes: CustomCniCrdSpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"custom_cni_cidr": basetypes.StringType{},
		"custom_cni_crd_spec": basetypes.ListType{
			ElemType: CustomCniCrdSpecValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_cni_cidr":     v.CustomCniCidr,
			"custom_cni_crd_spec": customCniCrdSpec,
		})

	return objVal, diags
}

func (v CniParamsValue) Equal(o attr.Value) bool {
	other, ok := o.(CniParamsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomCniCidr.Equal(other.CustomCniCidr) {
		return false
	}

	if !v.CustomCniCrdSpec.Equal(other.CustomCniCrdSpec) {
		return false
	}

	return true
}

func (v CniParamsValue) Type(ctx context.Context) attr.Type {
	return CniParamsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CniParamsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_cni_cidr": basetypes.StringType{},
		"custom_cni_crd_spec": basetypes.ListType{
			ElemType: CustomCniCrdSpecValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = CustomCniCrdSpecType{}

type CustomCniCrdSpecType struct {
	basetypes.ObjectType
}

func (t CustomCniCrdSpecType) Equal(o attr.Type) bool {
	other, ok := o.(CustomCniCrdSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomCniCrdSpecType) String() string {
	return "CustomCniCrdSpecType"
}

func (t CustomCniCrdSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cniSpecAttribute, ok := attributes["cni_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_spec is missing from object`)

		return nil, diags
	}

	cniSpecVal, ok := cniSpecAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_spec expected to be basetypes.ListValue, was: %T`, cniSpecAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomCniCrdSpecValue{
		CniSpec: cniSpecVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCustomCniCrdSpecValueNull() CustomCniCrdSpecValue {
	return CustomCniCrdSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomCniCrdSpecValueUnknown() CustomCniCrdSpecValue {
	return CustomCniCrdSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomCniCrdSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomCniCrdSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomCniCrdSpecValue Attribute Value",
				"While creating a CustomCniCrdSpecValue value, a missing attribute value was detected. "+
					"A CustomCniCrdSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomCniCrdSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomCniCrdSpecValue Attribute Type",
				"While creating a CustomCniCrdSpecValue value, an invalid attribute value was detected. "+
					"A CustomCniCrdSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomCniCrdSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomCniCrdSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomCniCrdSpecValue Attribute Value",
				"While creating a CustomCniCrdSpecValue value, an extra attribute value was detected. "+
					"A CustomCniCrdSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomCniCrdSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomCniCrdSpecValueUnknown(), diags
	}

	cniSpecAttribute, ok := attributes["cni_spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni_spec is missing from object`)

		return NewCustomCniCrdSpecValueUnknown(), diags
	}

	cniSpecVal, ok := cniSpecAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni_spec expected to be basetypes.ListValue, was: %T`, cniSpecAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCustomCniCrdSpecValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewCustomCniCrdSpecValueUnknown(), diags
	}

	return CustomCniCrdSpecValue{
		CniSpec: cniSpecVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCustomCniCrdSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomCniCrdSpecValue {
	object, diags := NewCustomCniCrdSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomCniCrdSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomCniCrdSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomCniCrdSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomCniCrdSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomCniCrdSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomCniCrdSpecValueMust(CustomCniCrdSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomCniCrdSpecType) ValueType(ctx context.Context) attr.Value {
	return CustomCniCrdSpecValue{}
}

var _ basetypes.ObjectValuable = CustomCniCrdSpecValue{}

type CustomCniCrdSpecValue struct {
	CniSpec basetypes.ListValue   `tfsdk:"cni_spec"`
	Name    basetypes.StringValue `tfsdk:"name"`
	state   attr.ValueState
}

func (v CustomCniCrdSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cni_spec"] = basetypes.ListType{
		ElemType: CniSpecValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CniSpec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cni_spec"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomCniCrdSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomCniCrdSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomCniCrdSpecValue) String() string {
	return "CustomCniCrdSpecValue"
}

func (v CustomCniCrdSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	cniSpec := types.ListValueMust(
		CniSpecType{
			basetypes.ObjectType{
				AttrTypes: CniSpecValue{}.AttributeTypes(ctx),
			},
		},
		v.CniSpec.Elements(),
	)

	if v.CniSpec.IsNull() {
		cniSpec = types.ListNull(
			CniSpecType{
				basetypes.ObjectType{
					AttrTypes: CniSpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CniSpec.IsUnknown() {
		cniSpec = types.ListUnknown(
			CniSpecType{
				basetypes.ObjectType{
					AttrTypes: CniSpecValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"cni_spec": basetypes.ListType{
			ElemType: CniSpecValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cni_spec": cniSpec,
			"name":     v.Name,
		})

	return objVal, diags
}

func (v CustomCniCrdSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomCniCrdSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CniSpec.Equal(other.CniSpec) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v CustomCniCrdSpecValue) Type(ctx context.Context) attr.Type {
	return CustomCniCrdSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomCniCrdSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cni_spec": basetypes.ListType{
			ElemType: CniSpecValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CniSpecType{}

type CniSpecType struct {
	basetypes.ObjectType
}

func (t CniSpecType) Equal(o attr.Type) bool {
	other, ok := o.(CniSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CniSpecType) String() string {
	return "CniSpecType"
}

func (t CniSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CniSpecValue{
		SecurityGroups: securityGroupsVal,
		Subnet:         subnetVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCniSpecValueNull() CniSpecValue {
	return CniSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewCniSpecValueUnknown() CniSpecValue {
	return CniSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCniSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CniSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CniSpecValue Attribute Value",
				"While creating a CniSpecValue value, a missing attribute value was detected. "+
					"A CniSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CniSpecValue Attribute Type",
				"While creating a CniSpecValue value, an invalid attribute value was detected. "+
					"A CniSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CniSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CniSpecValue Attribute Value",
				"While creating a CniSpecValue value, an extra attribute value was detected. "+
					"A CniSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CniSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCniSpecValueUnknown(), diags
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewCniSpecValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewCniSpecValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return NewCniSpecValueUnknown(), diags
	}

	return CniSpecValue{
		SecurityGroups: securityGroupsVal,
		Subnet:         subnetVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCniSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CniSpecValue {
	object, diags := NewCniSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCniSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CniSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCniSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCniSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCniSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCniSpecValueMust(CniSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CniSpecType) ValueType(ctx context.Context) attr.Value {
	return CniSpecValue{}
}

var _ basetypes.ObjectValuable = CniSpecValue{}

type CniSpecValue struct {
	SecurityGroups basetypes.ListValue   `tfsdk:"security_groups"`
	Subnet         basetypes.StringValue `tfsdk:"subnet"`
	state          attr.ValueState
}

func (v CniSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CniSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CniSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CniSpecValue) String() string {
	return "CniSpecValue"
}

func (v CniSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var securityGroupsVal basetypes.ListValue
	switch {
	case v.SecurityGroups.IsUnknown():
		securityGroupsVal = types.ListUnknown(types.StringType)
	case v.SecurityGroups.IsNull():
		securityGroupsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		securityGroupsVal, d = types.ListValue(types.StringType, v.SecurityGroups.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"security_groups": basetypes.ListType{
				ElemType: types.StringType,
			},
			"subnet": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"security_groups": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subnet": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"security_groups": securityGroupsVal,
			"subnet":          v.Subnet,
		})

	return objVal, diags
}

func (v CniSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(CniSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	return true
}

func (v CniSpecValue) Type(ctx context.Context) attr.Type {
	return CniSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CniSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"security_groups": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subnet": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SharingType{}

type SharingType struct {
	basetypes.ObjectType
}

func (t SharingType) Equal(o attr.Type) bool {
	other, ok := o.(SharingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SharingType) String() string {
	return "SharingType"
}

func (t SharingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	projectsAttribute, ok := attributes["projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`projects is missing from object`)

		return nil, diags
	}

	projectsVal, ok := projectsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`projects expected to be basetypes.ListValue, was: %T`, projectsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SharingValue{
		Enabled:  enabledVal,
		Projects: projectsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSharingValueNull() SharingValue {
	return SharingValue{
		state: attr.ValueStateNull,
	}
}

func NewSharingValueUnknown() SharingValue {
	return SharingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSharingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SharingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SharingValue Attribute Value",
				"While creating a SharingValue value, a missing attribute value was detected. "+
					"A SharingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SharingValue Attribute Type",
				"While creating a SharingValue value, an invalid attribute value was detected. "+
					"A SharingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SharingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SharingValue Attribute Value",
				"While creating a SharingValue value, an extra attribute value was detected. "+
					"A SharingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SharingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSharingValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSharingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	projectsAttribute, ok := attributes["projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`projects is missing from object`)

		return NewSharingValueUnknown(), diags
	}

	projectsVal, ok := projectsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`projects expected to be basetypes.ListValue, was: %T`, projectsAttribute))
	}

	if diags.HasError() {
		return NewSharingValueUnknown(), diags
	}

	return SharingValue{
		Enabled:  enabledVal,
		Projects: projectsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSharingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SharingValue {
	object, diags := NewSharingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSharingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SharingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSharingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSharingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSharingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSharingValueMust(SharingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SharingType) ValueType(ctx context.Context) attr.Value {
	return SharingValue{}
}

var _ basetypes.ObjectValuable = SharingValue{}

type SharingValue struct {
	Enabled  basetypes.BoolValue `tfsdk:"enabled"`
	Projects basetypes.ListValue `tfsdk:"projects"`
	state    attr.ValueState
}

func (v SharingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["projects"] = basetypes.ListType{
		ElemType: ProjectsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Projects.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["projects"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SharingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SharingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SharingValue) String() string {
	return "SharingValue"
}

func (v SharingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	projects := types.ListValueMust(
		ProjectsType{
			basetypes.ObjectType{
				AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
			},
		},
		v.Projects.Elements(),
	)

	if v.Projects.IsNull() {
		projects = types.ListNull(
			ProjectsType{
				basetypes.ObjectType{
					AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Projects.IsUnknown() {
		projects = types.ListUnknown(
			ProjectsType{
				basetypes.ObjectType{
					AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"projects": basetypes.ListType{
			ElemType: ProjectsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":  v.Enabled,
			"projects": projects,
		})

	return objVal, diags
}

func (v SharingValue) Equal(o attr.Value) bool {
	other, ok := o.(SharingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Projects.Equal(other.Projects) {
		return false
	}

	return true
}

func (v SharingValue) Type(ctx context.Context) attr.Type {
	return SharingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SharingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"projects": basetypes.ListType{
			ElemType: ProjectsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ProjectsType{}

type ProjectsType struct {
	basetypes.ObjectType
}

func (t ProjectsType) Equal(o attr.Type) bool {
	other, ok := o.(ProjectsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProjectsType) String() string {
	return "ProjectsType"
}

func (t ProjectsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProjectsValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProjectsValueNull() ProjectsValue {
	return ProjectsValue{
		state: attr.ValueStateNull,
	}
}

func NewProjectsValueUnknown() ProjectsValue {
	return ProjectsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProjectsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProjectsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProjectsValue Attribute Value",
				"While creating a ProjectsValue value, a missing attribute value was detected. "+
					"A ProjectsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProjectsValue Attribute Type",
				"While creating a ProjectsValue value, an invalid attribute value was detected. "+
					"A ProjectsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProjectsValue Attribute Value",
				"While creating a ProjectsValue value, an extra attribute value was detected. "+
					"A ProjectsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProjectsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProjectsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewProjectsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewProjectsValueUnknown(), diags
	}

	return ProjectsValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProjectsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProjectsValue {
	object, diags := NewProjectsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProjectsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProjectsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProjectsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProjectsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProjectsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProjectsValueMust(ProjectsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProjectsType) ValueType(ctx context.Context) attr.Value {
	return ProjectsValue{}
}

var _ basetypes.ObjectValuable = ProjectsValue{}

type ProjectsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v ProjectsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProjectsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProjectsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProjectsValue) String() string {
	return "ProjectsValue"
}

func (v ProjectsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v ProjectsValue) Equal(o attr.Value) bool {
	other, ok := o.(ProjectsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ProjectsValue) Type(ctx context.Context) attr.Type {
	return ProjectsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProjectsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SystemComponentsPlacementType{}

type SystemComponentsPlacementType struct {
	basetypes.ObjectType
}

func (t SystemComponentsPlacementType) Equal(o attr.Type) bool {
	other, ok := o.(SystemComponentsPlacementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SystemComponentsPlacementType) String() string {
	return "SystemComponentsPlacementType"
}

func (t SystemComponentsPlacementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	daemonsetOverrideAttribute, ok := attributes["daemonset_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daemonset_override is missing from object`)

		return nil, diags
	}

	daemonsetOverrideVal, ok := daemonsetOverrideAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daemonset_override expected to be basetypes.ListValue, was: %T`, daemonsetOverrideAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return nil, diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.MapValue, was: %T`, nodeSelectorAttribute))
	}

	tolerationsAttribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations is missing from object`)

		return nil, diags
	}

	tolerationsVal, ok := tolerationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations expected to be basetypes.ListValue, was: %T`, tolerationsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SystemComponentsPlacementValue{
		DaemonsetOverride: daemonsetOverrideVal,
		NodeSelector:      nodeSelectorVal,
		Tolerations:       tolerationsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSystemComponentsPlacementValueNull() SystemComponentsPlacementValue {
	return SystemComponentsPlacementValue{
		state: attr.ValueStateNull,
	}
}

func NewSystemComponentsPlacementValueUnknown() SystemComponentsPlacementValue {
	return SystemComponentsPlacementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSystemComponentsPlacementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SystemComponentsPlacementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SystemComponentsPlacementValue Attribute Value",
				"While creating a SystemComponentsPlacementValue value, a missing attribute value was detected. "+
					"A SystemComponentsPlacementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SystemComponentsPlacementValue Attribute Type",
				"While creating a SystemComponentsPlacementValue value, an invalid attribute value was detected. "+
					"A SystemComponentsPlacementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SystemComponentsPlacementValue Attribute Value",
				"While creating a SystemComponentsPlacementValue value, an extra attribute value was detected. "+
					"A SystemComponentsPlacementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SystemComponentsPlacementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	daemonsetOverrideAttribute, ok := attributes["daemonset_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daemonset_override is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	daemonsetOverrideVal, ok := daemonsetOverrideAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daemonset_override expected to be basetypes.ListValue, was: %T`, daemonsetOverrideAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.MapValue, was: %T`, nodeSelectorAttribute))
	}

	tolerationsAttribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	tolerationsVal, ok := tolerationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations expected to be basetypes.ListValue, was: %T`, tolerationsAttribute))
	}

	if diags.HasError() {
		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	return SystemComponentsPlacementValue{
		DaemonsetOverride: daemonsetOverrideVal,
		NodeSelector:      nodeSelectorVal,
		Tolerations:       tolerationsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSystemComponentsPlacementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SystemComponentsPlacementValue {
	object, diags := NewSystemComponentsPlacementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSystemComponentsPlacementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SystemComponentsPlacementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSystemComponentsPlacementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSystemComponentsPlacementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSystemComponentsPlacementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSystemComponentsPlacementValueMust(SystemComponentsPlacementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SystemComponentsPlacementType) ValueType(ctx context.Context) attr.Value {
	return SystemComponentsPlacementValue{}
}

var _ basetypes.ObjectValuable = SystemComponentsPlacementValue{}

type SystemComponentsPlacementValue struct {
	DaemonsetOverride basetypes.ListValue `tfsdk:"daemonset_override"`
	NodeSelector      basetypes.MapValue  `tfsdk:"node_selector"`
	Tolerations       basetypes.ListValue `tfsdk:"tolerations"`
	state             attr.ValueState
}

func (v SystemComponentsPlacementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["daemonset_override"] = basetypes.ListType{
		ElemType: DaemonsetOverrideValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_selector"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tolerations"] = basetypes.ListType{
		ElemType: TolerationsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DaemonsetOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daemonset_override"] = val

		val, err = v.NodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selector"] = val

		val, err = v.Tolerations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tolerations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SystemComponentsPlacementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SystemComponentsPlacementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SystemComponentsPlacementValue) String() string {
	return "SystemComponentsPlacementValue"
}

func (v SystemComponentsPlacementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	daemonsetOverride := types.ListValueMust(
		DaemonsetOverrideType{
			basetypes.ObjectType{
				AttrTypes: DaemonsetOverrideValue{}.AttributeTypes(ctx),
			},
		},
		v.DaemonsetOverride.Elements(),
	)

	if v.DaemonsetOverride.IsNull() {
		daemonsetOverride = types.ListNull(
			DaemonsetOverrideType{
				basetypes.ObjectType{
					AttrTypes: DaemonsetOverrideValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DaemonsetOverride.IsUnknown() {
		daemonsetOverride = types.ListUnknown(
			DaemonsetOverrideType{
				basetypes.ObjectType{
					AttrTypes: DaemonsetOverrideValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	tolerations := types.ListValueMust(
		TolerationsType{
			basetypes.ObjectType{
				AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
			},
		},
		v.Tolerations.Elements(),
	)

	if v.Tolerations.IsNull() {
		tolerations = types.ListNull(
			TolerationsType{
				basetypes.ObjectType{
					AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tolerations.IsUnknown() {
		tolerations = types.ListUnknown(
			TolerationsType{
				basetypes.ObjectType{
					AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var nodeSelectorVal basetypes.MapValue
	switch {
	case v.NodeSelector.IsUnknown():
		nodeSelectorVal = types.MapUnknown(types.StringType)
	case v.NodeSelector.IsNull():
		nodeSelectorVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorVal, d = types.MapValue(types.StringType, v.NodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"daemonset_override": basetypes.ListType{
				ElemType: DaemonsetOverrideValue{}.Type(ctx),
			},
			"node_selector": basetypes.MapType{
				ElemType: types.StringType,
			},
			"tolerations": basetypes.ListType{
				ElemType: TolerationsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"daemonset_override": basetypes.ListType{
			ElemType: DaemonsetOverrideValue{}.Type(ctx),
		},
		"node_selector": basetypes.MapType{
			ElemType: types.StringType,
		},
		"tolerations": basetypes.ListType{
			ElemType: TolerationsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"daemonset_override": daemonsetOverride,
			"node_selector":      nodeSelectorVal,
			"tolerations":        tolerations,
		})

	return objVal, diags
}

func (v SystemComponentsPlacementValue) Equal(o attr.Value) bool {
	other, ok := o.(SystemComponentsPlacementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DaemonsetOverride.Equal(other.DaemonsetOverride) {
		return false
	}

	if !v.NodeSelector.Equal(other.NodeSelector) {
		return false
	}

	if !v.Tolerations.Equal(other.Tolerations) {
		return false
	}

	return true
}

func (v SystemComponentsPlacementValue) Type(ctx context.Context) attr.Type {
	return SystemComponentsPlacementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SystemComponentsPlacementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daemonset_override": basetypes.ListType{
			ElemType: DaemonsetOverrideValue{}.Type(ctx),
		},
		"node_selector": basetypes.MapType{
			ElemType: types.StringType,
		},
		"tolerations": basetypes.ListType{
			ElemType: TolerationsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DaemonsetOverrideType{}

type DaemonsetOverrideType struct {
	basetypes.ObjectType
}

func (t DaemonsetOverrideType) Equal(o attr.Type) bool {
	other, ok := o.(DaemonsetOverrideType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DaemonsetOverrideType) String() string {
	return "DaemonsetOverrideType"
}

func (t DaemonsetOverrideType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nodeSelectionEnabledAttribute, ok := attributes["node_selection_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selection_enabled is missing from object`)

		return nil, diags
	}

	nodeSelectionEnabledVal, ok := nodeSelectionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selection_enabled expected to be basetypes.BoolValue, was: %T`, nodeSelectionEnabledAttribute))
	}

	tolerations2Attribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations2 is missing from object`)

		return nil, diags
	}

	tolerations2Val, ok := tolerations2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations2 expected to be basetypes.ListValue, was: %T`, tolerations2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DaemonsetOverrideValue{
		NodeSelectionEnabled: nodeSelectionEnabledVal,
		Tolerations2:         tolerations2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDaemonsetOverrideValueNull() DaemonsetOverrideValue {
	return DaemonsetOverrideValue{
		state: attr.ValueStateNull,
	}
}

func NewDaemonsetOverrideValueUnknown() DaemonsetOverrideValue {
	return DaemonsetOverrideValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDaemonsetOverrideValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DaemonsetOverrideValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DaemonsetOverrideValue Attribute Value",
				"While creating a DaemonsetOverrideValue value, a missing attribute value was detected. "+
					"A DaemonsetOverrideValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DaemonsetOverrideValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DaemonsetOverrideValue Attribute Type",
				"While creating a DaemonsetOverrideValue value, an invalid attribute value was detected. "+
					"A DaemonsetOverrideValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DaemonsetOverrideValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DaemonsetOverrideValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DaemonsetOverrideValue Attribute Value",
				"While creating a DaemonsetOverrideValue value, an extra attribute value was detected. "+
					"A DaemonsetOverrideValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DaemonsetOverrideValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDaemonsetOverrideValueUnknown(), diags
	}

	nodeSelectionEnabledAttribute, ok := attributes["node_selection_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selection_enabled is missing from object`)

		return NewDaemonsetOverrideValueUnknown(), diags
	}

	nodeSelectionEnabledVal, ok := nodeSelectionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selection_enabled expected to be basetypes.BoolValue, was: %T`, nodeSelectionEnabledAttribute))
	}

	tolerations2Attribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations2 is missing from object`)

		return NewDaemonsetOverrideValueUnknown(), diags
	}

	tolerations2Val, ok := tolerations2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations2 expected to be basetypes.ListValue, was: %T`, tolerations2Attribute))
	}

	if diags.HasError() {
		return NewDaemonsetOverrideValueUnknown(), diags
	}

	return DaemonsetOverrideValue{
		NodeSelectionEnabled: nodeSelectionEnabledVal,
		Tolerations2:         tolerations2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDaemonsetOverrideValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DaemonsetOverrideValue {
	object, diags := NewDaemonsetOverrideValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDaemonsetOverrideValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DaemonsetOverrideType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDaemonsetOverrideValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDaemonsetOverrideValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDaemonsetOverrideValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDaemonsetOverrideValueMust(DaemonsetOverrideValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DaemonsetOverrideType) ValueType(ctx context.Context) attr.Value {
	return DaemonsetOverrideValue{}
}

var _ basetypes.ObjectValuable = DaemonsetOverrideValue{}

type DaemonsetOverrideValue struct {
	NodeSelectionEnabled basetypes.BoolValue `tfsdk:"node_selection_enabled"`
	Tolerations2         basetypes.ListValue `tfsdk:"tolerations"`
	state                attr.ValueState
}

func (v DaemonsetOverrideValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["node_selection_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tolerations"] = basetypes.ListType{
		ElemType: Tolerations2Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NodeSelectionEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selection_enabled"] = val

		val, err = v.Tolerations2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tolerations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DaemonsetOverrideValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DaemonsetOverrideValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DaemonsetOverrideValue) String() string {
	return "DaemonsetOverrideValue"
}

func (v DaemonsetOverrideValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	tolerations2 := types.ListValueMust(
		Tolerations2Type{
			basetypes.ObjectType{
				AttrTypes: Tolerations2Value{}.AttributeTypes(ctx),
			},
		},
		v.Tolerations2.Elements(),
	)

	if v.Tolerations2.IsNull() {
		tolerations2 = types.ListNull(
			Tolerations2Type{
				basetypes.ObjectType{
					AttrTypes: Tolerations2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tolerations2.IsUnknown() {
		tolerations2 = types.ListUnknown(
			Tolerations2Type{
				basetypes.ObjectType{
					AttrTypes: Tolerations2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"node_selection_enabled": basetypes.BoolType{},
		"tolerations": basetypes.ListType{
			ElemType: Tolerations2Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"node_selection_enabled": v.NodeSelectionEnabled,
			"tolerations":           tolerations2,
		})

	return objVal, diags
}

func (v DaemonsetOverrideValue) Equal(o attr.Value) bool {
	other, ok := o.(DaemonsetOverrideValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NodeSelectionEnabled.Equal(other.NodeSelectionEnabled) {
		return false
	}

	if !v.Tolerations2.Equal(other.Tolerations2) {
		return false
	}

	return true
}

func (v DaemonsetOverrideValue) Type(ctx context.Context) attr.Type {
	return DaemonsetOverrideType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DaemonsetOverrideValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"node_selection_enabled": basetypes.BoolType{},
		"tolerations": basetypes.ListType{
			ElemType: Tolerations2Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Tolerations2Type{}

type Tolerations2Type struct {
	basetypes.ObjectType
}

func (t Tolerations2Type) Equal(o attr.Type) bool {
	other, ok := o.(Tolerations2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Tolerations2Type) String() string {
	return "Tolerations2Type"
}

func (t Tolerations2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return nil, diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return nil, diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Tolerations2Value{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerations2ValueNull() Tolerations2Value {
	return Tolerations2Value{
		state: attr.ValueStateNull,
	}
}

func NewTolerations2ValueUnknown() Tolerations2Value {
	return Tolerations2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTolerations2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Tolerations2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Tolerations2Value Attribute Value",
				"While creating a Tolerations2Value value, a missing attribute value was detected. "+
					"A Tolerations2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Tolerations2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Tolerations2Value Attribute Type",
				"While creating a Tolerations2Value value, an invalid attribute value was detected. "+
					"A Tolerations2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Tolerations2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Tolerations2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Tolerations2Value Attribute Value",
				"While creating a Tolerations2Value value, an extra attribute value was detected. "+
					"A Tolerations2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Tolerations2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTolerations2ValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTolerations2ValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTolerations2ValueUnknown(), diags
	}

	return Tolerations2Value{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerations2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Tolerations2Value {
	object, diags := NewTolerations2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTolerations2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Tolerations2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTolerations2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTolerations2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTolerations2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTolerations2ValueMust(Tolerations2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Tolerations2Type) ValueType(ctx context.Context) attr.Value {
	return Tolerations2Value{}
}

var _ basetypes.ObjectValuable = Tolerations2Value{}

type Tolerations2Value struct {
	Effect            basetypes.StringValue `tfsdk:"effect"`
	Key               basetypes.StringValue `tfsdk:"key"`
	Operator          basetypes.StringValue `tfsdk:"operator"`
	TolerationSeconds basetypes.Int64Value  `tfsdk:"toleration_seconds"`
	Value             basetypes.StringValue `tfsdk:"value"`
	state             attr.ValueState
}

func (v Tolerations2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["toleration_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Operator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operator"] = val

		val, err = v.TolerationSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["toleration_seconds"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Tolerations2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Tolerations2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Tolerations2Value) String() string {
	return "Tolerations2Value"
}

func (v Tolerations2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect":             v.Effect,
			"key":                v.Key,
			"operator":           v.Operator,
			"toleration_seconds": v.TolerationSeconds,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v Tolerations2Value) Equal(o attr.Value) bool {
	other, ok := o.(Tolerations2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Operator.Equal(other.Operator) {
		return false
	}

	if !v.TolerationSeconds.Equal(other.TolerationSeconds) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v Tolerations2Value) Type(ctx context.Context) attr.Type {
	return Tolerations2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Tolerations2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TolerationsType{}

type TolerationsType struct {
	basetypes.ObjectType
}

func (t TolerationsType) Equal(o attr.Type) bool {
	other, ok := o.(TolerationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TolerationsType) String() string {
	return "TolerationsType"
}

func (t TolerationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return nil, diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return nil, diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TolerationsValue{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerationsValueNull() TolerationsValue {
	return TolerationsValue{
		state: attr.ValueStateNull,
	}
}

func NewTolerationsValueUnknown() TolerationsValue {
	return TolerationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTolerationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TolerationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TolerationsValue Attribute Value",
				"While creating a TolerationsValue value, a missing attribute value was detected. "+
					"A TolerationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TolerationsValue Attribute Type",
				"While creating a TolerationsValue value, an invalid attribute value was detected. "+
					"A TolerationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TolerationsValue Attribute Value",
				"While creating a TolerationsValue value, an extra attribute value was detected. "+
					"A TolerationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TolerationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTolerationsValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTolerationsValueUnknown(), diags
	}

	return TolerationsValue{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TolerationsValue {
	object, diags := NewTolerationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTolerationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TolerationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTolerationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTolerationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTolerationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTolerationsValueMust(TolerationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TolerationsType) ValueType(ctx context.Context) attr.Value {
	return TolerationsValue{}
}

var _ basetypes.ObjectValuable = TolerationsValue{}

type TolerationsValue struct {
	Effect            basetypes.StringValue `tfsdk:"effect"`
	Key               basetypes.StringValue `tfsdk:"key"`
	Operator          basetypes.StringValue `tfsdk:"operator"`
	TolerationSeconds basetypes.Int64Value  `tfsdk:"toleration_seconds"`
	Value             basetypes.StringValue `tfsdk:"value"`
	state             attr.ValueState
}

func (v TolerationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["toleration_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Operator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operator"] = val

		val, err = v.TolerationSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["toleration_seconds"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TolerationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TolerationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TolerationsValue) String() string {
	return "TolerationsValue"
}

func (v TolerationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect":             v.Effect,
			"key":                v.Key,
			"operator":           v.Operator,
			"toleration_seconds": v.TolerationSeconds,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v TolerationsValue) Equal(o attr.Value) bool {
	other, ok := o.(TolerationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Operator.Equal(other.Operator) {
		return false
	}

	if !v.TolerationSeconds.Equal(other.TolerationSeconds) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TolerationsValue) Type(ctx context.Context) attr.Type {
	return TolerationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TolerationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterConfigType{}

type ClusterConfigType struct {
	basetypes.ObjectType
}

func (t ClusterConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterConfigType) String() string {
	return "ClusterConfigType"
}

func (t ClusterConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiversionAttribute, ok := attributes["apiversion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apiversion is missing from object`)

		return nil, diags
	}

	apiversionVal, ok := apiversionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apiversion expected to be basetypes.StringValue, was: %T`, apiversionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadata2Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata2 is missing from object`)

		return nil, diags
	}

	metadata2Val, ok := metadata2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata2 expected to be basetypes.ListValue, was: %T`, metadata2Attribute))
	}

	nodeGroupsAttribute, ok := attributes["node_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups is missing from object`)

		return nil, diags
	}

	nodeGroupsVal, ok := nodeGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups expected to be basetypes.ListValue, was: %T`, nodeGroupsAttribute))
	}

	nodeGroupsMapAttribute, ok := attributes["node_groups_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups_map is missing from object`)

		return nil, diags
	}

	nodeGroupsMapVal, ok := nodeGroupsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups_map expected to be basetypes.MapValue, was: %T`, nodeGroupsMapAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterConfigValue{
		Apiversion:    apiversionVal,
		Kind:          kindVal,
		Metadata2:     metadata2Val,
		NodeGroups:    nodeGroupsVal,
		NodeGroupsMap: nodeGroupsMapVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueNull() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterConfigValueUnknown() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, a missing attribute value was detected. "+
					"A ClusterConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterConfigValue Attribute Type",
				"While creating a ClusterConfigValue value, an invalid attribute value was detected. "+
					"A ClusterConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, an extra attribute value was detected. "+
					"A ClusterConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	apiversionAttribute, ok := attributes["apiversion"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apiversion is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	apiversionVal, ok := apiversionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apiversion expected to be basetypes.StringValue, was: %T`, apiversionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadata2Attribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata2 is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	metadata2Val, ok := metadata2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata2 expected to be basetypes.ListValue, was: %T`, metadata2Attribute))
	}

	nodeGroupsAttribute, ok := attributes["node_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	nodeGroupsVal, ok := nodeGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups expected to be basetypes.ListValue, was: %T`, nodeGroupsAttribute))
	}

	nodeGroupsMapAttribute, ok := attributes["node_groups_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_groups_map is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	nodeGroupsMapVal, ok := nodeGroupsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_groups_map expected to be basetypes.MapValue, was: %T`, nodeGroupsMapAttribute))
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	return ClusterConfigValue{
		Apiversion:    apiversionVal,
		Kind:          kindVal,
		Metadata2:     metadata2Val,
		NodeGroups:    nodeGroupsVal,
		NodeGroupsMap: nodeGroupsMapVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterConfigValue {
	object, diags := NewClusterConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterConfigValueMust(ClusterConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterConfigType) ValueType(ctx context.Context) attr.Value {
	return ClusterConfigValue{}
}

var _ basetypes.ObjectValuable = ClusterConfigValue{}

type ClusterConfigValue struct {
	Apiversion    basetypes.StringValue `tfsdk:"apiversion"`
	Kind          basetypes.StringValue `tfsdk:"kind"`
	Metadata2     basetypes.ListValue   `tfsdk:"metadata"`
	NodeGroups    basetypes.ListValue   `tfsdk:"node_groups"`
	NodeGroupsMap basetypes.MapValue    `tfsdk:"node_groups_map"`
	state         attr.ValueState
}

func (v ClusterConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["apiversion"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: Metadata2Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_groups"] = basetypes.ListType{
		ElemType: NodeGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_groups_map"] = basetypes.MapType{
		ElemType: NodeGroupsMapValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Apiversion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apiversion"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.NodeGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_groups"] = val

		val, err = v.NodeGroupsMap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_groups_map"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterConfigValue) String() string {
	return "ClusterConfigValue"
}

func (v ClusterConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	metadata2 := types.ListValueMust(
		Metadata2Type{
			basetypes.ObjectType{
				AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
			},
		},
		v.Metadata2.Elements(),
	)

	if v.Metadata2.IsNull() {
		metadata2 = types.ListNull(
			Metadata2Type{
				basetypes.ObjectType{
					AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata2.IsUnknown() {
		metadata2 = types.ListUnknown(
			Metadata2Type{
				basetypes.ObjectType{
					AttrTypes: Metadata2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeGroups := types.ListValueMust(
		NodeGroupsType{
			basetypes.ObjectType{
				AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeGroups.Elements(),
	)

	if v.NodeGroups.IsNull() {
		nodeGroups = types.ListNull(
			NodeGroupsType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeGroups.IsUnknown() {
		nodeGroups = types.ListUnknown(
			NodeGroupsType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	nodeGroupsMap := types.MapValueMust(
		NodeGroupsMapType{
			basetypes.ObjectType{
				AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
			},
		},
		v.NodeGroupsMap.Elements(),
	)

	if v.NodeGroupsMap.IsNull() {
		nodeGroupsMap = types.MapNull(
			NodeGroupsMapType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NodeGroupsMap.IsUnknown() {
		nodeGroupsMap = types.MapUnknown(
			NodeGroupsMapType{
				basetypes.ObjectType{
					AttrTypes: NodeGroupsMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"apiversion": basetypes.StringType{},
		"kind":       basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: Metadata2Value{}.Type(ctx),
		},
		"node_groups": basetypes.ListType{
			ElemType: NodeGroupsValue{}.Type(ctx),
		},
		"node_groups_map": basetypes.MapType{
			ElemType: NodeGroupsMapValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"apiversion":      v.Apiversion,
			"kind":            v.Kind,
			"metadata":       metadata2,
			"node_groups":     nodeGroups,
			"node_groups_map": nodeGroupsMap,
		})

	return objVal, diags
}

func (v ClusterConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Apiversion.Equal(other.Apiversion) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata2.Equal(other.Metadata2) {
		return false
	}

	if !v.NodeGroups.Equal(other.NodeGroups) {
		return false
	}

	if !v.NodeGroupsMap.Equal(other.NodeGroupsMap) {
		return false
	}

	return true
}

func (v ClusterConfigValue) Type(ctx context.Context) attr.Type {
	return ClusterConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"apiversion": basetypes.StringType{},
		"kind":       basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: Metadata2Value{}.Type(ctx),
		},
		"node_groups": basetypes.ListType{
			ElemType: NodeGroupsValue{}.Type(ctx),
		},
		"node_groups_map": basetypes.MapType{
			ElemType: NodeGroupsMapValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = NodeGroupsMapType{}

type NodeGroupsMapType struct {
	basetypes.ObjectType
}

func (t NodeGroupsMapType) Equal(o attr.Type) bool {
	other, ok := o.(NodeGroupsMapType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeGroupsMapType) String() string {
	return "NodeGroupsMapType"
}

func (t NodeGroupsMapType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return nil, diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return nil, diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return nil, diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return nil, diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return nil, diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	iam2Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam2 is missing from object`)

		return nil, diags
	}

	iam2Val, ok := iam2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam2 expected to be basetypes.ListValue, was: %T`, iam2Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return nil, diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return nil, diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return nil, diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return nil, diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return nil, diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeGroupsMapValue{
		AmiFamily:         amiFamilyVal,
		DesiredCapacity:   desiredCapacityVal,
		DisableImdsv1:     disableImdsv1Val,
		DisablePodsImds:   disablePodsImdsVal,
		EfaEnabled:        efaEnabledVal,
		Iam2:              iam2Val,
		InstanceType:      instanceTypeVal,
		MaxPodsPerNode:    maxPodsPerNodeVal,
		MaxSize:           maxSizeVal,
		MinSize:           minSizeVal,
		PrivateNetworking: privateNetworkingVal,
		Version:           versionVal,
		VolumeIops:        volumeIopsVal,
		VolumeSize:        volumeSizeVal,
		VolumeThroughput:  volumeThroughputVal,
		VolumeType:        volumeTypeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsMapValueNull() NodeGroupsMapValue {
	return NodeGroupsMapValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeGroupsMapValueUnknown() NodeGroupsMapValue {
	return NodeGroupsMapValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeGroupsMapValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeGroupsMapValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeGroupsMapValue Attribute Value",
				"While creating a NodeGroupsMapValue value, a missing attribute value was detected. "+
					"A NodeGroupsMapValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeGroupsMapValue Attribute Type",
				"While creating a NodeGroupsMapValue value, an invalid attribute value was detected. "+
					"A NodeGroupsMapValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeGroupsMapValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeGroupsMapValue Attribute Value",
				"While creating a NodeGroupsMapValue value, an extra attribute value was detected. "+
					"A NodeGroupsMapValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeGroupsMapValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeGroupsMapValueUnknown(), diags
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	iam2Attribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam2 is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	iam2Val, ok := iam2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam2 expected to be basetypes.ListValue, was: %T`, iam2Attribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewNodeGroupsMapValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewNodeGroupsMapValueUnknown(), diags
	}

	return NodeGroupsMapValue{
		AmiFamily:         amiFamilyVal,
		DesiredCapacity:   desiredCapacityVal,
		DisableImdsv1:     disableImdsv1Val,
		DisablePodsImds:   disablePodsImdsVal,
		EfaEnabled:        efaEnabledVal,
		Iam2:              iam2Val,
		InstanceType:      instanceTypeVal,
		MaxPodsPerNode:    maxPodsPerNodeVal,
		MaxSize:           maxSizeVal,
		MinSize:           minSizeVal,
		PrivateNetworking: privateNetworkingVal,
		Version:           versionVal,
		VolumeIops:        volumeIopsVal,
		VolumeSize:        volumeSizeVal,
		VolumeThroughput:  volumeThroughputVal,
		VolumeType:        volumeTypeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsMapValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeGroupsMapValue {
	object, diags := NewNodeGroupsMapValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeGroupsMapValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeGroupsMapType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeGroupsMapValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeGroupsMapValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeGroupsMapValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeGroupsMapValueMust(NodeGroupsMapValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeGroupsMapType) ValueType(ctx context.Context) attr.Value {
	return NodeGroupsMapValue{}
}

var _ basetypes.ObjectValuable = NodeGroupsMapValue{}

type NodeGroupsMapValue struct {
	AmiFamily         basetypes.StringValue `tfsdk:"ami_family"`
	DesiredCapacity   basetypes.Int64Value  `tfsdk:"desired_capacity"`
	DisableImdsv1     basetypes.BoolValue   `tfsdk:"disable_imdsv1"`
	DisablePodsImds   basetypes.BoolValue   `tfsdk:"disable_pods_imds"`
	EfaEnabled        basetypes.BoolValue   `tfsdk:"efa_enabled"`
	Iam2              basetypes.ListValue   `tfsdk:"iam"`
	InstanceType      basetypes.StringValue `tfsdk:"instance_type"`
	MaxPodsPerNode    basetypes.Int64Value  `tfsdk:"max_pods_per_node"`
	MaxSize           basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize           basetypes.Int64Value  `tfsdk:"min_size"`
	PrivateNetworking basetypes.BoolValue   `tfsdk:"private_networking"`
	Version           basetypes.StringValue `tfsdk:"version"`
	VolumeIops        basetypes.Int64Value  `tfsdk:"volume_iops"`
	VolumeSize        basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeThroughput  basetypes.Int64Value  `tfsdk:"volume_throughput"`
	VolumeType        basetypes.StringValue `tfsdk:"volume_type"`
	state             attr.ValueState
}

func (v NodeGroupsMapValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["ami_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["desired_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_imdsv1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_pods_imds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ListType{
		ElemType: Iam2Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_pods_per_node"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["private_networking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_throughput"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.AmiFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami_family"] = val

		val, err = v.DesiredCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_capacity"] = val

		val, err = v.DisableImdsv1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_imdsv1"] = val

		val, err = v.DisablePodsImds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_pods_imds"] = val

		val, err = v.EfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efa_enabled"] = val

		val, err = v.Iam2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.InstanceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_type"] = val

		val, err = v.MaxPodsPerNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pods_per_node"] = val

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.PrivateNetworking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_networking"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VolumeIops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_iops"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeThroughput.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_throughput"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeGroupsMapValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeGroupsMapValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeGroupsMapValue) String() string {
	return "NodeGroupsMapValue"
}

func (v NodeGroupsMapValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	iam2 := types.ListValueMust(
		Iam2Type{
			basetypes.ObjectType{
				AttrTypes: Iam2Value{}.AttributeTypes(ctx),
			},
		},
		v.Iam2.Elements(),
	)

	if v.Iam2.IsNull() {
		iam2 = types.ListNull(
			Iam2Type{
				basetypes.ObjectType{
					AttrTypes: Iam2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Iam2.IsUnknown() {
		iam2 = types.ListUnknown(
			Iam2Type{
				basetypes.ObjectType{
					AttrTypes: Iam2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"ami_family":        basetypes.StringType{},
		"desired_capacity":  basetypes.Int64Type{},
		"disable_imdsv1":    basetypes.BoolType{},
		"disable_pods_imds": basetypes.BoolType{},
		"efa_enabled":       basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: Iam2Value{}.Type(ctx),
		},
		"instance_type":      basetypes.StringType{},
		"max_pods_per_node":  basetypes.Int64Type{},
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"private_networking": basetypes.BoolType{},
		"version":            basetypes.StringType{},
		"volume_iops":        basetypes.Int64Type{},
		"volume_size":        basetypes.Int64Type{},
		"volume_throughput":  basetypes.Int64Type{},
		"volume_type":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ami_family":         v.AmiFamily,
			"desired_capacity":   v.DesiredCapacity,
			"disable_imdsv1":     v.DisableImdsv1,
			"disable_pods_imds":  v.DisablePodsImds,
			"efa_enabled":        v.EfaEnabled,
			"iam":               iam2,
			"instance_type":      v.InstanceType,
			"max_pods_per_node":  v.MaxPodsPerNode,
			"max_size":           v.MaxSize,
			"min_size":           v.MinSize,
			"private_networking": v.PrivateNetworking,
			"version":            v.Version,
			"volume_iops":        v.VolumeIops,
			"volume_size":        v.VolumeSize,
			"volume_throughput":  v.VolumeThroughput,
			"volume_type":        v.VolumeType,
		})

	return objVal, diags
}

func (v NodeGroupsMapValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeGroupsMapValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmiFamily.Equal(other.AmiFamily) {
		return false
	}

	if !v.DesiredCapacity.Equal(other.DesiredCapacity) {
		return false
	}

	if !v.DisableImdsv1.Equal(other.DisableImdsv1) {
		return false
	}

	if !v.DisablePodsImds.Equal(other.DisablePodsImds) {
		return false
	}

	if !v.EfaEnabled.Equal(other.EfaEnabled) {
		return false
	}

	if !v.Iam2.Equal(other.Iam2) {
		return false
	}

	if !v.InstanceType.Equal(other.InstanceType) {
		return false
	}

	if !v.MaxPodsPerNode.Equal(other.MaxPodsPerNode) {
		return false
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.PrivateNetworking.Equal(other.PrivateNetworking) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VolumeIops.Equal(other.VolumeIops) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeThroughput.Equal(other.VolumeThroughput) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v NodeGroupsMapValue) Type(ctx context.Context) attr.Type {
	return NodeGroupsMapType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeGroupsMapValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami_family":        basetypes.StringType{},
		"desired_capacity":  basetypes.Int64Type{},
		"disable_imdsv1":    basetypes.BoolType{},
		"disable_pods_imds": basetypes.BoolType{},
		"efa_enabled":       basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: Iam2Value{}.Type(ctx),
		},
		"instance_type":      basetypes.StringType{},
		"max_pods_per_node":  basetypes.Int64Type{},
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"private_networking": basetypes.BoolType{},
		"version":            basetypes.StringType{},
		"volume_iops":        basetypes.Int64Type{},
		"volume_size":        basetypes.Int64Type{},
		"volume_throughput":  basetypes.Int64Type{},
		"volume_type":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Iam2Type{}

type Iam2Type struct {
	basetypes.ObjectType
}

func (t Iam2Type) Equal(o attr.Type) bool {
	other, ok := o.(Iam2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Iam2Type) String() string {
	return "Iam2Type"
}

func (t Iam2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	iamNodeGroupWithAddonPolicies2Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies2 is missing from object`)

		return nil, diags
	}

	iamNodeGroupWithAddonPolicies2Val, ok := iamNodeGroupWithAddonPolicies2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies2 expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPolicies2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Iam2Value{
		IamNodeGroupWithAddonPolicies2: iamNodeGroupWithAddonPolicies2Val,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam2ValueNull() Iam2Value {
	return Iam2Value{
		state: attr.ValueStateNull,
	}
}

func NewIam2ValueUnknown() Iam2Value {
	return Iam2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIam2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Iam2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Iam2Value Attribute Value",
				"While creating a Iam2Value value, a missing attribute value was detected. "+
					"A Iam2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Iam2Value Attribute Type",
				"While creating a Iam2Value value, an invalid attribute value was detected. "+
					"A Iam2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Iam2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Iam2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Iam2Value Attribute Value",
				"While creating a Iam2Value value, an extra attribute value was detected. "+
					"A Iam2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Iam2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIam2ValueUnknown(), diags
	}

	iamNodeGroupWithAddonPolicies2Attribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies2 is missing from object`)

		return NewIam2ValueUnknown(), diags
	}

	iamNodeGroupWithAddonPolicies2Val, ok := iamNodeGroupWithAddonPolicies2Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies2 expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPolicies2Attribute))
	}

	if diags.HasError() {
		return NewIam2ValueUnknown(), diags
	}

	return Iam2Value{
		IamNodeGroupWithAddonPolicies2: iamNodeGroupWithAddonPolicies2Val,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewIam2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Iam2Value {
	object, diags := NewIam2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIam2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Iam2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIam2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIam2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIam2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIam2ValueMust(Iam2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Iam2Type) ValueType(ctx context.Context) attr.Value {
	return Iam2Value{}
}

var _ basetypes.ObjectValuable = Iam2Value{}

type Iam2Value struct {
	IamNodeGroupWithAddonPolicies2 basetypes.ListValue `tfsdk:"iam_node_group_with_addon_policies"`
	state                          attr.ValueState
}

func (v Iam2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["iam_node_group_with_addon_policies"] = basetypes.ListType{
		ElemType: IamNodeGroupWithAddonPolicies2Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.IamNodeGroupWithAddonPolicies2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_node_group_with_addon_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Iam2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Iam2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Iam2Value) String() string {
	return "Iam2Value"
}

func (v Iam2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	iamNodeGroupWithAddonPolicies2 := types.ListValueMust(
		IamNodeGroupWithAddonPolicies2Type{
			basetypes.ObjectType{
				AttrTypes: IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx),
			},
		},
		v.IamNodeGroupWithAddonPolicies2.Elements(),
	)

	if v.IamNodeGroupWithAddonPolicies2.IsNull() {
		iamNodeGroupWithAddonPolicies2 = types.ListNull(
			IamNodeGroupWithAddonPolicies2Type{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IamNodeGroupWithAddonPolicies2.IsUnknown() {
		iamNodeGroupWithAddonPolicies2 = types.ListUnknown(
			IamNodeGroupWithAddonPolicies2Type{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPolicies2Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"iam_node_group_with_addon_policies": iamNodeGroupWithAddonPolicies2,
		})

	return objVal, diags
}

func (v Iam2Value) Equal(o attr.Value) bool {
	other, ok := o.(Iam2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IamNodeGroupWithAddonPolicies2.Equal(other.IamNodeGroupWithAddonPolicies2) {
		return false
	}

	return true
}

func (v Iam2Value) Type(ctx context.Context) attr.Type {
	return Iam2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Iam2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPolicies2Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = IamNodeGroupWithAddonPolicies2Type{}

type IamNodeGroupWithAddonPolicies2Type struct {
	basetypes.ObjectType
}

func (t IamNodeGroupWithAddonPolicies2Type) Equal(o attr.Type) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamNodeGroupWithAddonPolicies2Type) String() string {
	return "IamNodeGroupWithAddonPolicies2Type"
}

func (t IamNodeGroupWithAddonPolicies2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return nil, diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return nil, diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return nil, diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return nil, diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return nil, diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return nil, diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return nil, diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamNodeGroupWithAddonPolicies2Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies2ValueNull() IamNodeGroupWithAddonPolicies2Value {
	return IamNodeGroupWithAddonPolicies2Value{
		state: attr.ValueStateNull,
	}
}

func NewIamNodeGroupWithAddonPolicies2ValueUnknown() IamNodeGroupWithAddonPolicies2Value {
	return IamNodeGroupWithAddonPolicies2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIamNodeGroupWithAddonPolicies2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamNodeGroupWithAddonPolicies2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamNodeGroupWithAddonPolicies2Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies2Value value, a missing attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamNodeGroupWithAddonPolicies2Value Attribute Type",
				"While creating a IamNodeGroupWithAddonPolicies2Value value, an invalid attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamNodeGroupWithAddonPolicies2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamNodeGroupWithAddonPolicies2Value Attribute Value",
				"While creating a IamNodeGroupWithAddonPolicies2Value value, an extra attribute value was detected. "+
					"A IamNodeGroupWithAddonPolicies2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamNodeGroupWithAddonPolicies2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), diags
	}

	return IamNodeGroupWithAddonPolicies2Value{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPolicies2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamNodeGroupWithAddonPolicies2Value {
	object, diags := NewIamNodeGroupWithAddonPolicies2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamNodeGroupWithAddonPolicies2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamNodeGroupWithAddonPolicies2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamNodeGroupWithAddonPolicies2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamNodeGroupWithAddonPolicies2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamNodeGroupWithAddonPolicies2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamNodeGroupWithAddonPolicies2ValueMust(IamNodeGroupWithAddonPolicies2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t IamNodeGroupWithAddonPolicies2Type) ValueType(ctx context.Context) attr.Value {
	return IamNodeGroupWithAddonPolicies2Value{}
}

var _ basetypes.ObjectValuable = IamNodeGroupWithAddonPolicies2Value{}

type IamNodeGroupWithAddonPolicies2Value struct {
	AlbIngress    basetypes.BoolValue `tfsdk:"alb_ingress"`
	AppMesh       basetypes.BoolValue `tfsdk:"app_mesh"`
	AppMeshReview basetypes.BoolValue `tfsdk:"app_mesh_review"`
	AutoScaler    basetypes.BoolValue `tfsdk:"auto_scaler"`
	CertManager   basetypes.BoolValue `tfsdk:"cert_manager"`
	CloudWatch    basetypes.BoolValue `tfsdk:"cloud_watch"`
	Ebs           basetypes.BoolValue `tfsdk:"ebs"`
	Efs           basetypes.BoolValue `tfsdk:"efs"`
	ExternalDns   basetypes.BoolValue `tfsdk:"external_dns"`
	Fsx           basetypes.BoolValue `tfsdk:"fsx"`
	ImageBuilder  basetypes.BoolValue `tfsdk:"image_builder"`
	Xray          basetypes.BoolValue `tfsdk:"xray"`
	state         attr.ValueState
}

func (v IamNodeGroupWithAddonPolicies2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alb_ingress"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh_review"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fsx"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xray"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AlbIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alb_ingress"] = val

		val, err = v.AppMesh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh"] = val

		val, err = v.AppMeshReview.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh_review"] = val

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.Ebs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs"] = val

		val, err = v.Efs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.Fsx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fsx"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		val, err = v.Xray.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xray"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamNodeGroupWithAddonPolicies2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamNodeGroupWithAddonPolicies2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamNodeGroupWithAddonPolicies2Value) String() string {
	return "IamNodeGroupWithAddonPolicies2Value"
}

func (v IamNodeGroupWithAddonPolicies2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alb_ingress":     v.AlbIngress,
			"app_mesh":        v.AppMesh,
			"app_mesh_review": v.AppMeshReview,
			"auto_scaler":     v.AutoScaler,
			"cert_manager":    v.CertManager,
			"cloud_watch":     v.CloudWatch,
			"ebs":             v.Ebs,
			"efs":             v.Efs,
			"external_dns":    v.ExternalDns,
			"fsx":             v.Fsx,
			"image_builder":   v.ImageBuilder,
			"xray":            v.Xray,
		})

	return objVal, diags
}

func (v IamNodeGroupWithAddonPolicies2Value) Equal(o attr.Value) bool {
	other, ok := o.(IamNodeGroupWithAddonPolicies2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlbIngress.Equal(other.AlbIngress) {
		return false
	}

	if !v.AppMesh.Equal(other.AppMesh) {
		return false
	}

	if !v.AppMeshReview.Equal(other.AppMeshReview) {
		return false
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.Ebs.Equal(other.Ebs) {
		return false
	}

	if !v.Efs.Equal(other.Efs) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.Fsx.Equal(other.Fsx) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	if !v.Xray.Equal(other.Xray) {
		return false
	}

	return true
}

func (v IamNodeGroupWithAddonPolicies2Value) Type(ctx context.Context) attr.Type {
	return IamNodeGroupWithAddonPolicies2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamNodeGroupWithAddonPolicies2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Metadata2Type{}

type Metadata2Type struct {
	basetypes.ObjectType
}

func (t Metadata2Type) Equal(o attr.Type) bool {
	other, ok := o.(Metadata2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Metadata2Type) String() string {
	return "Metadata2Type"
}

func (t Metadata2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Metadata2Value{
		Name:    nameVal,
		Region:  regionVal,
		Tags:    tagsVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadata2ValueNull() Metadata2Value {
	return Metadata2Value{
		state: attr.ValueStateNull,
	}
}

func NewMetadata2ValueUnknown() Metadata2Value {
	return Metadata2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadata2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Metadata2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Metadata2Value Attribute Value",
				"While creating a Metadata2Value value, a missing attribute value was detected. "+
					"A Metadata2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Metadata2Value Attribute Type",
				"While creating a Metadata2Value value, an invalid attribute value was detected. "+
					"A Metadata2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Metadata2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Metadata2Value Attribute Value",
				"While creating a Metadata2Value value, an extra attribute value was detected. "+
					"A Metadata2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Metadata2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadata2ValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.MapValue, was: %T`, tagsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewMetadata2ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewMetadata2ValueUnknown(), diags
	}

	return Metadata2Value{
		Name:    nameVal,
		Region:  regionVal,
		Tags:    tagsVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMetadata2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Metadata2Value {
	object, diags := NewMetadata2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadata2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Metadata2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadata2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadata2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadata2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadata2ValueMust(Metadata2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Metadata2Type) ValueType(ctx context.Context) attr.Value {
	return Metadata2Value{}
}

var _ basetypes.ObjectValuable = Metadata2Value{}

type Metadata2Value struct {
	Name    basetypes.StringValue `tfsdk:"name"`
	Region  basetypes.StringValue `tfsdk:"region"`
	Tags    basetypes.MapValue    `tfsdk:"tags"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v Metadata2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Metadata2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Metadata2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Metadata2Value) String() string {
	return "Metadata2Value"
}

func (v Metadata2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.MapValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.MapUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.MapValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"name":   basetypes.StringType{},
			"region": basetypes.StringType{},
			"tags": basetypes.MapType{
				ElemType: types.StringType,
			},
			"version": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"region": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":    v.Name,
			"region":  v.Region,
			"tags":    tagsVal,
			"version": v.Version,
		})

	return objVal, diags
}

func (v Metadata2Value) Equal(o attr.Value) bool {
	other, ok := o.(Metadata2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v Metadata2Value) Type(ctx context.Context) attr.Type {
	return Metadata2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Metadata2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"region": basetypes.StringType{},
		"tags": basetypes.MapType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodeGroupsType{}

type NodeGroupsType struct {
	basetypes.ObjectType
}

func (t NodeGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(NodeGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodeGroupsType) String() string {
	return "NodeGroupsType"
}

func (t NodeGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return nil, diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return nil, diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return nil, diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return nil, diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return nil, diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	iamAttribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam is missing from object`)

		return nil, diags
	}

	iamVal, ok := iamAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam expected to be basetypes.ListValue, was: %T`, iamAttribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return nil, diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return nil, diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return nil, diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return nil, diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return nil, diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return nil, diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return nil, diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return nil, diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodeGroupsValue{
		AmiFamily:         amiFamilyVal,
		DesiredCapacity:   desiredCapacityVal,
		DisableImdsv1:     disableImdsv1Val,
		DisablePodsImds:   disablePodsImdsVal,
		EfaEnabled:        efaEnabledVal,
		Iam:               iamVal,
		InstanceType:      instanceTypeVal,
		MaxPodsPerNode:    maxPodsPerNodeVal,
		MaxSize:           maxSizeVal,
		MinSize:           minSizeVal,
		Name:              nameVal,
		PrivateNetworking: privateNetworkingVal,
		Version:           versionVal,
		VolumeIops:        volumeIopsVal,
		VolumeSize:        volumeSizeVal,
		VolumeThroughput:  volumeThroughputVal,
		VolumeType:        volumeTypeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsValueNull() NodeGroupsValue {
	return NodeGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewNodeGroupsValueUnknown() NodeGroupsValue {
	return NodeGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodeGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodeGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodeGroupsValue Attribute Value",
				"While creating a NodeGroupsValue value, a missing attribute value was detected. "+
					"A NodeGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodeGroupsValue Attribute Type",
				"While creating a NodeGroupsValue value, an invalid attribute value was detected. "+
					"A NodeGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodeGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodeGroupsValue Attribute Value",
				"While creating a NodeGroupsValue value, an extra attribute value was detected. "+
					"A NodeGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodeGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodeGroupsValueUnknown(), diags
	}

	amiFamilyAttribute, ok := attributes["ami_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ami_family is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	amiFamilyVal, ok := amiFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ami_family expected to be basetypes.StringValue, was: %T`, amiFamilyAttribute))
	}

	desiredCapacityAttribute, ok := attributes["desired_capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_capacity is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	desiredCapacityVal, ok := desiredCapacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_capacity expected to be basetypes.Int64Value, was: %T`, desiredCapacityAttribute))
	}

	disableImdsv1Attribute, ok := attributes["disable_imdsv1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_imdsv1 is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	disableImdsv1Val, ok := disableImdsv1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_imdsv1 expected to be basetypes.BoolValue, was: %T`, disableImdsv1Attribute))
	}

	disablePodsImdsAttribute, ok := attributes["disable_pods_imds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_pods_imds is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	disablePodsImdsVal, ok := disablePodsImdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_pods_imds expected to be basetypes.BoolValue, was: %T`, disablePodsImdsAttribute))
	}

	efaEnabledAttribute, ok := attributes["efa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efa_enabled is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	efaEnabledVal, ok := efaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efa_enabled expected to be basetypes.BoolValue, was: %T`, efaEnabledAttribute))
	}

	iamAttribute, ok := attributes["iam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	iamVal, ok := iamAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam expected to be basetypes.ListValue, was: %T`, iamAttribute))
	}

	instanceTypeAttribute, ok := attributes["instance_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_type is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	instanceTypeVal, ok := instanceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_type expected to be basetypes.StringValue, was: %T`, instanceTypeAttribute))
	}

	maxPodsPerNodeAttribute, ok := attributes["max_pods_per_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pods_per_node is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	maxPodsPerNodeVal, ok := maxPodsPerNodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pods_per_node expected to be basetypes.Int64Value, was: %T`, maxPodsPerNodeAttribute))
	}

	maxSizeAttribute, ok := attributes["max_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	maxSizeVal, ok := maxSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_size expected to be basetypes.Int64Value, was: %T`, maxSizeAttribute))
	}

	minSizeAttribute, ok := attributes["min_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	minSizeVal, ok := minSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_size expected to be basetypes.Int64Value, was: %T`, minSizeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	privateNetworkingAttribute, ok := attributes["private_networking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_networking is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	privateNetworkingVal, ok := privateNetworkingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_networking expected to be basetypes.BoolValue, was: %T`, privateNetworkingAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	volumeIopsAttribute, ok := attributes["volume_iops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_iops is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeIopsVal, ok := volumeIopsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_iops expected to be basetypes.Int64Value, was: %T`, volumeIopsAttribute))
	}

	volumeSizeAttribute, ok := attributes["volume_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_size is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeSizeVal, ok := volumeSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_size expected to be basetypes.Int64Value, was: %T`, volumeSizeAttribute))
	}

	volumeThroughputAttribute, ok := attributes["volume_throughput"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_throughput is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeThroughputVal, ok := volumeThroughputAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_throughput expected to be basetypes.Int64Value, was: %T`, volumeThroughputAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewNodeGroupsValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewNodeGroupsValueUnknown(), diags
	}

	return NodeGroupsValue{
		AmiFamily:         amiFamilyVal,
		DesiredCapacity:   desiredCapacityVal,
		DisableImdsv1:     disableImdsv1Val,
		DisablePodsImds:   disablePodsImdsVal,
		EfaEnabled:        efaEnabledVal,
		Iam:               iamVal,
		InstanceType:      instanceTypeVal,
		MaxPodsPerNode:    maxPodsPerNodeVal,
		MaxSize:           maxSizeVal,
		MinSize:           minSizeVal,
		Name:              nameVal,
		PrivateNetworking: privateNetworkingVal,
		Version:           versionVal,
		VolumeIops:        volumeIopsVal,
		VolumeSize:        volumeSizeVal,
		VolumeThroughput:  volumeThroughputVal,
		VolumeType:        volumeTypeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNodeGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodeGroupsValue {
	object, diags := NewNodeGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodeGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodeGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodeGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodeGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodeGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodeGroupsValueMust(NodeGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodeGroupsType) ValueType(ctx context.Context) attr.Value {
	return NodeGroupsValue{}
}

var _ basetypes.ObjectValuable = NodeGroupsValue{}

type NodeGroupsValue struct {
	AmiFamily         basetypes.StringValue `tfsdk:"ami_family"`
	DesiredCapacity   basetypes.Int64Value  `tfsdk:"desired_capacity"`
	DisableImdsv1     basetypes.BoolValue   `tfsdk:"disable_imdsv1"`
	DisablePodsImds   basetypes.BoolValue   `tfsdk:"disable_pods_imds"`
	EfaEnabled        basetypes.BoolValue   `tfsdk:"efa_enabled"`
	Iam               basetypes.ListValue   `tfsdk:"iam"`
	InstanceType      basetypes.StringValue `tfsdk:"instance_type"`
	MaxPodsPerNode    basetypes.Int64Value  `tfsdk:"max_pods_per_node"`
	MaxSize           basetypes.Int64Value  `tfsdk:"max_size"`
	MinSize           basetypes.Int64Value  `tfsdk:"min_size"`
	Name              basetypes.StringValue `tfsdk:"name"`
	PrivateNetworking basetypes.BoolValue   `tfsdk:"private_networking"`
	Version           basetypes.StringValue `tfsdk:"version"`
	VolumeIops        basetypes.Int64Value  `tfsdk:"volume_iops"`
	VolumeSize        basetypes.Int64Value  `tfsdk:"volume_size"`
	VolumeThroughput  basetypes.Int64Value  `tfsdk:"volume_throughput"`
	VolumeType        basetypes.StringValue `tfsdk:"volume_type"`
	state             attr.ValueState
}

func (v NodeGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["ami_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["desired_capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_imdsv1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_pods_imds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["iam"] = basetypes.ListType{
		ElemType: IamValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_pods_per_node"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_networking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_iops"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_throughput"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.AmiFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ami_family"] = val

		val, err = v.DesiredCapacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_capacity"] = val

		val, err = v.DisableImdsv1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_imdsv1"] = val

		val, err = v.DisablePodsImds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_pods_imds"] = val

		val, err = v.EfaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efa_enabled"] = val

		val, err = v.Iam.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam"] = val

		val, err = v.InstanceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_type"] = val

		val, err = v.MaxPodsPerNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pods_per_node"] = val

		val, err = v.MaxSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_size"] = val

		val, err = v.MinSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_size"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PrivateNetworking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_networking"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VolumeIops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_iops"] = val

		val, err = v.VolumeSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_size"] = val

		val, err = v.VolumeThroughput.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_throughput"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodeGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodeGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodeGroupsValue) String() string {
	return "NodeGroupsValue"
}

func (v NodeGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	iam := types.ListValueMust(
		IamType{
			basetypes.ObjectType{
				AttrTypes: IamValue{}.AttributeTypes(ctx),
			},
		},
		v.Iam.Elements(),
	)

	if v.Iam.IsNull() {
		iam = types.ListNull(
			IamType{
				basetypes.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Iam.IsUnknown() {
		iam = types.ListUnknown(
			IamType{
				basetypes.ObjectType{
					AttrTypes: IamValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"ami_family":        basetypes.StringType{},
		"desired_capacity":  basetypes.Int64Type{},
		"disable_imdsv1":    basetypes.BoolType{},
		"disable_pods_imds": basetypes.BoolType{},
		"efa_enabled":       basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: IamValue{}.Type(ctx),
		},
		"instance_type":      basetypes.StringType{},
		"max_pods_per_node":  basetypes.Int64Type{},
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"name":               basetypes.StringType{},
		"private_networking": basetypes.BoolType{},
		"version":            basetypes.StringType{},
		"volume_iops":        basetypes.Int64Type{},
		"volume_size":        basetypes.Int64Type{},
		"volume_throughput":  basetypes.Int64Type{},
		"volume_type":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ami_family":         v.AmiFamily,
			"desired_capacity":   v.DesiredCapacity,
			"disable_imdsv1":     v.DisableImdsv1,
			"disable_pods_imds":  v.DisablePodsImds,
			"efa_enabled":        v.EfaEnabled,
			"iam":                iam,
			"instance_type":      v.InstanceType,
			"max_pods_per_node":  v.MaxPodsPerNode,
			"max_size":           v.MaxSize,
			"min_size":           v.MinSize,
			"name":               v.Name,
			"private_networking": v.PrivateNetworking,
			"version":            v.Version,
			"volume_iops":        v.VolumeIops,
			"volume_size":        v.VolumeSize,
			"volume_throughput":  v.VolumeThroughput,
			"volume_type":        v.VolumeType,
		})

	return objVal, diags
}

func (v NodeGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(NodeGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmiFamily.Equal(other.AmiFamily) {
		return false
	}

	if !v.DesiredCapacity.Equal(other.DesiredCapacity) {
		return false
	}

	if !v.DisableImdsv1.Equal(other.DisableImdsv1) {
		return false
	}

	if !v.DisablePodsImds.Equal(other.DisablePodsImds) {
		return false
	}

	if !v.EfaEnabled.Equal(other.EfaEnabled) {
		return false
	}

	if !v.Iam.Equal(other.Iam) {
		return false
	}

	if !v.InstanceType.Equal(other.InstanceType) {
		return false
	}

	if !v.MaxPodsPerNode.Equal(other.MaxPodsPerNode) {
		return false
	}

	if !v.MaxSize.Equal(other.MaxSize) {
		return false
	}

	if !v.MinSize.Equal(other.MinSize) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PrivateNetworking.Equal(other.PrivateNetworking) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VolumeIops.Equal(other.VolumeIops) {
		return false
	}

	if !v.VolumeSize.Equal(other.VolumeSize) {
		return false
	}

	if !v.VolumeThroughput.Equal(other.VolumeThroughput) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v NodeGroupsValue) Type(ctx context.Context) attr.Type {
	return NodeGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodeGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ami_family":        basetypes.StringType{},
		"desired_capacity":  basetypes.Int64Type{},
		"disable_imdsv1":    basetypes.BoolType{},
		"disable_pods_imds": basetypes.BoolType{},
		"efa_enabled":       basetypes.BoolType{},
		"iam": basetypes.ListType{
			ElemType: IamValue{}.Type(ctx),
		},
		"instance_type":      basetypes.StringType{},
		"max_pods_per_node":  basetypes.Int64Type{},
		"max_size":           basetypes.Int64Type{},
		"min_size":           basetypes.Int64Type{},
		"name":               basetypes.StringType{},
		"private_networking": basetypes.BoolType{},
		"version":            basetypes.StringType{},
		"volume_iops":        basetypes.Int64Type{},
		"volume_size":        basetypes.Int64Type{},
		"volume_throughput":  basetypes.Int64Type{},
		"volume_type":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IamType{}

type IamType struct {
	basetypes.ObjectType
}

func (t IamType) Equal(o attr.Type) bool {
	other, ok := o.(IamType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamType) String() string {
	return "IamType"
}

func (t IamType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	iamNodeGroupWithAddonPoliciesAttribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies is missing from object`)

		return nil, diags
	}

	iamNodeGroupWithAddonPoliciesVal, ok := iamNodeGroupWithAddonPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPoliciesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamValue{
		IamNodeGroupWithAddonPolicies: iamNodeGroupWithAddonPoliciesVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewIamValueNull() IamValue {
	return IamValue{
		state: attr.ValueStateNull,
	}
}

func NewIamValueUnknown() IamValue {
	return IamValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIamValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamValue Attribute Value",
				"While creating a IamValue value, a missing attribute value was detected. "+
					"A IamValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamValue Attribute Type",
				"While creating a IamValue value, an invalid attribute value was detected. "+
					"A IamValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamValue Attribute Value",
				"While creating a IamValue value, an extra attribute value was detected. "+
					"A IamValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamValueUnknown(), diags
	}

	iamNodeGroupWithAddonPoliciesAttribute, ok := attributes["iam_node_group_with_addon_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iam_node_group_with_addon_policies is missing from object`)

		return NewIamValueUnknown(), diags
	}

	iamNodeGroupWithAddonPoliciesVal, ok := iamNodeGroupWithAddonPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iam_node_group_with_addon_policies expected to be basetypes.ListValue, was: %T`, iamNodeGroupWithAddonPoliciesAttribute))
	}

	if diags.HasError() {
		return NewIamValueUnknown(), diags
	}

	return IamValue{
		IamNodeGroupWithAddonPolicies: iamNodeGroupWithAddonPoliciesVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewIamValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamValue {
	object, diags := NewIamValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamValueMust(IamValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IamType) ValueType(ctx context.Context) attr.Value {
	return IamValue{}
}

var _ basetypes.ObjectValuable = IamValue{}

type IamValue struct {
	IamNodeGroupWithAddonPolicies basetypes.ListValue `tfsdk:"iam_node_group_with_addon_policies"`
	state                         attr.ValueState
}

func (v IamValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["iam_node_group_with_addon_policies"] = basetypes.ListType{
		ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.IamNodeGroupWithAddonPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iam_node_group_with_addon_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamValue) String() string {
	return "IamValue"
}

func (v IamValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	iamNodeGroupWithAddonPolicies := types.ListValueMust(
		IamNodeGroupWithAddonPoliciesType{
			basetypes.ObjectType{
				AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.IamNodeGroupWithAddonPolicies.Elements(),
	)

	if v.IamNodeGroupWithAddonPolicies.IsNull() {
		iamNodeGroupWithAddonPolicies = types.ListNull(
			IamNodeGroupWithAddonPoliciesType{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IamNodeGroupWithAddonPolicies.IsUnknown() {
		iamNodeGroupWithAddonPolicies = types.ListUnknown(
			IamNodeGroupWithAddonPoliciesType{
				basetypes.ObjectType{
					AttrTypes: IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"iam_node_group_with_addon_policies": iamNodeGroupWithAddonPolicies,
		})

	return objVal, diags
}

func (v IamValue) Equal(o attr.Value) bool {
	other, ok := o.(IamValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IamNodeGroupWithAddonPolicies.Equal(other.IamNodeGroupWithAddonPolicies) {
		return false
	}

	return true
}

func (v IamValue) Type(ctx context.Context) attr.Type {
	return IamType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"iam_node_group_with_addon_policies": basetypes.ListType{
			ElemType: IamNodeGroupWithAddonPoliciesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = IamNodeGroupWithAddonPoliciesType{}

type IamNodeGroupWithAddonPoliciesType struct {
	basetypes.ObjectType
}

func (t IamNodeGroupWithAddonPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(IamNodeGroupWithAddonPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IamNodeGroupWithAddonPoliciesType) String() string {
	return "IamNodeGroupWithAddonPoliciesType"
}

func (t IamNodeGroupWithAddonPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return nil, diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return nil, diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return nil, diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return nil, diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return nil, diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return nil, diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return nil, diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return nil, diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return nil, diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return nil, diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return nil, diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return nil, diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IamNodeGroupWithAddonPoliciesValue{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPoliciesValueNull() IamNodeGroupWithAddonPoliciesValue {
	return IamNodeGroupWithAddonPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewIamNodeGroupWithAddonPoliciesValueUnknown() IamNodeGroupWithAddonPoliciesValue {
	return IamNodeGroupWithAddonPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIamNodeGroupWithAddonPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IamNodeGroupWithAddonPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IamNodeGroupWithAddonPoliciesValue Attribute Value",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, a missing attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IamNodeGroupWithAddonPoliciesValue Attribute Type",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, an invalid attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IamNodeGroupWithAddonPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IamNodeGroupWithAddonPoliciesValue Attribute Value",
				"While creating a IamNodeGroupWithAddonPoliciesValue value, an extra attribute value was detected. "+
					"A IamNodeGroupWithAddonPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IamNodeGroupWithAddonPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	albIngressAttribute, ok := attributes["alb_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alb_ingress is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	albIngressVal, ok := albIngressAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alb_ingress expected to be basetypes.BoolValue, was: %T`, albIngressAttribute))
	}

	appMeshAttribute, ok := attributes["app_mesh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	appMeshVal, ok := appMeshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh expected to be basetypes.BoolValue, was: %T`, appMeshAttribute))
	}

	appMeshReviewAttribute, ok := attributes["app_mesh_review"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_mesh_review is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	appMeshReviewVal, ok := appMeshReviewAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_mesh_review expected to be basetypes.BoolValue, was: %T`, appMeshReviewAttribute))
	}

	autoScalerAttribute, ok := attributes["auto_scaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scaler is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	autoScalerVal, ok := autoScalerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scaler expected to be basetypes.BoolValue, was: %T`, autoScalerAttribute))
	}

	certManagerAttribute, ok := attributes["cert_manager"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_manager is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	certManagerVal, ok := certManagerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_manager expected to be basetypes.BoolValue, was: %T`, certManagerAttribute))
	}

	cloudWatchAttribute, ok := attributes["cloud_watch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_watch is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	cloudWatchVal, ok := cloudWatchAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_watch expected to be basetypes.BoolValue, was: %T`, cloudWatchAttribute))
	}

	ebsAttribute, ok := attributes["ebs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebs is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	ebsVal, ok := ebsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebs expected to be basetypes.BoolValue, was: %T`, ebsAttribute))
	}

	efsAttribute, ok := attributes["efs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`efs is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	efsVal, ok := efsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`efs expected to be basetypes.BoolValue, was: %T`, efsAttribute))
	}

	externalDnsAttribute, ok := attributes["external_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_dns is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	externalDnsVal, ok := externalDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_dns expected to be basetypes.BoolValue, was: %T`, externalDnsAttribute))
	}

	fsxAttribute, ok := attributes["fsx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fsx is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	fsxVal, ok := fsxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fsx expected to be basetypes.BoolValue, was: %T`, fsxAttribute))
	}

	imageBuilderAttribute, ok := attributes["image_builder"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_builder is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	imageBuilderVal, ok := imageBuilderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_builder expected to be basetypes.BoolValue, was: %T`, imageBuilderAttribute))
	}

	xrayAttribute, ok := attributes["xray"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xray is missing from object`)

		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	xrayVal, ok := xrayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xray expected to be basetypes.BoolValue, was: %T`, xrayAttribute))
	}

	if diags.HasError() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), diags
	}

	return IamNodeGroupWithAddonPoliciesValue{
		AlbIngress:    albIngressVal,
		AppMesh:       appMeshVal,
		AppMeshReview: appMeshReviewVal,
		AutoScaler:    autoScalerVal,
		CertManager:   certManagerVal,
		CloudWatch:    cloudWatchVal,
		Ebs:           ebsVal,
		Efs:           efsVal,
		ExternalDns:   externalDnsVal,
		Fsx:           fsxVal,
		ImageBuilder:  imageBuilderVal,
		Xray:          xrayVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIamNodeGroupWithAddonPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IamNodeGroupWithAddonPoliciesValue {
	object, diags := NewIamNodeGroupWithAddonPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIamNodeGroupWithAddonPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IamNodeGroupWithAddonPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIamNodeGroupWithAddonPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIamNodeGroupWithAddonPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIamNodeGroupWithAddonPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIamNodeGroupWithAddonPoliciesValueMust(IamNodeGroupWithAddonPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IamNodeGroupWithAddonPoliciesType) ValueType(ctx context.Context) attr.Value {
	return IamNodeGroupWithAddonPoliciesValue{}
}

var _ basetypes.ObjectValuable = IamNodeGroupWithAddonPoliciesValue{}

type IamNodeGroupWithAddonPoliciesValue struct {
	AlbIngress    basetypes.BoolValue `tfsdk:"alb_ingress"`
	AppMesh       basetypes.BoolValue `tfsdk:"app_mesh"`
	AppMeshReview basetypes.BoolValue `tfsdk:"app_mesh_review"`
	AutoScaler    basetypes.BoolValue `tfsdk:"auto_scaler"`
	CertManager   basetypes.BoolValue `tfsdk:"cert_manager"`
	CloudWatch    basetypes.BoolValue `tfsdk:"cloud_watch"`
	Ebs           basetypes.BoolValue `tfsdk:"ebs"`
	Efs           basetypes.BoolValue `tfsdk:"efs"`
	ExternalDns   basetypes.BoolValue `tfsdk:"external_dns"`
	Fsx           basetypes.BoolValue `tfsdk:"fsx"`
	ImageBuilder  basetypes.BoolValue `tfsdk:"image_builder"`
	Xray          basetypes.BoolValue `tfsdk:"xray"`
	state         attr.ValueState
}

func (v IamNodeGroupWithAddonPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alb_ingress"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["app_mesh_review"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_scaler"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cert_manager"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cloud_watch"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ebs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["efs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["external_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fsx"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image_builder"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xray"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AlbIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alb_ingress"] = val

		val, err = v.AppMesh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh"] = val

		val, err = v.AppMeshReview.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_mesh_review"] = val

		val, err = v.AutoScaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scaler"] = val

		val, err = v.CertManager.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_manager"] = val

		val, err = v.CloudWatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_watch"] = val

		val, err = v.Ebs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebs"] = val

		val, err = v.Efs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["efs"] = val

		val, err = v.ExternalDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_dns"] = val

		val, err = v.Fsx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fsx"] = val

		val, err = v.ImageBuilder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_builder"] = val

		val, err = v.Xray.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xray"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IamNodeGroupWithAddonPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IamNodeGroupWithAddonPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IamNodeGroupWithAddonPoliciesValue) String() string {
	return "IamNodeGroupWithAddonPoliciesValue"
}

func (v IamNodeGroupWithAddonPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alb_ingress":     v.AlbIngress,
			"app_mesh":        v.AppMesh,
			"app_mesh_review": v.AppMeshReview,
			"auto_scaler":     v.AutoScaler,
			"cert_manager":    v.CertManager,
			"cloud_watch":     v.CloudWatch,
			"ebs":             v.Ebs,
			"efs":             v.Efs,
			"external_dns":    v.ExternalDns,
			"fsx":             v.Fsx,
			"image_builder":   v.ImageBuilder,
			"xray":            v.Xray,
		})

	return objVal, diags
}

func (v IamNodeGroupWithAddonPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(IamNodeGroupWithAddonPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlbIngress.Equal(other.AlbIngress) {
		return false
	}

	if !v.AppMesh.Equal(other.AppMesh) {
		return false
	}

	if !v.AppMeshReview.Equal(other.AppMeshReview) {
		return false
	}

	if !v.AutoScaler.Equal(other.AutoScaler) {
		return false
	}

	if !v.CertManager.Equal(other.CertManager) {
		return false
	}

	if !v.CloudWatch.Equal(other.CloudWatch) {
		return false
	}

	if !v.Ebs.Equal(other.Ebs) {
		return false
	}

	if !v.Efs.Equal(other.Efs) {
		return false
	}

	if !v.ExternalDns.Equal(other.ExternalDns) {
		return false
	}

	if !v.Fsx.Equal(other.Fsx) {
		return false
	}

	if !v.ImageBuilder.Equal(other.ImageBuilder) {
		return false
	}

	if !v.Xray.Equal(other.Xray) {
		return false
	}

	return true
}

func (v IamNodeGroupWithAddonPoliciesValue) Type(ctx context.Context) attr.Type {
	return IamNodeGroupWithAddonPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IamNodeGroupWithAddonPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alb_ingress":     basetypes.BoolType{},
		"app_mesh":        basetypes.BoolType{},
		"app_mesh_review": basetypes.BoolType{},
		"auto_scaler":     basetypes.BoolType{},
		"cert_manager":    basetypes.BoolType{},
		"cloud_watch":     basetypes.BoolType{},
		"ebs":             basetypes.BoolType{},
		"efs":             basetypes.BoolType{},
		"external_dns":    basetypes.BoolType{},
		"fsx":             basetypes.BoolType{},
		"image_builder":   basetypes.BoolType{},
		"xray":            basetypes.BoolType{},
	}
}
