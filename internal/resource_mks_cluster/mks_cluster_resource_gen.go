// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_mks_cluster

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func MksClusterResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "api version",
				MarkdownDescription: "api version",
				Default:             stringdefault.StaticString("infra.k8smgmt.io/v3"),
			},
			"kind": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "kind",
				MarkdownDescription: "kind",
				Default:             stringdefault.StaticString("Cluster"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "annotations of the resource",
						MarkdownDescription: "annotations of the resource",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Description:         "description of the resource",
						MarkdownDescription: "description of the resource",
					},
					"labels": schema.MapAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "labels of the resource",
						MarkdownDescription: "labels of the resource",
					},
					"name": schema.StringAttribute{
						Required:            true,
						Description:         "name of the resource",
						MarkdownDescription: "name of the resource",
					},
					"project": schema.StringAttribute{
						Required:            true,
						Description:         "Project of the resource",
						MarkdownDescription: "Project of the resource",
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "metadata of the resource",
				MarkdownDescription: "metadata of the resource",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"blueprint": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								Required: true,
							},
							"version": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Version of the blueprint",
								MarkdownDescription: "Version of the blueprint",
								Default:             stringdefault.StaticString("latest"),
							},
						},
						CustomType: BlueprintType{
							ObjectType: types.ObjectType{
								AttrTypes: BlueprintValue{}.AttributeTypes(ctx),
							},
						},
						Required: true,
					},
					"cloud_credentials": schema.StringAttribute{
						Optional:            true,
						Description:         "The credentials to be used to ssh into the  Clusster Nodes",
						MarkdownDescription: "The credentials to be used to ssh into the  Clusster Nodes",
					},
					"config": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"auto_approve_nodes": schema.BoolAttribute{
								Optional:            true,
								Description:         "Auto approves incoming nodes by default",
								MarkdownDescription: "Auto approves incoming nodes by default",
							},
							"cluster_ssh": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"passphrase": schema.StringAttribute{
										Optional:            true,
										Description:         "Provide ssh passphrase",
										MarkdownDescription: "Provide ssh passphrase",
									},
									"port": schema.StringAttribute{
										Optional:            true,
										Description:         "Provide ssh port",
										MarkdownDescription: "Provide ssh port",
									},
									"private_key_path": schema.StringAttribute{
										Optional:            true,
										Description:         "Provide local path to the private key",
										MarkdownDescription: "Provide local path to the private key",
									},
									"username": schema.StringAttribute{
										Optional:            true,
										Description:         "Provide the ssh username",
										MarkdownDescription: "Provide the ssh username",
									},
								},
								CustomType: ClusterSshType{
									ObjectType: types.ObjectType{
										AttrTypes: ClusterSshValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "SSH config for all the nodes within the cluster",
								MarkdownDescription: "SSH config for all the nodes within the cluster",
							},
							"dedicated_control_plane": schema.BoolAttribute{
								Optional:            true,
								Description:         "Select this option for preventing scheduling of user workloads on Control Plane nodes",
								MarkdownDescription: "Select this option for preventing scheduling of user workloads on Control Plane nodes",
							},
							"high_availability": schema.BoolAttribute{
								Optional:            true,
								Description:         "Select this option for highly available control plane. Minimum three control plane nodes are required",
								MarkdownDescription: "Select this option for highly available control plane. Minimum three control plane nodes are required",
							},
							"installer_ttl": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Installer TTL Configuration",
								MarkdownDescription: "Installer TTL Configuration",
								Default:             int64default.StaticInt64(365),
							},
							"kubelet_extra_args": schema.MapAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "cluster kubelet extra args",
								MarkdownDescription: "cluster kubelet extra args",
							},
							"kubernetes_upgrade": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"params": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"worker_concurrency": schema.StringAttribute{
												Required:            true,
												Description:         "It can be number or percentage",
												MarkdownDescription: "It can be number or percentage",
											},
										},
										CustomType: ParamsType{
											ObjectType: types.ObjectType{
												AttrTypes: ParamsValue{}.AttributeTypes(ctx),
											},
										},
										Required: true,
									},
									"strategy": schema.StringAttribute{
										Required:            true,
										Description:         "Kubernetes upgrade strategy for worker nodes and Valid options are: concurrent/sequential",
										MarkdownDescription: "Kubernetes upgrade strategy for worker nodes and Valid options are: concurrent/sequential",
									},
								},
								CustomType: KubernetesUpgradeType{
									ObjectType: types.ObjectType{
										AttrTypes: KubernetesUpgradeValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"kubernetes_version": schema.StringAttribute{
								Required:            true,
								Description:         "Kubernetes version of the Control Plane",
								MarkdownDescription: "Kubernetes version of the Control Plane",
							},
							"location": schema.StringAttribute{
								Optional:            true,
								Description:         "The data center location where the cluster nodes will be launched",
								MarkdownDescription: "The data center location where the cluster nodes will be launched",
							},
							"network": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"cni": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Required:            true,
												Description:         "Provide the CNI name, e.g., Calico or Cilium",
												MarkdownDescription: "Provide the CNI name, e.g., Calico or Cilium",
											},
											"version": schema.StringAttribute{
												Optional:            true,
												Description:         "Provide the CNI version, e.g., 3.26.1",
												MarkdownDescription: "Provide the CNI version, e.g., 3.26.1",
											},
										},
										CustomType: CniType{
											ObjectType: types.ObjectType{
												AttrTypes: CniValue{}.AttributeTypes(ctx),
											},
										},
										Required:            true,
										Description:         "MKS Cluster CNI Specification",
										MarkdownDescription: "MKS Cluster CNI Specification",
									},
									"ipv6": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"pod_subnet": schema.StringAttribute{
												Optional:            true,
												Description:         "Kubernetes pod subnet",
												MarkdownDescription: "Kubernetes pod subnet",
											},
											"service_subnet": schema.StringAttribute{
												Optional:            true,
												Description:         "Kubernetes service subnet",
												MarkdownDescription: "Kubernetes service subnet",
											},
										},
										CustomType: Ipv6Type{
											ObjectType: types.ObjectType{
												AttrTypes: Ipv6Value{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"pod_subnet": schema.StringAttribute{
										Required:            true,
										Description:         "Kubernetes pod subnet",
										MarkdownDescription: "Kubernetes pod subnet",
									},
									"service_subnet": schema.StringAttribute{
										Required:            true,
										Description:         "Kubernetes service subnet",
										MarkdownDescription: "Kubernetes service subnet",
									},
								},
								CustomType: NetworkType{
									ObjectType: types.ObjectType{
										AttrTypes: NetworkValue{}.AttributeTypes(ctx),
									},
								},
								Required:            true,
								Description:         "MKS Cluster Network Specification",
								MarkdownDescription: "MKS Cluster Network Specification",
							},
							"nodes": schema.MapNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"arch": schema.StringAttribute{
											Required:            true,
											Description:         "System Architecture of the node",
											MarkdownDescription: "System Architecture of the node",
										},
										"hostname": schema.StringAttribute{
											Required:            true,
											Description:         "Hostname of the node",
											MarkdownDescription: "Hostname of the node",
										},
										"interface": schema.StringAttribute{
											Optional:            true,
											Description:         "Interface to be used on the node",
											MarkdownDescription: "Interface to be used on the node",
										},
										"kubelet_extra_args": schema.MapAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "node kubelet extra args",
											MarkdownDescription: "node kubelet extra args",
										},
										"labels": schema.MapAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "labels to be added to the node",
											MarkdownDescription: "labels to be added to the node",
										},
										"operating_system": schema.StringAttribute{
											Required:            true,
											Description:         "OS of the node",
											MarkdownDescription: "OS of the node",
										},
										"private_ip": schema.StringAttribute{
											Required:            true,
											Description:         "Private ip address of the node",
											MarkdownDescription: "Private ip address of the node",
										},
										"roles": schema.SetAttribute{
											ElementType:         types.StringType,
											Required:            true,
											Description:         "Valid roles are: 'ControlPlane', 'Worker', 'Storage'",
											MarkdownDescription: "Valid roles are: 'ControlPlane', 'Worker', 'Storage'",
										},
										"ssh": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"ip_address": schema.StringAttribute{
													Optional:            true,
													Description:         "Use this to override node level ssh details",
													MarkdownDescription: "Use this to override node level ssh details",
												},
												"passphrase": schema.StringAttribute{
													Optional:            true,
													Description:         "SSH Passphrase",
													MarkdownDescription: "SSH Passphrase",
												},
												"port": schema.StringAttribute{
													Optional:            true,
													Description:         "SSH Port",
													MarkdownDescription: "SSH Port",
												},
												"private_key_path": schema.StringAttribute{
													Optional:            true,
													Description:         "Specify Path to SSH private key",
													MarkdownDescription: "Specify Path to SSH private key",
												},
												"username": schema.StringAttribute{
													Optional:            true,
													Description:         "SSH Username",
													MarkdownDescription: "SSH Username",
												},
											},
											CustomType: SshType{
												ObjectType: types.ObjectType{
													AttrTypes: SshValue{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "MKS Node SSH definition",
											MarkdownDescription: "MKS Node SSH definition",
										},
										"taints": schema.SetNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"effect": schema.StringAttribute{
														Required: true,
													},
													"key": schema.StringAttribute{
														Required: true,
													},
													"value": schema.StringAttribute{
														Optional: true,
													},
												},
												CustomType: TaintsType{
													ObjectType: types.ObjectType{
														AttrTypes: TaintsValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Description:         "taints to be added to the node",
											MarkdownDescription: "taints to be added to the node",
										},
									},
									CustomType: NodesType{
										ObjectType: types.ObjectType{
											AttrTypes: NodesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Required:            true,
								Description:         "holds node configuration for the cluster",
								MarkdownDescription: "holds node configuration for the cluster",
							},
							"platform_version": schema.StringAttribute{
								Required:            true,
								Description:         "Platform version configuration",
								MarkdownDescription: "Platform version configuration",
							},
						},
						CustomType: ConfigType{
							ObjectType: types.ObjectType{
								AttrTypes: ConfigValue{}.AttributeTypes(ctx),
							},
						},
						Required:            true,
						Description:         "MKS V3 cluster specification",
						MarkdownDescription: "MKS V3 cluster specification",
					},
					"proxy": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_insecure_bootstrap": schema.BoolAttribute{
								Optional: true,
							},
							"bootstrap_ca": schema.StringAttribute{
								Optional: true,
							},
							"enabled": schema.BoolAttribute{
								Required: true,
							},
							"http_proxy": schema.StringAttribute{
								Required: true,
							},
							"https_proxy": schema.StringAttribute{
								Optional: true,
							},
							"no_proxy": schema.StringAttribute{
								Optional: true,
							},
							"proxy_auth": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: ProxyType{
							ObjectType: types.ObjectType{
								AttrTypes: ProxyValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"sharing": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Required: true,
							},
							"projects": schema.SetNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
									},
									CustomType: ProjectsType{
										ObjectType: types.ObjectType{
											AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Required: true,
							},
						},
						CustomType: SharingType{
							ObjectType: types.ObjectType{
								AttrTypes: SharingValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"system_components_placement": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"daemon_set_override": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"daemon_set_tolerations": schema.SetNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"effect": schema.StringAttribute{
													Optional: true,
												},
												"key": schema.StringAttribute{
													Optional: true,
												},
												"operator": schema.StringAttribute{
													Optional: true,
												},
												"toleration_seconds": schema.Int64Attribute{
													Optional: true,
												},
												"value": schema.StringAttribute{
													Optional: true,
												},
											},
											CustomType: DaemonSetTolerationsType{
												ObjectType: types.ObjectType{
													AttrTypes: DaemonSetTolerationsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
									"node_selection_enabled": schema.BoolAttribute{
										Optional: true,
									},
								},
								CustomType: DaemonSetOverrideType{
									ObjectType: types.ObjectType{
										AttrTypes: DaemonSetOverrideValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"node_selector": schema.MapAttribute{
								ElementType: types.StringType,
								Optional:    true,
							},
							"tolerations": schema.SetNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"effect": schema.StringAttribute{
											Optional: true,
										},
										"key": schema.StringAttribute{
											Optional: true,
										},
										"operator": schema.StringAttribute{
											Optional: true,
										},
										"toleration_seconds": schema.Int64Attribute{
											Optional: true,
										},
										"value": schema.StringAttribute{
											Optional: true,
										},
									},
									CustomType: TolerationsType{
										ObjectType: types.ObjectType{
											AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
						},
						CustomType: SystemComponentsPlacementType{
							ObjectType: types.ObjectType{
								AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The type of the cluster this spec corresponds to",
						MarkdownDescription: "The type of the cluster this spec corresponds to",
						Default:             stringdefault.StaticString("mks"),
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "cluster specification",
				MarkdownDescription: "cluster specification",
			},
		},
	}
}

type MksClusterModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Spec       SpecValue     `tfsdk:"spec"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Description: descriptionVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Project:     projectVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Description: descriptionVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Project:     projectVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Description basetypes.StringValue `tfsdk:"description"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Project     basetypes.StringValue `tfsdk:"project"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"description": basetypes.StringType{},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":    basetypes.StringType{},
			"project": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"description": basetypes.StringType{},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":    basetypes.StringType{},
			"project": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"description": basetypes.StringType{},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":    basetypes.StringType{},
		"project": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"description": v.Description,
			"labels":      labelsVal,
			"name":        v.Name,
			"project":     v.Project,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"description": basetypes.StringType{},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":    basetypes.StringType{},
		"project": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return nil, diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.ObjectValue, was: %T`, blueprintAttribute))
	}

	cloudCredentialsAttribute, ok := attributes["cloud_credentials"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_credentials is missing from object`)

		return nil, diags
	}

	cloudCredentialsVal, ok := cloudCredentialsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_credentials expected to be basetypes.StringValue, was: %T`, cloudCredentialsAttribute))
	}

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return nil, diags
	}

	configVal, ok := configAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.ObjectValue, was: %T`, configAttribute))
	}

	proxyAttribute, ok := attributes["proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy is missing from object`)

		return nil, diags
	}

	proxyVal, ok := proxyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy expected to be basetypes.ObjectValue, was: %T`, proxyAttribute))
	}

	sharingAttribute, ok := attributes["sharing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sharing is missing from object`)

		return nil, diags
	}

	sharingVal, ok := sharingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sharing expected to be basetypes.ObjectValue, was: %T`, sharingAttribute))
	}

	systemComponentsPlacementAttribute, ok := attributes["system_components_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_components_placement is missing from object`)

		return nil, diags
	}

	systemComponentsPlacementVal, ok := systemComponentsPlacementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_components_placement expected to be basetypes.ObjectValue, was: %T`, systemComponentsPlacementAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Blueprint:                 blueprintVal,
		CloudCredentials:          cloudCredentialsVal,
		Config:                    configVal,
		Proxy:                     proxyVal,
		Sharing:                   sharingVal,
		SystemComponentsPlacement: systemComponentsPlacementVal,
		SpecType:                  typeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	blueprintAttribute, ok := attributes["blueprint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blueprint is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	blueprintVal, ok := blueprintAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blueprint expected to be basetypes.ObjectValue, was: %T`, blueprintAttribute))
	}

	cloudCredentialsAttribute, ok := attributes["cloud_credentials"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cloud_credentials is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	cloudCredentialsVal, ok := cloudCredentialsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cloud_credentials expected to be basetypes.StringValue, was: %T`, cloudCredentialsAttribute))
	}

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	configVal, ok := configAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.ObjectValue, was: %T`, configAttribute))
	}

	proxyAttribute, ok := attributes["proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	proxyVal, ok := proxyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy expected to be basetypes.ObjectValue, was: %T`, proxyAttribute))
	}

	sharingAttribute, ok := attributes["sharing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sharing is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	sharingVal, ok := sharingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sharing expected to be basetypes.ObjectValue, was: %T`, sharingAttribute))
	}

	systemComponentsPlacementAttribute, ok := attributes["system_components_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_components_placement is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	systemComponentsPlacementVal, ok := systemComponentsPlacementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_components_placement expected to be basetypes.ObjectValue, was: %T`, systemComponentsPlacementAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Blueprint:                 blueprintVal,
		CloudCredentials:          cloudCredentialsVal,
		Config:                    configVal,
		Proxy:                     proxyVal,
		Sharing:                   sharingVal,
		SystemComponentsPlacement: systemComponentsPlacementVal,
		SpecType:                  typeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Blueprint                 basetypes.ObjectValue `tfsdk:"blueprint"`
	CloudCredentials          basetypes.StringValue `tfsdk:"cloud_credentials"`
	Config                    basetypes.ObjectValue `tfsdk:"config"`
	Proxy                     basetypes.ObjectValue `tfsdk:"proxy"`
	Sharing                   basetypes.ObjectValue `tfsdk:"sharing"`
	SystemComponentsPlacement basetypes.ObjectValue `tfsdk:"system_components_placement"`
	SpecType                  basetypes.StringValue `tfsdk:"type"`
	state                     attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["blueprint"] = basetypes.ObjectType{
		AttrTypes: BlueprintValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cloud_credentials"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["config"] = basetypes.ObjectType{
		AttrTypes: ConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["proxy"] = basetypes.ObjectType{
		AttrTypes: ProxyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["sharing"] = basetypes.ObjectType{
		AttrTypes: SharingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["system_components_placement"] = basetypes.ObjectType{
		AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Blueprint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blueprint"] = val

		val, err = v.CloudCredentials.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cloud_credentials"] = val

		val, err = v.Config.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config"] = val

		val, err = v.Proxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy"] = val

		val, err = v.Sharing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sharing"] = val

		val, err = v.SystemComponentsPlacement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_components_placement"] = val

		val, err = v.SpecType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var blueprint basetypes.ObjectValue

	if v.Blueprint.IsNull() {
		blueprint = types.ObjectNull(
			BlueprintValue{}.AttributeTypes(ctx),
		)
	}

	if v.Blueprint.IsUnknown() {
		blueprint = types.ObjectUnknown(
			BlueprintValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Blueprint.IsNull() && !v.Blueprint.IsUnknown() {
		blueprint = types.ObjectValueMust(
			BlueprintValue{}.AttributeTypes(ctx),
			v.Blueprint.Attributes(),
		)
	}

	var config basetypes.ObjectValue

	if v.Config.IsNull() {
		config = types.ObjectNull(
			ConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.Config.IsUnknown() {
		config = types.ObjectUnknown(
			ConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Config.IsNull() && !v.Config.IsUnknown() {
		config = types.ObjectValueMust(
			ConfigValue{}.AttributeTypes(ctx),
			v.Config.Attributes(),
		)
	}

	var proxy basetypes.ObjectValue

	if v.Proxy.IsNull() {
		proxy = types.ObjectNull(
			ProxyValue{}.AttributeTypes(ctx),
		)
	}

	if v.Proxy.IsUnknown() {
		proxy = types.ObjectUnknown(
			ProxyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Proxy.IsNull() && !v.Proxy.IsUnknown() {
		proxy = types.ObjectValueMust(
			ProxyValue{}.AttributeTypes(ctx),
			v.Proxy.Attributes(),
		)
	}

	var sharing basetypes.ObjectValue

	if v.Sharing.IsNull() {
		sharing = types.ObjectNull(
			SharingValue{}.AttributeTypes(ctx),
		)
	}

	if v.Sharing.IsUnknown() {
		sharing = types.ObjectUnknown(
			SharingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Sharing.IsNull() && !v.Sharing.IsUnknown() {
		sharing = types.ObjectValueMust(
			SharingValue{}.AttributeTypes(ctx),
			v.Sharing.Attributes(),
		)
	}

	var systemComponentsPlacement basetypes.ObjectValue

	if v.SystemComponentsPlacement.IsNull() {
		systemComponentsPlacement = types.ObjectNull(
			SystemComponentsPlacementValue{}.AttributeTypes(ctx),
		)
	}

	if v.SystemComponentsPlacement.IsUnknown() {
		systemComponentsPlacement = types.ObjectUnknown(
			SystemComponentsPlacementValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SystemComponentsPlacement.IsNull() && !v.SystemComponentsPlacement.IsUnknown() {
		systemComponentsPlacement = types.ObjectValueMust(
			SystemComponentsPlacementValue{}.AttributeTypes(ctx),
			v.SystemComponentsPlacement.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"blueprint": basetypes.ObjectType{
			AttrTypes: BlueprintValue{}.AttributeTypes(ctx),
		},
		"cloud_credentials": basetypes.StringType{},
		"config": basetypes.ObjectType{
			AttrTypes: ConfigValue{}.AttributeTypes(ctx),
		},
		"proxy": basetypes.ObjectType{
			AttrTypes: ProxyValue{}.AttributeTypes(ctx),
		},
		"sharing": basetypes.ObjectType{
			AttrTypes: SharingValue{}.AttributeTypes(ctx),
		},
		"system_components_placement": basetypes.ObjectType{
			AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"blueprint":                   blueprint,
			"cloud_credentials":           v.CloudCredentials,
			"config":                      config,
			"proxy":                       proxy,
			"sharing":                     sharing,
			"system_components_placement": systemComponentsPlacement,
			"type":                        v.SpecType,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Blueprint.Equal(other.Blueprint) {
		return false
	}

	if !v.CloudCredentials.Equal(other.CloudCredentials) {
		return false
	}

	if !v.Config.Equal(other.Config) {
		return false
	}

	if !v.Proxy.Equal(other.Proxy) {
		return false
	}

	if !v.Sharing.Equal(other.Sharing) {
		return false
	}

	if !v.SystemComponentsPlacement.Equal(other.SystemComponentsPlacement) {
		return false
	}

	if !v.SpecType.Equal(other.SpecType) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"blueprint": basetypes.ObjectType{
			AttrTypes: BlueprintValue{}.AttributeTypes(ctx),
		},
		"cloud_credentials": basetypes.StringType{},
		"config": basetypes.ObjectType{
			AttrTypes: ConfigValue{}.AttributeTypes(ctx),
		},
		"proxy": basetypes.ObjectType{
			AttrTypes: ProxyValue{}.AttributeTypes(ctx),
		},
		"sharing": basetypes.ObjectType{
			AttrTypes: SharingValue{}.AttributeTypes(ctx),
		},
		"system_components_placement": basetypes.ObjectType{
			AttrTypes: SystemComponentsPlacementValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BlueprintType{}

type BlueprintType struct {
	basetypes.ObjectType
}

func (t BlueprintType) Equal(o attr.Type) bool {
	other, ok := o.(BlueprintType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BlueprintType) String() string {
	return "BlueprintType"
}

func (t BlueprintType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BlueprintValue{
		Name:    nameVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewBlueprintValueNull() BlueprintValue {
	return BlueprintValue{
		state: attr.ValueStateNull,
	}
}

func NewBlueprintValueUnknown() BlueprintValue {
	return BlueprintValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBlueprintValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BlueprintValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BlueprintValue Attribute Value",
				"While creating a BlueprintValue value, a missing attribute value was detected. "+
					"A BlueprintValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlueprintValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BlueprintValue Attribute Type",
				"While creating a BlueprintValue value, an invalid attribute value was detected. "+
					"A BlueprintValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BlueprintValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BlueprintValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BlueprintValue Attribute Value",
				"While creating a BlueprintValue value, an extra attribute value was detected. "+
					"A BlueprintValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BlueprintValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBlueprintValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBlueprintValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewBlueprintValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewBlueprintValueUnknown(), diags
	}

	return BlueprintValue{
		Name:    nameVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewBlueprintValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BlueprintValue {
	object, diags := NewBlueprintValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBlueprintValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BlueprintType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBlueprintValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBlueprintValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBlueprintValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBlueprintValueMust(BlueprintValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BlueprintType) ValueType(ctx context.Context) attr.Value {
	return BlueprintValue{}
}

var _ basetypes.ObjectValuable = BlueprintValue{}

type BlueprintValue struct {
	Name    basetypes.StringValue `tfsdk:"name"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v BlueprintValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BlueprintValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BlueprintValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BlueprintValue) String() string {
	return "BlueprintValue"
}

func (v BlueprintValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":    v.Name,
			"version": v.Version,
		})

	return objVal, diags
}

func (v BlueprintValue) Equal(o attr.Value) bool {
	other, ok := o.(BlueprintValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v BlueprintValue) Type(ctx context.Context) attr.Type {
	return BlueprintType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BlueprintValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigType{}

type ConfigType struct {
	basetypes.ObjectType
}

func (t ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigType) String() string {
	return "ConfigType"
}

func (t ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoApproveNodesAttribute, ok := attributes["auto_approve_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_nodes is missing from object`)

		return nil, diags
	}

	autoApproveNodesVal, ok := autoApproveNodesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_nodes expected to be basetypes.BoolValue, was: %T`, autoApproveNodesAttribute))
	}

	clusterSshAttribute, ok := attributes["cluster_ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_ssh is missing from object`)

		return nil, diags
	}

	clusterSshVal, ok := clusterSshAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_ssh expected to be basetypes.ObjectValue, was: %T`, clusterSshAttribute))
	}

	dedicatedControlPlaneAttribute, ok := attributes["dedicated_control_plane"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dedicated_control_plane is missing from object`)

		return nil, diags
	}

	dedicatedControlPlaneVal, ok := dedicatedControlPlaneAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dedicated_control_plane expected to be basetypes.BoolValue, was: %T`, dedicatedControlPlaneAttribute))
	}

	highAvailabilityAttribute, ok := attributes["high_availability"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`high_availability is missing from object`)

		return nil, diags
	}

	highAvailabilityVal, ok := highAvailabilityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`high_availability expected to be basetypes.BoolValue, was: %T`, highAvailabilityAttribute))
	}

	installerTtlAttribute, ok := attributes["installer_ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installer_ttl is missing from object`)

		return nil, diags
	}

	installerTtlVal, ok := installerTtlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installer_ttl expected to be basetypes.Int64Value, was: %T`, installerTtlAttribute))
	}

	kubeletExtraArgsAttribute, ok := attributes["kubelet_extra_args"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubelet_extra_args is missing from object`)

		return nil, diags
	}

	kubeletExtraArgsVal, ok := kubeletExtraArgsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubelet_extra_args expected to be basetypes.MapValue, was: %T`, kubeletExtraArgsAttribute))
	}

	kubernetesUpgradeAttribute, ok := attributes["kubernetes_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_upgrade is missing from object`)

		return nil, diags
	}

	kubernetesUpgradeVal, ok := kubernetesUpgradeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_upgrade expected to be basetypes.ObjectValue, was: %T`, kubernetesUpgradeAttribute))
	}

	kubernetesVersionAttribute, ok := attributes["kubernetes_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_version is missing from object`)

		return nil, diags
	}

	kubernetesVersionVal, ok := kubernetesVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_version expected to be basetypes.StringValue, was: %T`, kubernetesVersionAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return nil, diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.ObjectValue, was: %T`, networkAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.MapValue, was: %T`, nodesAttribute))
	}

	platformVersionAttribute, ok := attributes["platform_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform_version is missing from object`)

		return nil, diags
	}

	platformVersionVal, ok := platformVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform_version expected to be basetypes.StringValue, was: %T`, platformVersionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigValue{
		AutoApproveNodes:      autoApproveNodesVal,
		ClusterSsh:            clusterSshVal,
		DedicatedControlPlane: dedicatedControlPlaneVal,
		HighAvailability:      highAvailabilityVal,
		InstallerTtl:          installerTtlVal,
		KubeletExtraArgs:      kubeletExtraArgsVal,
		KubernetesUpgrade:     kubernetesUpgradeVal,
		KubernetesVersion:     kubernetesVersionVal,
		Location:              locationVal,
		Network:               networkVal,
		Nodes:                 nodesVal,
		PlatformVersion:       platformVersionVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewConfigValueNull() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigValueUnknown() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigValue Attribute Value",
				"While creating a ConfigValue value, a missing attribute value was detected. "+
					"A ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigValue Attribute Type",
				"While creating a ConfigValue value, an invalid attribute value was detected. "+
					"A ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigValue Attribute Value",
				"While creating a ConfigValue value, an extra attribute value was detected. "+
					"A ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	autoApproveNodesAttribute, ok := attributes["auto_approve_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_nodes is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	autoApproveNodesVal, ok := autoApproveNodesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_nodes expected to be basetypes.BoolValue, was: %T`, autoApproveNodesAttribute))
	}

	clusterSshAttribute, ok := attributes["cluster_ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_ssh is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	clusterSshVal, ok := clusterSshAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_ssh expected to be basetypes.ObjectValue, was: %T`, clusterSshAttribute))
	}

	dedicatedControlPlaneAttribute, ok := attributes["dedicated_control_plane"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dedicated_control_plane is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dedicatedControlPlaneVal, ok := dedicatedControlPlaneAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dedicated_control_plane expected to be basetypes.BoolValue, was: %T`, dedicatedControlPlaneAttribute))
	}

	highAvailabilityAttribute, ok := attributes["high_availability"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`high_availability is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	highAvailabilityVal, ok := highAvailabilityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`high_availability expected to be basetypes.BoolValue, was: %T`, highAvailabilityAttribute))
	}

	installerTtlAttribute, ok := attributes["installer_ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`installer_ttl is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	installerTtlVal, ok := installerTtlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`installer_ttl expected to be basetypes.Int64Value, was: %T`, installerTtlAttribute))
	}

	kubeletExtraArgsAttribute, ok := attributes["kubelet_extra_args"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubelet_extra_args is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	kubeletExtraArgsVal, ok := kubeletExtraArgsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubelet_extra_args expected to be basetypes.MapValue, was: %T`, kubeletExtraArgsAttribute))
	}

	kubernetesUpgradeAttribute, ok := attributes["kubernetes_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_upgrade is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	kubernetesUpgradeVal, ok := kubernetesUpgradeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_upgrade expected to be basetypes.ObjectValue, was: %T`, kubernetesUpgradeAttribute))
	}

	kubernetesVersionAttribute, ok := attributes["kubernetes_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubernetes_version is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	kubernetesVersionVal, ok := kubernetesVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubernetes_version expected to be basetypes.StringValue, was: %T`, kubernetesVersionAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.ObjectValue, was: %T`, networkAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.MapValue, was: %T`, nodesAttribute))
	}

	platformVersionAttribute, ok := attributes["platform_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`platform_version is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	platformVersionVal, ok := platformVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`platform_version expected to be basetypes.StringValue, was: %T`, platformVersionAttribute))
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	return ConfigValue{
		AutoApproveNodes:      autoApproveNodesVal,
		ClusterSsh:            clusterSshVal,
		DedicatedControlPlane: dedicatedControlPlaneVal,
		HighAvailability:      highAvailabilityVal,
		InstallerTtl:          installerTtlVal,
		KubeletExtraArgs:      kubeletExtraArgsVal,
		KubernetesUpgrade:     kubernetesUpgradeVal,
		KubernetesVersion:     kubernetesVersionVal,
		Location:              locationVal,
		Network:               networkVal,
		Nodes:                 nodesVal,
		PlatformVersion:       platformVersionVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigValue {
	object, diags := NewConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigValueMust(ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigType) ValueType(ctx context.Context) attr.Value {
	return ConfigValue{}
}

var _ basetypes.ObjectValuable = ConfigValue{}

type ConfigValue struct {
	AutoApproveNodes      basetypes.BoolValue   `tfsdk:"auto_approve_nodes"`
	ClusterSsh            basetypes.ObjectValue `tfsdk:"cluster_ssh"`
	DedicatedControlPlane basetypes.BoolValue   `tfsdk:"dedicated_control_plane"`
	HighAvailability      basetypes.BoolValue   `tfsdk:"high_availability"`
	InstallerTtl          basetypes.Int64Value  `tfsdk:"installer_ttl"`
	KubeletExtraArgs      basetypes.MapValue    `tfsdk:"kubelet_extra_args"`
	KubernetesUpgrade     basetypes.ObjectValue `tfsdk:"kubernetes_upgrade"`
	KubernetesVersion     basetypes.StringValue `tfsdk:"kubernetes_version"`
	Location              basetypes.StringValue `tfsdk:"location"`
	Network               basetypes.ObjectValue `tfsdk:"network"`
	Nodes                 basetypes.MapValue    `tfsdk:"nodes"`
	PlatformVersion       basetypes.StringValue `tfsdk:"platform_version"`
	state                 attr.ValueState
}

func (v ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["auto_approve_nodes"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cluster_ssh"] = basetypes.ObjectType{
		AttrTypes: ClusterSshValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["dedicated_control_plane"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["high_availability"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["installer_ttl"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["kubelet_extra_args"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kubernetes_upgrade"] = basetypes.ObjectType{
		AttrTypes: KubernetesUpgradeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["kubernetes_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.ObjectType{
		AttrTypes: NetworkValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.MapType{
		ElemType: NodesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["platform_version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AutoApproveNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_approve_nodes"] = val

		val, err = v.ClusterSsh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_ssh"] = val

		val, err = v.DedicatedControlPlane.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dedicated_control_plane"] = val

		val, err = v.HighAvailability.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["high_availability"] = val

		val, err = v.InstallerTtl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["installer_ttl"] = val

		val, err = v.KubeletExtraArgs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubelet_extra_args"] = val

		val, err = v.KubernetesUpgrade.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubernetes_upgrade"] = val

		val, err = v.KubernetesVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubernetes_version"] = val

		val, err = v.Location.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["location"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.PlatformVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["platform_version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigValue) String() string {
	return "ConfigValue"
}

func (v ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var clusterSsh basetypes.ObjectValue

	if v.ClusterSsh.IsNull() {
		clusterSsh = types.ObjectNull(
			ClusterSshValue{}.AttributeTypes(ctx),
		)
	}

	if v.ClusterSsh.IsUnknown() {
		clusterSsh = types.ObjectUnknown(
			ClusterSshValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ClusterSsh.IsNull() && !v.ClusterSsh.IsUnknown() {
		clusterSsh = types.ObjectValueMust(
			ClusterSshValue{}.AttributeTypes(ctx),
			v.ClusterSsh.Attributes(),
		)
	}

	var kubernetesUpgrade basetypes.ObjectValue

	if v.KubernetesUpgrade.IsNull() {
		kubernetesUpgrade = types.ObjectNull(
			KubernetesUpgradeValue{}.AttributeTypes(ctx),
		)
	}

	if v.KubernetesUpgrade.IsUnknown() {
		kubernetesUpgrade = types.ObjectUnknown(
			KubernetesUpgradeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.KubernetesUpgrade.IsNull() && !v.KubernetesUpgrade.IsUnknown() {
		kubernetesUpgrade = types.ObjectValueMust(
			KubernetesUpgradeValue{}.AttributeTypes(ctx),
			v.KubernetesUpgrade.Attributes(),
		)
	}

	var network basetypes.ObjectValue

	if v.Network.IsNull() {
		network = types.ObjectNull(
			NetworkValue{}.AttributeTypes(ctx),
		)
	}

	if v.Network.IsUnknown() {
		network = types.ObjectUnknown(
			NetworkValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Network.IsNull() && !v.Network.IsUnknown() {
		network = types.ObjectValueMust(
			NetworkValue{}.AttributeTypes(ctx),
			v.Network.Attributes(),
		)
	}

	nodes := types.MapValueMust(
		NodesType{
			basetypes.ObjectType{
				AttrTypes: NodesValue{}.AttributeTypes(ctx),
			},
		},
		v.Nodes.Elements(),
	)

	if v.Nodes.IsNull() {
		nodes = types.MapNull(
			NodesType{
				basetypes.ObjectType{
					AttrTypes: NodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Nodes.IsUnknown() {
		nodes = types.MapUnknown(
			NodesType{
				basetypes.ObjectType{
					AttrTypes: NodesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var kubeletExtraArgsVal basetypes.MapValue
	switch {
	case v.KubeletExtraArgs.IsUnknown():
		kubeletExtraArgsVal = types.MapUnknown(types.StringType)
	case v.KubeletExtraArgs.IsNull():
		kubeletExtraArgsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		kubeletExtraArgsVal, d = types.MapValue(types.StringType, v.KubeletExtraArgs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_approve_nodes": basetypes.BoolType{},
			"cluster_ssh": basetypes.ObjectType{
				AttrTypes: ClusterSshValue{}.AttributeTypes(ctx),
			},
			"dedicated_control_plane": basetypes.BoolType{},
			"high_availability":       basetypes.BoolType{},
			"installer_ttl":           basetypes.Int64Type{},
			"kubelet_extra_args": basetypes.MapType{
				ElemType: types.StringType,
			},
			"kubernetes_upgrade": basetypes.ObjectType{
				AttrTypes: KubernetesUpgradeValue{}.AttributeTypes(ctx),
			},
			"kubernetes_version": basetypes.StringType{},
			"location":           basetypes.StringType{},
			"network": basetypes.ObjectType{
				AttrTypes: NetworkValue{}.AttributeTypes(ctx),
			},
			"nodes": basetypes.MapType{
				ElemType: NodesValue{}.Type(ctx),
			},
			"platform_version": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auto_approve_nodes": basetypes.BoolType{},
		"cluster_ssh": basetypes.ObjectType{
			AttrTypes: ClusterSshValue{}.AttributeTypes(ctx),
		},
		"dedicated_control_plane": basetypes.BoolType{},
		"high_availability":       basetypes.BoolType{},
		"installer_ttl":           basetypes.Int64Type{},
		"kubelet_extra_args": basetypes.MapType{
			ElemType: types.StringType,
		},
		"kubernetes_upgrade": basetypes.ObjectType{
			AttrTypes: KubernetesUpgradeValue{}.AttributeTypes(ctx),
		},
		"kubernetes_version": basetypes.StringType{},
		"location":           basetypes.StringType{},
		"network": basetypes.ObjectType{
			AttrTypes: NetworkValue{}.AttributeTypes(ctx),
		},
		"nodes": basetypes.MapType{
			ElemType: NodesValue{}.Type(ctx),
		},
		"platform_version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_approve_nodes":      v.AutoApproveNodes,
			"cluster_ssh":             clusterSsh,
			"dedicated_control_plane": v.DedicatedControlPlane,
			"high_availability":       v.HighAvailability,
			"installer_ttl":           v.InstallerTtl,
			"kubelet_extra_args":      kubeletExtraArgsVal,
			"kubernetes_upgrade":      kubernetesUpgrade,
			"kubernetes_version":      v.KubernetesVersion,
			"location":                v.Location,
			"network":                 network,
			"nodes":                   nodes,
			"platform_version":        v.PlatformVersion,
		})

	return objVal, diags
}

func (v ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoApproveNodes.Equal(other.AutoApproveNodes) {
		return false
	}

	if !v.ClusterSsh.Equal(other.ClusterSsh) {
		return false
	}

	if !v.DedicatedControlPlane.Equal(other.DedicatedControlPlane) {
		return false
	}

	if !v.HighAvailability.Equal(other.HighAvailability) {
		return false
	}

	if !v.InstallerTtl.Equal(other.InstallerTtl) {
		return false
	}

	if !v.KubeletExtraArgs.Equal(other.KubeletExtraArgs) {
		return false
	}

	if !v.KubernetesUpgrade.Equal(other.KubernetesUpgrade) {
		return false
	}

	if !v.KubernetesVersion.Equal(other.KubernetesVersion) {
		return false
	}

	if !v.Location.Equal(other.Location) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.PlatformVersion.Equal(other.PlatformVersion) {
		return false
	}

	return true
}

func (v ConfigValue) Type(ctx context.Context) attr.Type {
	return ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_approve_nodes": basetypes.BoolType{},
		"cluster_ssh": basetypes.ObjectType{
			AttrTypes: ClusterSshValue{}.AttributeTypes(ctx),
		},
		"dedicated_control_plane": basetypes.BoolType{},
		"high_availability":       basetypes.BoolType{},
		"installer_ttl":           basetypes.Int64Type{},
		"kubelet_extra_args": basetypes.MapType{
			ElemType: types.StringType,
		},
		"kubernetes_upgrade": basetypes.ObjectType{
			AttrTypes: KubernetesUpgradeValue{}.AttributeTypes(ctx),
		},
		"kubernetes_version": basetypes.StringType{},
		"location":           basetypes.StringType{},
		"network": basetypes.ObjectType{
			AttrTypes: NetworkValue{}.AttributeTypes(ctx),
		},
		"nodes": basetypes.MapType{
			ElemType: NodesValue{}.Type(ctx),
		},
		"platform_version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterSshType{}

type ClusterSshType struct {
	basetypes.ObjectType
}

func (t ClusterSshType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterSshType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterSshType) String() string {
	return "ClusterSshType"
}

func (t ClusterSshType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	passphraseAttribute, ok := attributes["passphrase"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase is missing from object`)

		return nil, diags
	}

	passphraseVal, ok := passphraseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase expected to be basetypes.StringValue, was: %T`, passphraseAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	privateKeyPathAttribute, ok := attributes["private_key_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_key_path is missing from object`)

		return nil, diags
	}

	privateKeyPathVal, ok := privateKeyPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_key_path expected to be basetypes.StringValue, was: %T`, privateKeyPathAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterSshValue{
		Passphrase:     passphraseVal,
		Port:           portVal,
		PrivateKeyPath: privateKeyPathVal,
		Username:       usernameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewClusterSshValueNull() ClusterSshValue {
	return ClusterSshValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterSshValueUnknown() ClusterSshValue {
	return ClusterSshValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterSshValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterSshValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterSshValue Attribute Value",
				"While creating a ClusterSshValue value, a missing attribute value was detected. "+
					"A ClusterSshValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterSshValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterSshValue Attribute Type",
				"While creating a ClusterSshValue value, an invalid attribute value was detected. "+
					"A ClusterSshValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterSshValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterSshValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterSshValue Attribute Value",
				"While creating a ClusterSshValue value, an extra attribute value was detected. "+
					"A ClusterSshValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterSshValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterSshValueUnknown(), diags
	}

	passphraseAttribute, ok := attributes["passphrase"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase is missing from object`)

		return NewClusterSshValueUnknown(), diags
	}

	passphraseVal, ok := passphraseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase expected to be basetypes.StringValue, was: %T`, passphraseAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewClusterSshValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	privateKeyPathAttribute, ok := attributes["private_key_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_key_path is missing from object`)

		return NewClusterSshValueUnknown(), diags
	}

	privateKeyPathVal, ok := privateKeyPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_key_path expected to be basetypes.StringValue, was: %T`, privateKeyPathAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewClusterSshValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewClusterSshValueUnknown(), diags
	}

	return ClusterSshValue{
		Passphrase:     passphraseVal,
		Port:           portVal,
		PrivateKeyPath: privateKeyPathVal,
		Username:       usernameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewClusterSshValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterSshValue {
	object, diags := NewClusterSshValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterSshValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterSshType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterSshValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterSshValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterSshValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterSshValueMust(ClusterSshValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterSshType) ValueType(ctx context.Context) attr.Value {
	return ClusterSshValue{}
}

var _ basetypes.ObjectValuable = ClusterSshValue{}

type ClusterSshValue struct {
	Passphrase     basetypes.StringValue `tfsdk:"passphrase"`
	Port           basetypes.StringValue `tfsdk:"port"`
	PrivateKeyPath basetypes.StringValue `tfsdk:"private_key_path"`
	Username       basetypes.StringValue `tfsdk:"username"`
	state          attr.ValueState
}

func (v ClusterSshValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["passphrase"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_key_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Passphrase.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passphrase"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.PrivateKeyPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_key_path"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterSshValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterSshValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterSshValue) String() string {
	return "ClusterSshValue"
}

func (v ClusterSshValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"passphrase":       basetypes.StringType{},
		"port":             basetypes.StringType{},
		"private_key_path": basetypes.StringType{},
		"username":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"passphrase":       v.Passphrase,
			"port":             v.Port,
			"private_key_path": v.PrivateKeyPath,
			"username":         v.Username,
		})

	return objVal, diags
}

func (v ClusterSshValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterSshValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Passphrase.Equal(other.Passphrase) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.PrivateKeyPath.Equal(other.PrivateKeyPath) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v ClusterSshValue) Type(ctx context.Context) attr.Type {
	return ClusterSshType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterSshValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"passphrase":       basetypes.StringType{},
		"port":             basetypes.StringType{},
		"private_key_path": basetypes.StringType{},
		"username":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = KubernetesUpgradeType{}

type KubernetesUpgradeType struct {
	basetypes.ObjectType
}

func (t KubernetesUpgradeType) Equal(o attr.Type) bool {
	other, ok := o.(KubernetesUpgradeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KubernetesUpgradeType) String() string {
	return "KubernetesUpgradeType"
}

func (t KubernetesUpgradeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	paramsAttribute, ok := attributes["params"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`params is missing from object`)

		return nil, diags
	}

	paramsVal, ok := paramsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`params expected to be basetypes.ObjectValue, was: %T`, paramsAttribute))
	}

	strategyAttribute, ok := attributes["strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strategy is missing from object`)

		return nil, diags
	}

	strategyVal, ok := strategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strategy expected to be basetypes.StringValue, was: %T`, strategyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KubernetesUpgradeValue{
		Params:   paramsVal,
		Strategy: strategyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewKubernetesUpgradeValueNull() KubernetesUpgradeValue {
	return KubernetesUpgradeValue{
		state: attr.ValueStateNull,
	}
}

func NewKubernetesUpgradeValueUnknown() KubernetesUpgradeValue {
	return KubernetesUpgradeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKubernetesUpgradeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KubernetesUpgradeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KubernetesUpgradeValue Attribute Value",
				"While creating a KubernetesUpgradeValue value, a missing attribute value was detected. "+
					"A KubernetesUpgradeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KubernetesUpgradeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KubernetesUpgradeValue Attribute Type",
				"While creating a KubernetesUpgradeValue value, an invalid attribute value was detected. "+
					"A KubernetesUpgradeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KubernetesUpgradeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KubernetesUpgradeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KubernetesUpgradeValue Attribute Value",
				"While creating a KubernetesUpgradeValue value, an extra attribute value was detected. "+
					"A KubernetesUpgradeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KubernetesUpgradeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKubernetesUpgradeValueUnknown(), diags
	}

	paramsAttribute, ok := attributes["params"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`params is missing from object`)

		return NewKubernetesUpgradeValueUnknown(), diags
	}

	paramsVal, ok := paramsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`params expected to be basetypes.ObjectValue, was: %T`, paramsAttribute))
	}

	strategyAttribute, ok := attributes["strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strategy is missing from object`)

		return NewKubernetesUpgradeValueUnknown(), diags
	}

	strategyVal, ok := strategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strategy expected to be basetypes.StringValue, was: %T`, strategyAttribute))
	}

	if diags.HasError() {
		return NewKubernetesUpgradeValueUnknown(), diags
	}

	return KubernetesUpgradeValue{
		Params:   paramsVal,
		Strategy: strategyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewKubernetesUpgradeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KubernetesUpgradeValue {
	object, diags := NewKubernetesUpgradeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKubernetesUpgradeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KubernetesUpgradeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKubernetesUpgradeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKubernetesUpgradeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKubernetesUpgradeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKubernetesUpgradeValueMust(KubernetesUpgradeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KubernetesUpgradeType) ValueType(ctx context.Context) attr.Value {
	return KubernetesUpgradeValue{}
}

var _ basetypes.ObjectValuable = KubernetesUpgradeValue{}

type KubernetesUpgradeValue struct {
	Params   basetypes.ObjectValue `tfsdk:"params"`
	Strategy basetypes.StringValue `tfsdk:"strategy"`
	state    attr.ValueState
}

func (v KubernetesUpgradeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["params"] = basetypes.ObjectType{
		AttrTypes: ParamsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["strategy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Params.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["params"] = val

		val, err = v.Strategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["strategy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KubernetesUpgradeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KubernetesUpgradeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KubernetesUpgradeValue) String() string {
	return "KubernetesUpgradeValue"
}

func (v KubernetesUpgradeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var params basetypes.ObjectValue

	if v.Params.IsNull() {
		params = types.ObjectNull(
			ParamsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Params.IsUnknown() {
		params = types.ObjectUnknown(
			ParamsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Params.IsNull() && !v.Params.IsUnknown() {
		params = types.ObjectValueMust(
			ParamsValue{}.AttributeTypes(ctx),
			v.Params.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"params": basetypes.ObjectType{
			AttrTypes: ParamsValue{}.AttributeTypes(ctx),
		},
		"strategy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"params":   params,
			"strategy": v.Strategy,
		})

	return objVal, diags
}

func (v KubernetesUpgradeValue) Equal(o attr.Value) bool {
	other, ok := o.(KubernetesUpgradeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Params.Equal(other.Params) {
		return false
	}

	if !v.Strategy.Equal(other.Strategy) {
		return false
	}

	return true
}

func (v KubernetesUpgradeValue) Type(ctx context.Context) attr.Type {
	return KubernetesUpgradeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KubernetesUpgradeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"params": basetypes.ObjectType{
			AttrTypes: ParamsValue{}.AttributeTypes(ctx),
		},
		"strategy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ParamsType{}

type ParamsType struct {
	basetypes.ObjectType
}

func (t ParamsType) Equal(o attr.Type) bool {
	other, ok := o.(ParamsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ParamsType) String() string {
	return "ParamsType"
}

func (t ParamsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	workerConcurrencyAttribute, ok := attributes["worker_concurrency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`worker_concurrency is missing from object`)

		return nil, diags
	}

	workerConcurrencyVal, ok := workerConcurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`worker_concurrency expected to be basetypes.StringValue, was: %T`, workerConcurrencyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ParamsValue{
		WorkerConcurrency: workerConcurrencyVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewParamsValueNull() ParamsValue {
	return ParamsValue{
		state: attr.ValueStateNull,
	}
}

func NewParamsValueUnknown() ParamsValue {
	return ParamsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewParamsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ParamsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ParamsValue Attribute Value",
				"While creating a ParamsValue value, a missing attribute value was detected. "+
					"A ParamsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ParamsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ParamsValue Attribute Type",
				"While creating a ParamsValue value, an invalid attribute value was detected. "+
					"A ParamsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ParamsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ParamsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ParamsValue Attribute Value",
				"While creating a ParamsValue value, an extra attribute value was detected. "+
					"A ParamsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ParamsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewParamsValueUnknown(), diags
	}

	workerConcurrencyAttribute, ok := attributes["worker_concurrency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`worker_concurrency is missing from object`)

		return NewParamsValueUnknown(), diags
	}

	workerConcurrencyVal, ok := workerConcurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`worker_concurrency expected to be basetypes.StringValue, was: %T`, workerConcurrencyAttribute))
	}

	if diags.HasError() {
		return NewParamsValueUnknown(), diags
	}

	return ParamsValue{
		WorkerConcurrency: workerConcurrencyVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewParamsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ParamsValue {
	object, diags := NewParamsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewParamsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ParamsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewParamsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewParamsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewParamsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewParamsValueMust(ParamsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ParamsType) ValueType(ctx context.Context) attr.Value {
	return ParamsValue{}
}

var _ basetypes.ObjectValuable = ParamsValue{}

type ParamsValue struct {
	WorkerConcurrency basetypes.StringValue `tfsdk:"worker_concurrency"`
	state             attr.ValueState
}

func (v ParamsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["worker_concurrency"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.WorkerConcurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["worker_concurrency"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ParamsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ParamsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ParamsValue) String() string {
	return "ParamsValue"
}

func (v ParamsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"worker_concurrency": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"worker_concurrency": v.WorkerConcurrency,
		})

	return objVal, diags
}

func (v ParamsValue) Equal(o attr.Value) bool {
	other, ok := o.(ParamsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.WorkerConcurrency.Equal(other.WorkerConcurrency) {
		return false
	}

	return true
}

func (v ParamsValue) Type(ctx context.Context) attr.Type {
	return ParamsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ParamsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"worker_concurrency": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworkType{}

type NetworkType struct {
	basetypes.ObjectType
}

func (t NetworkType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkType) String() string {
	return "NetworkType"
}

func (t NetworkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cniAttribute, ok := attributes["cni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni is missing from object`)

		return nil, diags
	}

	cniVal, ok := cniAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni expected to be basetypes.ObjectValue, was: %T`, cniAttribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return nil, diags
	}

	ipv6Val, ok := ipv6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be basetypes.ObjectValue, was: %T`, ipv6Attribute))
	}

	podSubnetAttribute, ok := attributes["pod_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_subnet is missing from object`)

		return nil, diags
	}

	podSubnetVal, ok := podSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_subnet expected to be basetypes.StringValue, was: %T`, podSubnetAttribute))
	}

	serviceSubnetAttribute, ok := attributes["service_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_subnet is missing from object`)

		return nil, diags
	}

	serviceSubnetVal, ok := serviceSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_subnet expected to be basetypes.StringValue, was: %T`, serviceSubnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkValue{
		Cni:           cniVal,
		Ipv6:          ipv6Val,
		PodSubnet:     podSubnetVal,
		ServiceSubnet: serviceSubnetVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewNetworkValueNull() NetworkValue {
	return NetworkValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkValueUnknown() NetworkValue {
	return NetworkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkValue Attribute Value",
				"While creating a NetworkValue value, a missing attribute value was detected. "+
					"A NetworkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkValue Attribute Type",
				"While creating a NetworkValue value, an invalid attribute value was detected. "+
					"A NetworkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkValue Attribute Value",
				"While creating a NetworkValue value, an extra attribute value was detected. "+
					"A NetworkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkValueUnknown(), diags
	}

	cniAttribute, ok := attributes["cni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cni is missing from object`)

		return NewNetworkValueUnknown(), diags
	}

	cniVal, ok := cniAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cni expected to be basetypes.ObjectValue, was: %T`, cniAttribute))
	}

	ipv6Attribute, ok := attributes["ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6 is missing from object`)

		return NewNetworkValueUnknown(), diags
	}

	ipv6Val, ok := ipv6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6 expected to be basetypes.ObjectValue, was: %T`, ipv6Attribute))
	}

	podSubnetAttribute, ok := attributes["pod_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_subnet is missing from object`)

		return NewNetworkValueUnknown(), diags
	}

	podSubnetVal, ok := podSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_subnet expected to be basetypes.StringValue, was: %T`, podSubnetAttribute))
	}

	serviceSubnetAttribute, ok := attributes["service_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_subnet is missing from object`)

		return NewNetworkValueUnknown(), diags
	}

	serviceSubnetVal, ok := serviceSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_subnet expected to be basetypes.StringValue, was: %T`, serviceSubnetAttribute))
	}

	if diags.HasError() {
		return NewNetworkValueUnknown(), diags
	}

	return NetworkValue{
		Cni:           cniVal,
		Ipv6:          ipv6Val,
		PodSubnet:     podSubnetVal,
		ServiceSubnet: serviceSubnetVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewNetworkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkValue {
	object, diags := NewNetworkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkValueMust(NetworkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkType) ValueType(ctx context.Context) attr.Value {
	return NetworkValue{}
}

var _ basetypes.ObjectValuable = NetworkValue{}

type NetworkValue struct {
	Cni           basetypes.ObjectValue `tfsdk:"cni"`
	Ipv6          basetypes.ObjectValue `tfsdk:"ipv6"`
	PodSubnet     basetypes.StringValue `tfsdk:"pod_subnet"`
	ServiceSubnet basetypes.StringValue `tfsdk:"service_subnet"`
	state         attr.ValueState
}

func (v NetworkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cni"] = basetypes.ObjectType{
		AttrTypes: CniValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6"] = basetypes.ObjectType{
		AttrTypes: Ipv6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["pod_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Cni.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cni"] = val

		val, err = v.Ipv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6"] = val

		val, err = v.PodSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_subnet"] = val

		val, err = v.ServiceSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkValue) String() string {
	return "NetworkValue"
}

func (v NetworkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cni basetypes.ObjectValue

	if v.Cni.IsNull() {
		cni = types.ObjectNull(
			CniValue{}.AttributeTypes(ctx),
		)
	}

	if v.Cni.IsUnknown() {
		cni = types.ObjectUnknown(
			CniValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Cni.IsNull() && !v.Cni.IsUnknown() {
		cni = types.ObjectValueMust(
			CniValue{}.AttributeTypes(ctx),
			v.Cni.Attributes(),
		)
	}

	var ipv6 basetypes.ObjectValue

	if v.Ipv6.IsNull() {
		ipv6 = types.ObjectNull(
			Ipv6Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6.IsUnknown() {
		ipv6 = types.ObjectUnknown(
			Ipv6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6.IsNull() && !v.Ipv6.IsUnknown() {
		ipv6 = types.ObjectValueMust(
			Ipv6Value{}.AttributeTypes(ctx),
			v.Ipv6.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"cni": basetypes.ObjectType{
			AttrTypes: CniValue{}.AttributeTypes(ctx),
		},
		"ipv6": basetypes.ObjectType{
			AttrTypes: Ipv6Value{}.AttributeTypes(ctx),
		},
		"pod_subnet":     basetypes.StringType{},
		"service_subnet": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cni":            cni,
			"ipv6":           ipv6,
			"pod_subnet":     v.PodSubnet,
			"service_subnet": v.ServiceSubnet,
		})

	return objVal, diags
}

func (v NetworkValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cni.Equal(other.Cni) {
		return false
	}

	if !v.Ipv6.Equal(other.Ipv6) {
		return false
	}

	if !v.PodSubnet.Equal(other.PodSubnet) {
		return false
	}

	if !v.ServiceSubnet.Equal(other.ServiceSubnet) {
		return false
	}

	return true
}

func (v NetworkValue) Type(ctx context.Context) attr.Type {
	return NetworkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cni": basetypes.ObjectType{
			AttrTypes: CniValue{}.AttributeTypes(ctx),
		},
		"ipv6": basetypes.ObjectType{
			AttrTypes: Ipv6Value{}.AttributeTypes(ctx),
		},
		"pod_subnet":     basetypes.StringType{},
		"service_subnet": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CniType{}

type CniType struct {
	basetypes.ObjectType
}

func (t CniType) Equal(o attr.Type) bool {
	other, ok := o.(CniType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CniType) String() string {
	return "CniType"
}

func (t CniType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CniValue{
		Name:    nameVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCniValueNull() CniValue {
	return CniValue{
		state: attr.ValueStateNull,
	}
}

func NewCniValueUnknown() CniValue {
	return CniValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCniValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CniValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CniValue Attribute Value",
				"While creating a CniValue value, a missing attribute value was detected. "+
					"A CniValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CniValue Attribute Type",
				"While creating a CniValue value, an invalid attribute value was detected. "+
					"A CniValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CniValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CniValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CniValue Attribute Value",
				"While creating a CniValue value, an extra attribute value was detected. "+
					"A CniValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CniValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCniValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCniValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewCniValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewCniValueUnknown(), diags
	}

	return CniValue{
		Name:    nameVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCniValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CniValue {
	object, diags := NewCniValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCniValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CniType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCniValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCniValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCniValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCniValueMust(CniValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CniType) ValueType(ctx context.Context) attr.Value {
	return CniValue{}
}

var _ basetypes.ObjectValuable = CniValue{}

type CniValue struct {
	Name    basetypes.StringValue `tfsdk:"name"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v CniValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CniValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CniValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CniValue) String() string {
	return "CniValue"
}

func (v CniValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":    v.Name,
			"version": v.Version,
		})

	return objVal, diags
}

func (v CniValue) Equal(o attr.Value) bool {
	other, ok := o.(CniValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v CniValue) Type(ctx context.Context) attr.Type {
	return CniType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CniValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6Type{}

type Ipv6Type struct {
	basetypes.ObjectType
}

func (t Ipv6Type) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6Type) String() string {
	return "Ipv6Type"
}

func (t Ipv6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	podSubnetAttribute, ok := attributes["pod_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_subnet is missing from object`)

		return nil, diags
	}

	podSubnetVal, ok := podSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_subnet expected to be basetypes.StringValue, was: %T`, podSubnetAttribute))
	}

	serviceSubnetAttribute, ok := attributes["service_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_subnet is missing from object`)

		return nil, diags
	}

	serviceSubnetVal, ok := serviceSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_subnet expected to be basetypes.StringValue, was: %T`, serviceSubnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6Value{
		PodSubnet:     podSubnetVal,
		ServiceSubnet: serviceSubnetVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIpv6ValueNull() Ipv6Value {
	return Ipv6Value{
		state: attr.ValueStateNull,
	}
}

func NewIpv6ValueUnknown() Ipv6Value {
	return Ipv6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6Value Attribute Value",
				"While creating a Ipv6Value value, a missing attribute value was detected. "+
					"A Ipv6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6Value Attribute Type",
				"While creating a Ipv6Value value, an invalid attribute value was detected. "+
					"A Ipv6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6Value Attribute Value",
				"While creating a Ipv6Value value, an extra attribute value was detected. "+
					"A Ipv6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6ValueUnknown(), diags
	}

	podSubnetAttribute, ok := attributes["pod_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_subnet is missing from object`)

		return NewIpv6ValueUnknown(), diags
	}

	podSubnetVal, ok := podSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_subnet expected to be basetypes.StringValue, was: %T`, podSubnetAttribute))
	}

	serviceSubnetAttribute, ok := attributes["service_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_subnet is missing from object`)

		return NewIpv6ValueUnknown(), diags
	}

	serviceSubnetVal, ok := serviceSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_subnet expected to be basetypes.StringValue, was: %T`, serviceSubnetAttribute))
	}

	if diags.HasError() {
		return NewIpv6ValueUnknown(), diags
	}

	return Ipv6Value{
		PodSubnet:     podSubnetVal,
		ServiceSubnet: serviceSubnetVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIpv6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6Value {
	object, diags := NewIpv6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6ValueMust(Ipv6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6Type) ValueType(ctx context.Context) attr.Value {
	return Ipv6Value{}
}

var _ basetypes.ObjectValuable = Ipv6Value{}

type Ipv6Value struct {
	PodSubnet     basetypes.StringValue `tfsdk:"pod_subnet"`
	ServiceSubnet basetypes.StringValue `tfsdk:"service_subnet"`
	state         attr.ValueState
}

func (v Ipv6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["pod_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PodSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_subnet"] = val

		val, err = v.ServiceSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6Value) String() string {
	return "Ipv6Value"
}

func (v Ipv6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"pod_subnet":     basetypes.StringType{},
		"service_subnet": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"pod_subnet":     v.PodSubnet,
			"service_subnet": v.ServiceSubnet,
		})

	return objVal, diags
}

func (v Ipv6Value) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PodSubnet.Equal(other.PodSubnet) {
		return false
	}

	if !v.ServiceSubnet.Equal(other.ServiceSubnet) {
		return false
	}

	return true
}

func (v Ipv6Value) Type(ctx context.Context) attr.Type {
	return Ipv6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"pod_subnet":     basetypes.StringType{},
		"service_subnet": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NodesType{}

type NodesType struct {
	basetypes.ObjectType
}

func (t NodesType) Equal(o attr.Type) bool {
	other, ok := o.(NodesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NodesType) String() string {
	return "NodesType"
}

func (t NodesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archAttribute, ok := attributes["arch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arch is missing from object`)

		return nil, diags
	}

	archVal, ok := archAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arch expected to be basetypes.StringValue, was: %T`, archAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return nil, diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	kubeletExtraArgsAttribute, ok := attributes["kubelet_extra_args"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubelet_extra_args is missing from object`)

		return nil, diags
	}

	kubeletExtraArgsVal, ok := kubeletExtraArgsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubelet_extra_args expected to be basetypes.MapValue, was: %T`, kubeletExtraArgsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	privateIpAttribute, ok := attributes["private_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip is missing from object`)

		return nil, diags
	}

	privateIpVal, ok := privateIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip expected to be basetypes.StringValue, was: %T`, privateIpAttribute))
	}

	rolesAttribute, ok := attributes["roles"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`roles is missing from object`)

		return nil, diags
	}

	rolesVal, ok := rolesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`roles expected to be basetypes.SetValue, was: %T`, rolesAttribute))
	}

	sshAttribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh is missing from object`)

		return nil, diags
	}

	sshVal, ok := sshAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh expected to be basetypes.ObjectValue, was: %T`, sshAttribute))
	}

	taintsAttribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints is missing from object`)

		return nil, diags
	}

	taintsVal, ok := taintsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints expected to be basetypes.SetValue, was: %T`, taintsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NodesValue{
		Arch:             archVal,
		Hostname:         hostnameVal,
		Interface:        interfaceVal,
		KubeletExtraArgs: kubeletExtraArgsVal,
		Labels:           labelsVal,
		OperatingSystem:  operatingSystemVal,
		PrivateIp:        privateIpVal,
		Roles:            rolesVal,
		Ssh:              sshVal,
		Taints:           taintsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNodesValueNull() NodesValue {
	return NodesValue{
		state: attr.ValueStateNull,
	}
}

func NewNodesValueUnknown() NodesValue {
	return NodesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNodesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NodesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NodesValue Attribute Value",
				"While creating a NodesValue value, a missing attribute value was detected. "+
					"A NodesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NodesValue Attribute Type",
				"While creating a NodesValue value, an invalid attribute value was detected. "+
					"A NodesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NodesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NodesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NodesValue Attribute Value",
				"While creating a NodesValue value, an extra attribute value was detected. "+
					"A NodesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NodesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNodesValueUnknown(), diags
	}

	archAttribute, ok := attributes["arch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arch is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	archVal, ok := archAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arch expected to be basetypes.StringValue, was: %T`, archAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	kubeletExtraArgsAttribute, ok := attributes["kubelet_extra_args"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kubelet_extra_args is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	kubeletExtraArgsVal, ok := kubeletExtraArgsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kubelet_extra_args expected to be basetypes.MapValue, was: %T`, kubeletExtraArgsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	privateIpAttribute, ok := attributes["private_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	privateIpVal, ok := privateIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip expected to be basetypes.StringValue, was: %T`, privateIpAttribute))
	}

	rolesAttribute, ok := attributes["roles"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`roles is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	rolesVal, ok := rolesAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`roles expected to be basetypes.SetValue, was: %T`, rolesAttribute))
	}

	sshAttribute, ok := attributes["ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssh is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	sshVal, ok := sshAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssh expected to be basetypes.ObjectValue, was: %T`, sshAttribute))
	}

	taintsAttribute, ok := attributes["taints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taints is missing from object`)

		return NewNodesValueUnknown(), diags
	}

	taintsVal, ok := taintsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taints expected to be basetypes.SetValue, was: %T`, taintsAttribute))
	}

	if diags.HasError() {
		return NewNodesValueUnknown(), diags
	}

	return NodesValue{
		Arch:             archVal,
		Hostname:         hostnameVal,
		Interface:        interfaceVal,
		KubeletExtraArgs: kubeletExtraArgsVal,
		Labels:           labelsVal,
		OperatingSystem:  operatingSystemVal,
		PrivateIp:        privateIpVal,
		Roles:            rolesVal,
		Ssh:              sshVal,
		Taints:           taintsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewNodesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NodesValue {
	object, diags := NewNodesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNodesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NodesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNodesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNodesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNodesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNodesValueMust(NodesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NodesType) ValueType(ctx context.Context) attr.Value {
	return NodesValue{}
}

var _ basetypes.ObjectValuable = NodesValue{}

type NodesValue struct {
	Arch             basetypes.StringValue `tfsdk:"arch"`
	Hostname         basetypes.StringValue `tfsdk:"hostname"`
	Interface        basetypes.StringValue `tfsdk:"interface"`
	KubeletExtraArgs basetypes.MapValue    `tfsdk:"kubelet_extra_args"`
	Labels           basetypes.MapValue    `tfsdk:"labels"`
	OperatingSystem  basetypes.StringValue `tfsdk:"operating_system"`
	PrivateIp        basetypes.StringValue `tfsdk:"private_ip"`
	Roles            basetypes.SetValue    `tfsdk:"roles"`
	Ssh              basetypes.ObjectValue `tfsdk:"ssh"`
	Taints           basetypes.SetValue    `tfsdk:"taints"`
	state            attr.ValueState
}

func (v NodesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["arch"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hostname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kubelet_extra_args"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["roles"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["ssh"] = basetypes.ObjectType{
		AttrTypes: SshValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["taints"] = basetypes.SetType{
		ElemType: TaintsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Arch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arch"] = val

		val, err = v.Hostname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hostname"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.KubeletExtraArgs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kubelet_extra_args"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.PrivateIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_ip"] = val

		val, err = v.Roles.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["roles"] = val

		val, err = v.Ssh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssh"] = val

		val, err = v.Taints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taints"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NodesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NodesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NodesValue) String() string {
	return "NodesValue"
}

func (v NodesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ssh basetypes.ObjectValue

	if v.Ssh.IsNull() {
		ssh = types.ObjectNull(
			SshValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ssh.IsUnknown() {
		ssh = types.ObjectUnknown(
			SshValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ssh.IsNull() && !v.Ssh.IsUnknown() {
		ssh = types.ObjectValueMust(
			SshValue{}.AttributeTypes(ctx),
			v.Ssh.Attributes(),
		)
	}

	taints := types.SetValueMust(
		TaintsType{
			basetypes.ObjectType{
				AttrTypes: TaintsValue{}.AttributeTypes(ctx),
			},
		},
		v.Taints.Elements(),
	)

	if v.Taints.IsNull() {
		taints = types.SetNull(
			TaintsType{
				basetypes.ObjectType{
					AttrTypes: TaintsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taints.IsUnknown() {
		taints = types.SetUnknown(
			TaintsType{
				basetypes.ObjectType{
					AttrTypes: TaintsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var kubeletExtraArgsVal basetypes.MapValue
	switch {
	case v.KubeletExtraArgs.IsUnknown():
		kubeletExtraArgsVal = types.MapUnknown(types.StringType)
	case v.KubeletExtraArgs.IsNull():
		kubeletExtraArgsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		kubeletExtraArgsVal, d = types.MapValue(types.StringType, v.KubeletExtraArgs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch":      basetypes.StringType{},
			"hostname":  basetypes.StringType{},
			"interface": basetypes.StringType{},
			"kubelet_extra_args": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"operating_system": basetypes.StringType{},
			"private_ip":       basetypes.StringType{},
			"roles": basetypes.SetType{
				ElemType: types.StringType,
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: SshValue{}.AttributeTypes(ctx),
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch":      basetypes.StringType{},
			"hostname":  basetypes.StringType{},
			"interface": basetypes.StringType{},
			"kubelet_extra_args": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"operating_system": basetypes.StringType{},
			"private_ip":       basetypes.StringType{},
			"roles": basetypes.SetType{
				ElemType: types.StringType,
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: SshValue{}.AttributeTypes(ctx),
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
		}), diags
	}

	var rolesVal basetypes.SetValue
	switch {
	case v.Roles.IsUnknown():
		rolesVal = types.SetUnknown(types.StringType)
	case v.Roles.IsNull():
		rolesVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		rolesVal, d = types.SetValue(types.StringType, v.Roles.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch":      basetypes.StringType{},
			"hostname":  basetypes.StringType{},
			"interface": basetypes.StringType{},
			"kubelet_extra_args": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"operating_system": basetypes.StringType{},
			"private_ip":       basetypes.StringType{},
			"roles": basetypes.SetType{
				ElemType: types.StringType,
			},
			"ssh": basetypes.ObjectType{
				AttrTypes: SshValue{}.AttributeTypes(ctx),
			},
			"taints": basetypes.SetType{
				ElemType: TaintsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"arch":      basetypes.StringType{},
		"hostname":  basetypes.StringType{},
		"interface": basetypes.StringType{},
		"kubelet_extra_args": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"operating_system": basetypes.StringType{},
		"private_ip":       basetypes.StringType{},
		"roles": basetypes.SetType{
			ElemType: types.StringType,
		},
		"ssh": basetypes.ObjectType{
			AttrTypes: SshValue{}.AttributeTypes(ctx),
		},
		"taints": basetypes.SetType{
			ElemType: TaintsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arch":               v.Arch,
			"hostname":           v.Hostname,
			"interface":          v.Interface,
			"kubelet_extra_args": kubeletExtraArgsVal,
			"labels":             labelsVal,
			"operating_system":   v.OperatingSystem,
			"private_ip":         v.PrivateIp,
			"roles":              rolesVal,
			"ssh":                ssh,
			"taints":             taints,
		})

	return objVal, diags
}

func (v NodesValue) Equal(o attr.Value) bool {
	other, ok := o.(NodesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Arch.Equal(other.Arch) {
		return false
	}

	if !v.Hostname.Equal(other.Hostname) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.KubeletExtraArgs.Equal(other.KubeletExtraArgs) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.PrivateIp.Equal(other.PrivateIp) {
		return false
	}

	if !v.Roles.Equal(other.Roles) {
		return false
	}

	if !v.Ssh.Equal(other.Ssh) {
		return false
	}

	if !v.Taints.Equal(other.Taints) {
		return false
	}

	return true
}

func (v NodesValue) Type(ctx context.Context) attr.Type {
	return NodesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NodesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arch":      basetypes.StringType{},
		"hostname":  basetypes.StringType{},
		"interface": basetypes.StringType{},
		"kubelet_extra_args": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"operating_system": basetypes.StringType{},
		"private_ip":       basetypes.StringType{},
		"roles": basetypes.SetType{
			ElemType: types.StringType,
		},
		"ssh": basetypes.ObjectType{
			AttrTypes: SshValue{}.AttributeTypes(ctx),
		},
		"taints": basetypes.SetType{
			ElemType: TaintsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SshType{}

type SshType struct {
	basetypes.ObjectType
}

func (t SshType) Equal(o attr.Type) bool {
	other, ok := o.(SshType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SshType) String() string {
	return "SshType"
}

func (t SshType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	passphraseAttribute, ok := attributes["passphrase"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase is missing from object`)

		return nil, diags
	}

	passphraseVal, ok := passphraseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase expected to be basetypes.StringValue, was: %T`, passphraseAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	privateKeyPathAttribute, ok := attributes["private_key_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_key_path is missing from object`)

		return nil, diags
	}

	privateKeyPathVal, ok := privateKeyPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_key_path expected to be basetypes.StringValue, was: %T`, privateKeyPathAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SshValue{
		IpAddress:      ipAddressVal,
		Passphrase:     passphraseVal,
		Port:           portVal,
		PrivateKeyPath: privateKeyPathVal,
		Username:       usernameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSshValueNull() SshValue {
	return SshValue{
		state: attr.ValueStateNull,
	}
}

func NewSshValueUnknown() SshValue {
	return SshValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSshValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SshValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SshValue Attribute Value",
				"While creating a SshValue value, a missing attribute value was detected. "+
					"A SshValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SshValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SshValue Attribute Type",
				"While creating a SshValue value, an invalid attribute value was detected. "+
					"A SshValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SshValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SshValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SshValue Attribute Value",
				"While creating a SshValue value, an extra attribute value was detected. "+
					"A SshValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SshValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSshValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewSshValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	passphraseAttribute, ok := attributes["passphrase"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase is missing from object`)

		return NewSshValueUnknown(), diags
	}

	passphraseVal, ok := passphraseAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase expected to be basetypes.StringValue, was: %T`, passphraseAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewSshValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	privateKeyPathAttribute, ok := attributes["private_key_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_key_path is missing from object`)

		return NewSshValueUnknown(), diags
	}

	privateKeyPathVal, ok := privateKeyPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_key_path expected to be basetypes.StringValue, was: %T`, privateKeyPathAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewSshValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewSshValueUnknown(), diags
	}

	return SshValue{
		IpAddress:      ipAddressVal,
		Passphrase:     passphraseVal,
		Port:           portVal,
		PrivateKeyPath: privateKeyPathVal,
		Username:       usernameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSshValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SshValue {
	object, diags := NewSshValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSshValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SshType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSshValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSshValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSshValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSshValueMust(SshValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SshType) ValueType(ctx context.Context) attr.Value {
	return SshValue{}
}

var _ basetypes.ObjectValuable = SshValue{}

type SshValue struct {
	IpAddress      basetypes.StringValue `tfsdk:"ip_address"`
	Passphrase     basetypes.StringValue `tfsdk:"passphrase"`
	Port           basetypes.StringValue `tfsdk:"port"`
	PrivateKeyPath basetypes.StringValue `tfsdk:"private_key_path"`
	Username       basetypes.StringValue `tfsdk:"username"`
	state          attr.ValueState
}

func (v SshValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["passphrase"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_key_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.Passphrase.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passphrase"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.PrivateKeyPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_key_path"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SshValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SshValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SshValue) String() string {
	return "SshValue"
}

func (v SshValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address":       basetypes.StringType{},
		"passphrase":       basetypes.StringType{},
		"port":             basetypes.StringType{},
		"private_key_path": basetypes.StringType{},
		"username":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address":       v.IpAddress,
			"passphrase":       v.Passphrase,
			"port":             v.Port,
			"private_key_path": v.PrivateKeyPath,
			"username":         v.Username,
		})

	return objVal, diags
}

func (v SshValue) Equal(o attr.Value) bool {
	other, ok := o.(SshValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.Passphrase.Equal(other.Passphrase) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.PrivateKeyPath.Equal(other.PrivateKeyPath) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v SshValue) Type(ctx context.Context) attr.Type {
	return SshType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SshValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address":       basetypes.StringType{},
		"passphrase":       basetypes.StringType{},
		"port":             basetypes.StringType{},
		"private_key_path": basetypes.StringType{},
		"username":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TaintsType{}

type TaintsType struct {
	basetypes.ObjectType
}

func (t TaintsType) Equal(o attr.Type) bool {
	other, ok := o.(TaintsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TaintsType) String() string {
	return "TaintsType"
}

func (t TaintsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TaintsValue{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaintsValueNull() TaintsValue {
	return TaintsValue{
		state: attr.ValueStateNull,
	}
}

func NewTaintsValueUnknown() TaintsValue {
	return TaintsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTaintsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TaintsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TaintsValue Attribute Value",
				"While creating a TaintsValue value, a missing attribute value was detected. "+
					"A TaintsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaintsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TaintsValue Attribute Type",
				"While creating a TaintsValue value, an invalid attribute value was detected. "+
					"A TaintsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaintsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TaintsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TaintsValue Attribute Value",
				"While creating a TaintsValue value, an extra attribute value was detected. "+
					"A TaintsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TaintsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaintsValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTaintsValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTaintsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTaintsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTaintsValueUnknown(), diags
	}

	return TaintsValue{
		Effect: effectVal,
		Key:    keyVal,
		Value:  valueVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTaintsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TaintsValue {
	object, diags := NewTaintsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaintsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TaintsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaintsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaintsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaintsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaintsValueMust(TaintsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TaintsType) ValueType(ctx context.Context) attr.Value {
	return TaintsValue{}
}

var _ basetypes.ObjectValuable = TaintsValue{}

type TaintsValue struct {
	Effect basetypes.StringValue `tfsdk:"effect"`
	Key    basetypes.StringValue `tfsdk:"key"`
	Value  basetypes.StringValue `tfsdk:"value"`
	state  attr.ValueState
}

func (v TaintsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TaintsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TaintsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TaintsValue) String() string {
	return "TaintsValue"
}

func (v TaintsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect": v.Effect,
			"key":    v.Key,
			"value":  v.Value,
		})

	return objVal, diags
}

func (v TaintsValue) Equal(o attr.Value) bool {
	other, ok := o.(TaintsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TaintsValue) Type(ctx context.Context) attr.Type {
	return TaintsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TaintsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect": basetypes.StringType{},
		"key":    basetypes.StringType{},
		"value":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ProxyType{}

type ProxyType struct {
	basetypes.ObjectType
}

func (t ProxyType) Equal(o attr.Type) bool {
	other, ok := o.(ProxyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProxyType) String() string {
	return "ProxyType"
}

func (t ProxyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowInsecureBootstrapAttribute, ok := attributes["allow_insecure_bootstrap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_insecure_bootstrap is missing from object`)

		return nil, diags
	}

	allowInsecureBootstrapVal, ok := allowInsecureBootstrapAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_insecure_bootstrap expected to be basetypes.BoolValue, was: %T`, allowInsecureBootstrapAttribute))
	}

	bootstrapCaAttribute, ok := attributes["bootstrap_ca"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_ca is missing from object`)

		return nil, diags
	}

	bootstrapCaVal, ok := bootstrapCaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_ca expected to be basetypes.StringValue, was: %T`, bootstrapCaAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	httpProxyAttribute, ok := attributes["http_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_proxy is missing from object`)

		return nil, diags
	}

	httpProxyVal, ok := httpProxyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_proxy expected to be basetypes.StringValue, was: %T`, httpProxyAttribute))
	}

	httpsProxyAttribute, ok := attributes["https_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`https_proxy is missing from object`)

		return nil, diags
	}

	httpsProxyVal, ok := httpsProxyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`https_proxy expected to be basetypes.StringValue, was: %T`, httpsProxyAttribute))
	}

	noProxyAttribute, ok := attributes["no_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_proxy is missing from object`)

		return nil, diags
	}

	noProxyVal, ok := noProxyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_proxy expected to be basetypes.StringValue, was: %T`, noProxyAttribute))
	}

	proxyAuthAttribute, ok := attributes["proxy_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_auth is missing from object`)

		return nil, diags
	}

	proxyAuthVal, ok := proxyAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_auth expected to be basetypes.StringValue, was: %T`, proxyAuthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProxyValue{
		AllowInsecureBootstrap: allowInsecureBootstrapVal,
		BootstrapCa:            bootstrapCaVal,
		Enabled:                enabledVal,
		HttpProxy:              httpProxyVal,
		HttpsProxy:             httpsProxyVal,
		NoProxy:                noProxyVal,
		ProxyAuth:              proxyAuthVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewProxyValueNull() ProxyValue {
	return ProxyValue{
		state: attr.ValueStateNull,
	}
}

func NewProxyValueUnknown() ProxyValue {
	return ProxyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProxyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProxyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProxyValue Attribute Value",
				"While creating a ProxyValue value, a missing attribute value was detected. "+
					"A ProxyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProxyValue Attribute Type",
				"While creating a ProxyValue value, an invalid attribute value was detected. "+
					"A ProxyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProxyValue Attribute Value",
				"While creating a ProxyValue value, an extra attribute value was detected. "+
					"A ProxyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProxyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProxyValueUnknown(), diags
	}

	allowInsecureBootstrapAttribute, ok := attributes["allow_insecure_bootstrap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_insecure_bootstrap is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	allowInsecureBootstrapVal, ok := allowInsecureBootstrapAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_insecure_bootstrap expected to be basetypes.BoolValue, was: %T`, allowInsecureBootstrapAttribute))
	}

	bootstrapCaAttribute, ok := attributes["bootstrap_ca"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootstrap_ca is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	bootstrapCaVal, ok := bootstrapCaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootstrap_ca expected to be basetypes.StringValue, was: %T`, bootstrapCaAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	httpProxyAttribute, ok := attributes["http_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`http_proxy is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	httpProxyVal, ok := httpProxyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`http_proxy expected to be basetypes.StringValue, was: %T`, httpProxyAttribute))
	}

	httpsProxyAttribute, ok := attributes["https_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`https_proxy is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	httpsProxyVal, ok := httpsProxyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`https_proxy expected to be basetypes.StringValue, was: %T`, httpsProxyAttribute))
	}

	noProxyAttribute, ok := attributes["no_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_proxy is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	noProxyVal, ok := noProxyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_proxy expected to be basetypes.StringValue, was: %T`, noProxyAttribute))
	}

	proxyAuthAttribute, ok := attributes["proxy_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_auth is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	proxyAuthVal, ok := proxyAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_auth expected to be basetypes.StringValue, was: %T`, proxyAuthAttribute))
	}

	if diags.HasError() {
		return NewProxyValueUnknown(), diags
	}

	return ProxyValue{
		AllowInsecureBootstrap: allowInsecureBootstrapVal,
		BootstrapCa:            bootstrapCaVal,
		Enabled:                enabledVal,
		HttpProxy:              httpProxyVal,
		HttpsProxy:             httpsProxyVal,
		NoProxy:                noProxyVal,
		ProxyAuth:              proxyAuthVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewProxyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProxyValue {
	object, diags := NewProxyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProxyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProxyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProxyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProxyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProxyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProxyValueMust(ProxyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProxyType) ValueType(ctx context.Context) attr.Value {
	return ProxyValue{}
}

var _ basetypes.ObjectValuable = ProxyValue{}

type ProxyValue struct {
	AllowInsecureBootstrap basetypes.BoolValue   `tfsdk:"allow_insecure_bootstrap"`
	BootstrapCa            basetypes.StringValue `tfsdk:"bootstrap_ca"`
	Enabled                basetypes.BoolValue   `tfsdk:"enabled"`
	HttpProxy              basetypes.StringValue `tfsdk:"http_proxy"`
	HttpsProxy             basetypes.StringValue `tfsdk:"https_proxy"`
	NoProxy                basetypes.StringValue `tfsdk:"no_proxy"`
	ProxyAuth              basetypes.StringValue `tfsdk:"proxy_auth"`
	state                  attr.ValueState
}

func (v ProxyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["allow_insecure_bootstrap"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bootstrap_ca"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["http_proxy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["https_proxy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["no_proxy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["proxy_auth"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AllowInsecureBootstrap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_insecure_bootstrap"] = val

		val, err = v.BootstrapCa.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bootstrap_ca"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.HttpProxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["http_proxy"] = val

		val, err = v.HttpsProxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["https_proxy"] = val

		val, err = v.NoProxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_proxy"] = val

		val, err = v.ProxyAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_auth"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProxyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProxyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProxyValue) String() string {
	return "ProxyValue"
}

func (v ProxyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"allow_insecure_bootstrap": basetypes.BoolType{},
		"bootstrap_ca":             basetypes.StringType{},
		"enabled":                  basetypes.BoolType{},
		"http_proxy":               basetypes.StringType{},
		"https_proxy":              basetypes.StringType{},
		"no_proxy":                 basetypes.StringType{},
		"proxy_auth":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_insecure_bootstrap": v.AllowInsecureBootstrap,
			"bootstrap_ca":             v.BootstrapCa,
			"enabled":                  v.Enabled,
			"http_proxy":               v.HttpProxy,
			"https_proxy":              v.HttpsProxy,
			"no_proxy":                 v.NoProxy,
			"proxy_auth":               v.ProxyAuth,
		})

	return objVal, diags
}

func (v ProxyValue) Equal(o attr.Value) bool {
	other, ok := o.(ProxyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowInsecureBootstrap.Equal(other.AllowInsecureBootstrap) {
		return false
	}

	if !v.BootstrapCa.Equal(other.BootstrapCa) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.HttpProxy.Equal(other.HttpProxy) {
		return false
	}

	if !v.HttpsProxy.Equal(other.HttpsProxy) {
		return false
	}

	if !v.NoProxy.Equal(other.NoProxy) {
		return false
	}

	if !v.ProxyAuth.Equal(other.ProxyAuth) {
		return false
	}

	return true
}

func (v ProxyValue) Type(ctx context.Context) attr.Type {
	return ProxyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProxyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_insecure_bootstrap": basetypes.BoolType{},
		"bootstrap_ca":             basetypes.StringType{},
		"enabled":                  basetypes.BoolType{},
		"http_proxy":               basetypes.StringType{},
		"https_proxy":              basetypes.StringType{},
		"no_proxy":                 basetypes.StringType{},
		"proxy_auth":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SharingType{}

type SharingType struct {
	basetypes.ObjectType
}

func (t SharingType) Equal(o attr.Type) bool {
	other, ok := o.(SharingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SharingType) String() string {
	return "SharingType"
}

func (t SharingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	projectsAttribute, ok := attributes["projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`projects is missing from object`)

		return nil, diags
	}

	projectsVal, ok := projectsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`projects expected to be basetypes.SetValue, was: %T`, projectsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SharingValue{
		Enabled:  enabledVal,
		Projects: projectsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSharingValueNull() SharingValue {
	return SharingValue{
		state: attr.ValueStateNull,
	}
}

func NewSharingValueUnknown() SharingValue {
	return SharingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSharingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SharingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SharingValue Attribute Value",
				"While creating a SharingValue value, a missing attribute value was detected. "+
					"A SharingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SharingValue Attribute Type",
				"While creating a SharingValue value, an invalid attribute value was detected. "+
					"A SharingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SharingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SharingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SharingValue Attribute Value",
				"While creating a SharingValue value, an extra attribute value was detected. "+
					"A SharingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SharingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSharingValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSharingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	projectsAttribute, ok := attributes["projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`projects is missing from object`)

		return NewSharingValueUnknown(), diags
	}

	projectsVal, ok := projectsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`projects expected to be basetypes.SetValue, was: %T`, projectsAttribute))
	}

	if diags.HasError() {
		return NewSharingValueUnknown(), diags
	}

	return SharingValue{
		Enabled:  enabledVal,
		Projects: projectsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSharingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SharingValue {
	object, diags := NewSharingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSharingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SharingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSharingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSharingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSharingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSharingValueMust(SharingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SharingType) ValueType(ctx context.Context) attr.Value {
	return SharingValue{}
}

var _ basetypes.ObjectValuable = SharingValue{}

type SharingValue struct {
	Enabled  basetypes.BoolValue `tfsdk:"enabled"`
	Projects basetypes.SetValue  `tfsdk:"projects"`
	state    attr.ValueState
}

func (v SharingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["projects"] = basetypes.SetType{
		ElemType: ProjectsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Projects.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["projects"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SharingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SharingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SharingValue) String() string {
	return "SharingValue"
}

func (v SharingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	projects := types.SetValueMust(
		ProjectsType{
			basetypes.ObjectType{
				AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
			},
		},
		v.Projects.Elements(),
	)

	if v.Projects.IsNull() {
		projects = types.SetNull(
			ProjectsType{
				basetypes.ObjectType{
					AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Projects.IsUnknown() {
		projects = types.SetUnknown(
			ProjectsType{
				basetypes.ObjectType{
					AttrTypes: ProjectsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"projects": basetypes.SetType{
			ElemType: ProjectsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":  v.Enabled,
			"projects": projects,
		})

	return objVal, diags
}

func (v SharingValue) Equal(o attr.Value) bool {
	other, ok := o.(SharingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Projects.Equal(other.Projects) {
		return false
	}

	return true
}

func (v SharingValue) Type(ctx context.Context) attr.Type {
	return SharingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SharingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"projects": basetypes.SetType{
			ElemType: ProjectsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ProjectsType{}

type ProjectsType struct {
	basetypes.ObjectType
}

func (t ProjectsType) Equal(o attr.Type) bool {
	other, ok := o.(ProjectsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProjectsType) String() string {
	return "ProjectsType"
}

func (t ProjectsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProjectsValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProjectsValueNull() ProjectsValue {
	return ProjectsValue{
		state: attr.ValueStateNull,
	}
}

func NewProjectsValueUnknown() ProjectsValue {
	return ProjectsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProjectsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProjectsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProjectsValue Attribute Value",
				"While creating a ProjectsValue value, a missing attribute value was detected. "+
					"A ProjectsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProjectsValue Attribute Type",
				"While creating a ProjectsValue value, an invalid attribute value was detected. "+
					"A ProjectsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProjectsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProjectsValue Attribute Value",
				"While creating a ProjectsValue value, an extra attribute value was detected. "+
					"A ProjectsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProjectsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProjectsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewProjectsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewProjectsValueUnknown(), diags
	}

	return ProjectsValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProjectsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProjectsValue {
	object, diags := NewProjectsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProjectsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProjectsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProjectsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProjectsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProjectsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProjectsValueMust(ProjectsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProjectsType) ValueType(ctx context.Context) attr.Value {
	return ProjectsValue{}
}

var _ basetypes.ObjectValuable = ProjectsValue{}

type ProjectsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v ProjectsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProjectsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProjectsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProjectsValue) String() string {
	return "ProjectsValue"
}

func (v ProjectsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v ProjectsValue) Equal(o attr.Value) bool {
	other, ok := o.(ProjectsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ProjectsValue) Type(ctx context.Context) attr.Type {
	return ProjectsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProjectsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SystemComponentsPlacementType{}

type SystemComponentsPlacementType struct {
	basetypes.ObjectType
}

func (t SystemComponentsPlacementType) Equal(o attr.Type) bool {
	other, ok := o.(SystemComponentsPlacementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SystemComponentsPlacementType) String() string {
	return "SystemComponentsPlacementType"
}

func (t SystemComponentsPlacementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	daemonSetOverrideAttribute, ok := attributes["daemon_set_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daemon_set_override is missing from object`)

		return nil, diags
	}

	daemonSetOverrideVal, ok := daemonSetOverrideAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daemon_set_override expected to be basetypes.ObjectValue, was: %T`, daemonSetOverrideAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return nil, diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.MapValue, was: %T`, nodeSelectorAttribute))
	}

	tolerationsAttribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations is missing from object`)

		return nil, diags
	}

	tolerationsVal, ok := tolerationsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations expected to be basetypes.SetValue, was: %T`, tolerationsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SystemComponentsPlacementValue{
		DaemonSetOverride: daemonSetOverrideVal,
		NodeSelector:      nodeSelectorVal,
		Tolerations:       tolerationsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSystemComponentsPlacementValueNull() SystemComponentsPlacementValue {
	return SystemComponentsPlacementValue{
		state: attr.ValueStateNull,
	}
}

func NewSystemComponentsPlacementValueUnknown() SystemComponentsPlacementValue {
	return SystemComponentsPlacementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSystemComponentsPlacementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SystemComponentsPlacementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SystemComponentsPlacementValue Attribute Value",
				"While creating a SystemComponentsPlacementValue value, a missing attribute value was detected. "+
					"A SystemComponentsPlacementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SystemComponentsPlacementValue Attribute Type",
				"While creating a SystemComponentsPlacementValue value, an invalid attribute value was detected. "+
					"A SystemComponentsPlacementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SystemComponentsPlacementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SystemComponentsPlacementValue Attribute Value",
				"While creating a SystemComponentsPlacementValue value, an extra attribute value was detected. "+
					"A SystemComponentsPlacementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SystemComponentsPlacementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	daemonSetOverrideAttribute, ok := attributes["daemon_set_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daemon_set_override is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	daemonSetOverrideVal, ok := daemonSetOverrideAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daemon_set_override expected to be basetypes.ObjectValue, was: %T`, daemonSetOverrideAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.MapValue, was: %T`, nodeSelectorAttribute))
	}

	tolerationsAttribute, ok := attributes["tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tolerations is missing from object`)

		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	tolerationsVal, ok := tolerationsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tolerations expected to be basetypes.SetValue, was: %T`, tolerationsAttribute))
	}

	if diags.HasError() {
		return NewSystemComponentsPlacementValueUnknown(), diags
	}

	return SystemComponentsPlacementValue{
		DaemonSetOverride: daemonSetOverrideVal,
		NodeSelector:      nodeSelectorVal,
		Tolerations:       tolerationsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSystemComponentsPlacementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SystemComponentsPlacementValue {
	object, diags := NewSystemComponentsPlacementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSystemComponentsPlacementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SystemComponentsPlacementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSystemComponentsPlacementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSystemComponentsPlacementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSystemComponentsPlacementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSystemComponentsPlacementValueMust(SystemComponentsPlacementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SystemComponentsPlacementType) ValueType(ctx context.Context) attr.Value {
	return SystemComponentsPlacementValue{}
}

var _ basetypes.ObjectValuable = SystemComponentsPlacementValue{}

type SystemComponentsPlacementValue struct {
	DaemonSetOverride basetypes.ObjectValue `tfsdk:"daemon_set_override"`
	NodeSelector      basetypes.MapValue    `tfsdk:"node_selector"`
	Tolerations       basetypes.SetValue    `tfsdk:"tolerations"`
	state             attr.ValueState
}

func (v SystemComponentsPlacementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["daemon_set_override"] = basetypes.ObjectType{
		AttrTypes: DaemonSetOverrideValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["node_selector"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tolerations"] = basetypes.SetType{
		ElemType: TolerationsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DaemonSetOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daemon_set_override"] = val

		val, err = v.NodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selector"] = val

		val, err = v.Tolerations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tolerations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SystemComponentsPlacementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SystemComponentsPlacementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SystemComponentsPlacementValue) String() string {
	return "SystemComponentsPlacementValue"
}

func (v SystemComponentsPlacementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var daemonSetOverride basetypes.ObjectValue

	if v.DaemonSetOverride.IsNull() {
		daemonSetOverride = types.ObjectNull(
			DaemonSetOverrideValue{}.AttributeTypes(ctx),
		)
	}

	if v.DaemonSetOverride.IsUnknown() {
		daemonSetOverride = types.ObjectUnknown(
			DaemonSetOverrideValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DaemonSetOverride.IsNull() && !v.DaemonSetOverride.IsUnknown() {
		daemonSetOverride = types.ObjectValueMust(
			DaemonSetOverrideValue{}.AttributeTypes(ctx),
			v.DaemonSetOverride.Attributes(),
		)
	}

	tolerations := types.SetValueMust(
		TolerationsType{
			basetypes.ObjectType{
				AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
			},
		},
		v.Tolerations.Elements(),
	)

	if v.Tolerations.IsNull() {
		tolerations = types.SetNull(
			TolerationsType{
				basetypes.ObjectType{
					AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tolerations.IsUnknown() {
		tolerations = types.SetUnknown(
			TolerationsType{
				basetypes.ObjectType{
					AttrTypes: TolerationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var nodeSelectorVal basetypes.MapValue
	switch {
	case v.NodeSelector.IsUnknown():
		nodeSelectorVal = types.MapUnknown(types.StringType)
	case v.NodeSelector.IsNull():
		nodeSelectorVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorVal, d = types.MapValue(types.StringType, v.NodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"daemon_set_override": basetypes.ObjectType{
				AttrTypes: DaemonSetOverrideValue{}.AttributeTypes(ctx),
			},
			"node_selector": basetypes.MapType{
				ElemType: types.StringType,
			},
			"tolerations": basetypes.SetType{
				ElemType: TolerationsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"daemon_set_override": basetypes.ObjectType{
			AttrTypes: DaemonSetOverrideValue{}.AttributeTypes(ctx),
		},
		"node_selector": basetypes.MapType{
			ElemType: types.StringType,
		},
		"tolerations": basetypes.SetType{
			ElemType: TolerationsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"daemon_set_override": daemonSetOverride,
			"node_selector":       nodeSelectorVal,
			"tolerations":         tolerations,
		})

	return objVal, diags
}

func (v SystemComponentsPlacementValue) Equal(o attr.Value) bool {
	other, ok := o.(SystemComponentsPlacementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DaemonSetOverride.Equal(other.DaemonSetOverride) {
		return false
	}

	if !v.NodeSelector.Equal(other.NodeSelector) {
		return false
	}

	if !v.Tolerations.Equal(other.Tolerations) {
		return false
	}

	return true
}

func (v SystemComponentsPlacementValue) Type(ctx context.Context) attr.Type {
	return SystemComponentsPlacementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SystemComponentsPlacementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daemon_set_override": basetypes.ObjectType{
			AttrTypes: DaemonSetOverrideValue{}.AttributeTypes(ctx),
		},
		"node_selector": basetypes.MapType{
			ElemType: types.StringType,
		},
		"tolerations": basetypes.SetType{
			ElemType: TolerationsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DaemonSetOverrideType{}

type DaemonSetOverrideType struct {
	basetypes.ObjectType
}

func (t DaemonSetOverrideType) Equal(o attr.Type) bool {
	other, ok := o.(DaemonSetOverrideType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DaemonSetOverrideType) String() string {
	return "DaemonSetOverrideType"
}

func (t DaemonSetOverrideType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	daemonSetTolerationsAttribute, ok := attributes["daemon_set_tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daemon_set_tolerations is missing from object`)

		return nil, diags
	}

	daemonSetTolerationsVal, ok := daemonSetTolerationsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daemon_set_tolerations expected to be basetypes.SetValue, was: %T`, daemonSetTolerationsAttribute))
	}

	nodeSelectionEnabledAttribute, ok := attributes["node_selection_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selection_enabled is missing from object`)

		return nil, diags
	}

	nodeSelectionEnabledVal, ok := nodeSelectionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selection_enabled expected to be basetypes.BoolValue, was: %T`, nodeSelectionEnabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DaemonSetOverrideValue{
		DaemonSetTolerations: daemonSetTolerationsVal,
		NodeSelectionEnabled: nodeSelectionEnabledVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDaemonSetOverrideValueNull() DaemonSetOverrideValue {
	return DaemonSetOverrideValue{
		state: attr.ValueStateNull,
	}
}

func NewDaemonSetOverrideValueUnknown() DaemonSetOverrideValue {
	return DaemonSetOverrideValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDaemonSetOverrideValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DaemonSetOverrideValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DaemonSetOverrideValue Attribute Value",
				"While creating a DaemonSetOverrideValue value, a missing attribute value was detected. "+
					"A DaemonSetOverrideValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DaemonSetOverrideValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DaemonSetOverrideValue Attribute Type",
				"While creating a DaemonSetOverrideValue value, an invalid attribute value was detected. "+
					"A DaemonSetOverrideValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DaemonSetOverrideValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DaemonSetOverrideValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DaemonSetOverrideValue Attribute Value",
				"While creating a DaemonSetOverrideValue value, an extra attribute value was detected. "+
					"A DaemonSetOverrideValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DaemonSetOverrideValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDaemonSetOverrideValueUnknown(), diags
	}

	daemonSetTolerationsAttribute, ok := attributes["daemon_set_tolerations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daemon_set_tolerations is missing from object`)

		return NewDaemonSetOverrideValueUnknown(), diags
	}

	daemonSetTolerationsVal, ok := daemonSetTolerationsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daemon_set_tolerations expected to be basetypes.SetValue, was: %T`, daemonSetTolerationsAttribute))
	}

	nodeSelectionEnabledAttribute, ok := attributes["node_selection_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selection_enabled is missing from object`)

		return NewDaemonSetOverrideValueUnknown(), diags
	}

	nodeSelectionEnabledVal, ok := nodeSelectionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selection_enabled expected to be basetypes.BoolValue, was: %T`, nodeSelectionEnabledAttribute))
	}

	if diags.HasError() {
		return NewDaemonSetOverrideValueUnknown(), diags
	}

	return DaemonSetOverrideValue{
		DaemonSetTolerations: daemonSetTolerationsVal,
		NodeSelectionEnabled: nodeSelectionEnabledVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDaemonSetOverrideValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DaemonSetOverrideValue {
	object, diags := NewDaemonSetOverrideValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDaemonSetOverrideValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DaemonSetOverrideType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDaemonSetOverrideValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDaemonSetOverrideValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDaemonSetOverrideValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDaemonSetOverrideValueMust(DaemonSetOverrideValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DaemonSetOverrideType) ValueType(ctx context.Context) attr.Value {
	return DaemonSetOverrideValue{}
}

var _ basetypes.ObjectValuable = DaemonSetOverrideValue{}

type DaemonSetOverrideValue struct {
	DaemonSetTolerations basetypes.SetValue  `tfsdk:"daemon_set_tolerations"`
	NodeSelectionEnabled basetypes.BoolValue `tfsdk:"node_selection_enabled"`
	state                attr.ValueState
}

func (v DaemonSetOverrideValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["daemon_set_tolerations"] = basetypes.SetType{
		ElemType: DaemonSetTolerationsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["node_selection_enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.DaemonSetTolerations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daemon_set_tolerations"] = val

		val, err = v.NodeSelectionEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selection_enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DaemonSetOverrideValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DaemonSetOverrideValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DaemonSetOverrideValue) String() string {
	return "DaemonSetOverrideValue"
}

func (v DaemonSetOverrideValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	daemonSetTolerations := types.SetValueMust(
		DaemonSetTolerationsType{
			basetypes.ObjectType{
				AttrTypes: DaemonSetTolerationsValue{}.AttributeTypes(ctx),
			},
		},
		v.DaemonSetTolerations.Elements(),
	)

	if v.DaemonSetTolerations.IsNull() {
		daemonSetTolerations = types.SetNull(
			DaemonSetTolerationsType{
				basetypes.ObjectType{
					AttrTypes: DaemonSetTolerationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DaemonSetTolerations.IsUnknown() {
		daemonSetTolerations = types.SetUnknown(
			DaemonSetTolerationsType{
				basetypes.ObjectType{
					AttrTypes: DaemonSetTolerationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"daemon_set_tolerations": basetypes.SetType{
			ElemType: DaemonSetTolerationsValue{}.Type(ctx),
		},
		"node_selection_enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"daemon_set_tolerations": daemonSetTolerations,
			"node_selection_enabled": v.NodeSelectionEnabled,
		})

	return objVal, diags
}

func (v DaemonSetOverrideValue) Equal(o attr.Value) bool {
	other, ok := o.(DaemonSetOverrideValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DaemonSetTolerations.Equal(other.DaemonSetTolerations) {
		return false
	}

	if !v.NodeSelectionEnabled.Equal(other.NodeSelectionEnabled) {
		return false
	}

	return true
}

func (v DaemonSetOverrideValue) Type(ctx context.Context) attr.Type {
	return DaemonSetOverrideType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DaemonSetOverrideValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daemon_set_tolerations": basetypes.SetType{
			ElemType: DaemonSetTolerationsValue{}.Type(ctx),
		},
		"node_selection_enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = DaemonSetTolerationsType{}

type DaemonSetTolerationsType struct {
	basetypes.ObjectType
}

func (t DaemonSetTolerationsType) Equal(o attr.Type) bool {
	other, ok := o.(DaemonSetTolerationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DaemonSetTolerationsType) String() string {
	return "DaemonSetTolerationsType"
}

func (t DaemonSetTolerationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return nil, diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return nil, diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DaemonSetTolerationsValue{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDaemonSetTolerationsValueNull() DaemonSetTolerationsValue {
	return DaemonSetTolerationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDaemonSetTolerationsValueUnknown() DaemonSetTolerationsValue {
	return DaemonSetTolerationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDaemonSetTolerationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DaemonSetTolerationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DaemonSetTolerationsValue Attribute Value",
				"While creating a DaemonSetTolerationsValue value, a missing attribute value was detected. "+
					"A DaemonSetTolerationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DaemonSetTolerationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DaemonSetTolerationsValue Attribute Type",
				"While creating a DaemonSetTolerationsValue value, an invalid attribute value was detected. "+
					"A DaemonSetTolerationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DaemonSetTolerationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DaemonSetTolerationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DaemonSetTolerationsValue Attribute Value",
				"While creating a DaemonSetTolerationsValue value, an extra attribute value was detected. "+
					"A DaemonSetTolerationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DaemonSetTolerationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDaemonSetTolerationsValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewDaemonSetTolerationsValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewDaemonSetTolerationsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return NewDaemonSetTolerationsValueUnknown(), diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return NewDaemonSetTolerationsValueUnknown(), diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewDaemonSetTolerationsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewDaemonSetTolerationsValueUnknown(), diags
	}

	return DaemonSetTolerationsValue{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDaemonSetTolerationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DaemonSetTolerationsValue {
	object, diags := NewDaemonSetTolerationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDaemonSetTolerationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DaemonSetTolerationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDaemonSetTolerationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDaemonSetTolerationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDaemonSetTolerationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDaemonSetTolerationsValueMust(DaemonSetTolerationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DaemonSetTolerationsType) ValueType(ctx context.Context) attr.Value {
	return DaemonSetTolerationsValue{}
}

var _ basetypes.ObjectValuable = DaemonSetTolerationsValue{}

type DaemonSetTolerationsValue struct {
	Effect            basetypes.StringValue `tfsdk:"effect"`
	Key               basetypes.StringValue `tfsdk:"key"`
	Operator          basetypes.StringValue `tfsdk:"operator"`
	TolerationSeconds basetypes.Int64Value  `tfsdk:"toleration_seconds"`
	Value             basetypes.StringValue `tfsdk:"value"`
	state             attr.ValueState
}

func (v DaemonSetTolerationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["toleration_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Operator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operator"] = val

		val, err = v.TolerationSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["toleration_seconds"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DaemonSetTolerationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DaemonSetTolerationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DaemonSetTolerationsValue) String() string {
	return "DaemonSetTolerationsValue"
}

func (v DaemonSetTolerationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect":             v.Effect,
			"key":                v.Key,
			"operator":           v.Operator,
			"toleration_seconds": v.TolerationSeconds,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v DaemonSetTolerationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DaemonSetTolerationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Operator.Equal(other.Operator) {
		return false
	}

	if !v.TolerationSeconds.Equal(other.TolerationSeconds) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v DaemonSetTolerationsValue) Type(ctx context.Context) attr.Type {
	return DaemonSetTolerationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DaemonSetTolerationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TolerationsType{}

type TolerationsType struct {
	basetypes.ObjectType
}

func (t TolerationsType) Equal(o attr.Type) bool {
	other, ok := o.(TolerationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TolerationsType) String() string {
	return "TolerationsType"
}

func (t TolerationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return nil, diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return nil, diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return nil, diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TolerationsValue{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerationsValueNull() TolerationsValue {
	return TolerationsValue{
		state: attr.ValueStateNull,
	}
}

func NewTolerationsValueUnknown() TolerationsValue {
	return TolerationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTolerationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TolerationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TolerationsValue Attribute Value",
				"While creating a TolerationsValue value, a missing attribute value was detected. "+
					"A TolerationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TolerationsValue Attribute Type",
				"While creating a TolerationsValue value, an invalid attribute value was detected. "+
					"A TolerationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TolerationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TolerationsValue Attribute Value",
				"While creating a TolerationsValue value, an extra attribute value was detected. "+
					"A TolerationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TolerationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTolerationsValueUnknown(), diags
	}

	effectAttribute, ok := attributes["effect"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`effect is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	effectVal, ok := effectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`effect expected to be basetypes.StringValue, was: %T`, effectAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	operatorAttribute, ok := attributes["operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operator is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	operatorVal, ok := operatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operator expected to be basetypes.StringValue, was: %T`, operatorAttribute))
	}

	tolerationSecondsAttribute, ok := attributes["toleration_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`toleration_seconds is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	tolerationSecondsVal, ok := tolerationSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`toleration_seconds expected to be basetypes.Int64Value, was: %T`, tolerationSecondsAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTolerationsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTolerationsValueUnknown(), diags
	}

	return TolerationsValue{
		Effect:            effectVal,
		Key:               keyVal,
		Operator:          operatorVal,
		TolerationSeconds: tolerationSecondsVal,
		Value:             valueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTolerationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TolerationsValue {
	object, diags := NewTolerationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTolerationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TolerationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTolerationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTolerationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTolerationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTolerationsValueMust(TolerationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TolerationsType) ValueType(ctx context.Context) attr.Value {
	return TolerationsValue{}
}

var _ basetypes.ObjectValuable = TolerationsValue{}

type TolerationsValue struct {
	Effect            basetypes.StringValue `tfsdk:"effect"`
	Key               basetypes.StringValue `tfsdk:"key"`
	Operator          basetypes.StringValue `tfsdk:"operator"`
	TolerationSeconds basetypes.Int64Value  `tfsdk:"toleration_seconds"`
	Value             basetypes.StringValue `tfsdk:"value"`
	state             attr.ValueState
}

func (v TolerationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["effect"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["toleration_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Effect.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["effect"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Operator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operator"] = val

		val, err = v.TolerationSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["toleration_seconds"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TolerationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TolerationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TolerationsValue) String() string {
	return "TolerationsValue"
}

func (v TolerationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"effect":             v.Effect,
			"key":                v.Key,
			"operator":           v.Operator,
			"toleration_seconds": v.TolerationSeconds,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v TolerationsValue) Equal(o attr.Value) bool {
	other, ok := o.(TolerationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Effect.Equal(other.Effect) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Operator.Equal(other.Operator) {
		return false
	}

	if !v.TolerationSeconds.Equal(other.TolerationSeconds) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TolerationsValue) Type(ctx context.Context) attr.Type {
	return TolerationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TolerationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"effect":             basetypes.StringType{},
		"key":                basetypes.StringType{},
		"operator":           basetypes.StringType{},
		"toleration_seconds": basetypes.Int64Type{},
		"value":              basetypes.StringType{},
	}
}
